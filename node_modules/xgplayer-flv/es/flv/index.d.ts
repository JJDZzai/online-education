export const logger: Logger;
/**
 * @typedef {import("../../../xgplayer-streaming-shared/es/services/stats").StatsInfo} Stats
 */
export class Flv {
    /**
     * @param {('video'|'audio')?} mediaType
     * @returns {Boolean}
     */
    static isSupported(mediaType: ('video' | 'audio') | null): boolean;
    static enableLogger(): void;
    static disableLogger(): void;
    /**
     * @param {import('./options').FlvOption} opts
     */
    constructor(opts: import('./options').FlvOption);
    /** @type {HTMLMediaElement | null} */
    media: HTMLMediaElement | null;
    _loading: boolean;
    /** @type {import('./options').FlvOption} */
    _opts: import('./options').FlvOption;
    /** @type {BufferService} */
    _bufferService: BufferService;
    /** @type {GapService} */
    _gapService: GapService;
    /** @type {MediaStatsService} */
    _stats: MediaStatsService;
    /** @type {NetLoader} */
    _mediaLoader: NetLoader;
    _maxChunkWaitTimer: any;
    _tickTimer: any;
    _tickInterval: number;
    _urlSwitching: boolean;
    _seamlessSwitching: boolean;
    _keyframes: any;
    _acceptRanges: boolean;
    _firstProgressEmit: boolean;
    _seiService: SeiService;
    _bandwidthService: BandwidthService;
    get version(): any;
    get isLive(): boolean;
    get baseDts(): number;
    get seekable(): boolean;
    speedInfo(): {
        speed: any;
        avgSpeed: number;
    };
    /**
     * @returns {Stats}
     */
    getStats(): Stats;
    bufferInfo(maxHole?: number): {
        start: number;
        end: number;
        buffers: [number, number][];
        remaining: number;
        index?: number;
        nextStart?: number;
        nextEnd?: number;
        prevStart?: number;
        prevEnd?: number;
    };
    playbackQuality(): {
        droppedVideoFrames?: undefined;
        totalVideoFrames?: undefined;
        creationTime?: undefined;
    } | {
        droppedVideoFrames: any;
        totalVideoFrames: any;
        creationTime: any;
    };
    /**
     * load or reload source
     * @param {string} [url]
     * @return {Promise}
     */
    load(url?: string, reuseMse?: boolean): Promise<any>;
    /** @return {Promise} */
    replay(seamlesslyReload: boolean, isPlayEmit: any): Promise<any>;
    disconnect(): Promise<void>;
    /**
     * @param {string} url
     * @param {boolean} [seamless=false]
     */
    switchURL(url: string, seamless?: boolean): Promise<void>;
    /** @return {Promise} */
    destroy(): Promise<any>;
    _emitError(error: any, endOfStream?: boolean): void;
    _reset(reuseMse?: boolean): Promise<void>;
    _loadData(url: any, range: any): Promise<void>;
    /**
     *
     * @param {ArrayBuffer} chunk
     * @param {boolean} done
     * @param { {startTime: number, endTime: number, st: number, firstByteTime: number}}
     * startTime: 当前流式分段开始read时间
     * endTime: 当前流式分段结束read时间
     * st: 拉流开始时间
     * firstByteTime: 首字节响应时间
     * @param {Response} response
     */
    _onProgress: (chunk: ArrayBuffer, done: boolean, { startTime, endTime, st, firstByteTime }: {
        startTime: number;
        endTime: number;
        st: number;
        firstByteTime: number;
    }, response: Response) => Promise<void>;
    _onRetryError: (error: any, retryTime: any) => void;
    _clear(): Promise<void>;
    _end: () => void;
    _tick: () => void;
    _onPlay: () => void;
    _onSeeking: () => Promise<void>;
    _onTimeupdate: () => void;
    _onFlvScriptData: (sample: any) => void;
}
export type Stats = import("../../../xgplayer-streaming-shared/es/services/stats").StatsInfo;
import { Logger } from "xgplayer-streaming-shared";
import { BufferService } from "./services/buffer-service";
import { GapService } from "../../../xgplayer-streaming-shared/es/services";
import { MediaStatsService } from "../../../xgplayer-streaming-shared/es/services";
import { NetLoader } from "../../../xgplayer-streaming-shared/es/net";
import { SeiService } from "../../../xgplayer-streaming-shared/es/services";
import { BandwidthService } from "../../../xgplayer-streaming-shared/es/services";
