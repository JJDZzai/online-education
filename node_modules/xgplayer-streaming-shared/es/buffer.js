import { createClass as _createClass, classCallCheck as _classCallCheck } from "./_virtual/_rollupPluginBabelHelpers.js";
var Buffer = /* @__PURE__ */ function() {
  function Buffer2() {
    _classCallCheck(this, Buffer2);
  }
  _createClass(Buffer2, null, [{
    key: "start",
    value: function start(buf) {
      if (!buf || !buf.length)
        return 0;
      if (buf.length === 1 && buf.end(0) - buf.start(0) < 1e-6)
        return 0;
      if (buf.length === 1 && buf.start(0) < 0)
        return 0;
      return buf.start(0);
    }
  }, {
    key: "end",
    value: function end(buf) {
      if (!buf || !buf.length)
        return 0;
      if (buf.length === 1 && buf.end(0) - buf.start(0) < 1e-6)
        return 0;
      return buf.end(buf.length - 1);
    }
  }, {
    key: "get",
    value: function get(b) {
      if (!b)
        return;
      try {
        return b.buffered;
      } catch (error) {
      }
    }
  }, {
    key: "buffers",
    value: function buffers(buf, maxHole) {
      if (!buf || !buf.length)
        return [];
      var buffers2 = [];
      for (var i = 0, l = buf.length; i < l; i++) {
        var bufLen = buffers2.length;
        if (!bufLen || !maxHole) {
          buffers2.push([buf.start(i), buf.end(i)]);
        } else {
          var last = buffers2[bufLen - 1];
          var lastEnd = last[1];
          var start = buf.start(i);
          if (start - lastEnd <= maxHole) {
            var end = buf.end(i);
            if (end > lastEnd) {
              last[1] = end;
            }
          } else {
            buffers2.push([buf.start(i), buf.end(i)]);
          }
        }
      }
      return buffers2;
    }
  }, {
    key: "totalLength",
    value: function totalLength(buffers) {
      if (!buffers || !buffers.length)
        return 0;
      return buffers.reduce(function(a, c) {
        return a += c[1] - c[0];
      }, 0);
    }
  }, {
    key: "info",
    value: function info(buf) {
      var pos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var maxHole = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (!buf || !buf.length)
        return {
          start: 0,
          end: 0,
          buffers: []
        };
      var start = 0;
      var end = 0;
      var index = 0;
      var nextStart = 0;
      var nextEnd = 0;
      var prevStart = 0;
      var prevEnd = 0;
      var buffers = Buffer2.buffers(buf, maxHole);
      for (var i = 0, l = buffers.length; i < l; i++) {
        var item = buffers[i];
        if (pos + maxHole >= item[0] && pos < item[1]) {
          start = item[0];
          end = item[1];
          index = i;
        } else if (pos + maxHole < item[0]) {
          nextStart = item[0];
          nextEnd = item[1];
          break;
        } else if (pos + maxHole > item[1]) {
          prevStart = item[0];
          prevEnd = item[1];
        }
      }
      return {
        start,
        end,
        index,
        buffers,
        nextStart,
        nextEnd,
        prevStart,
        prevEnd,
        currentTime: pos,
        behind: pos - start,
        remaining: end ? end - pos : 0,
        length: Buffer2.totalLength && Buffer2.totalLength(buffers)
      };
    }
  }]);
  return Buffer2;
}();
export { Buffer };
