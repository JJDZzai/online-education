export type MSEErrorType = string;
export namespace MSEErrorType {
    const UPDATE_ERROR: string;
}
export class MSEError extends Error {
    /**
     * @param {MSEErrorType} type
     * @param {any} [msg]
     */
    constructor(type: MSEErrorType, msg?: any);
    type: string;
    msg: any;
}
export class MSE {
    static VIDEO: string;
    static AUDIO: string;
    static getDefaultConfig(): {
        openLog: boolean;
    };
    /**
     * @param {string} [mime='video/mp4; codecs="avc1.42E01E,mp4a.40.2"']
     * @returns {boolean}
     */
    static isSupported(mime?: string): boolean;
    /**
     * @param {HTMLMediaElement} [media]
     */
    constructor(media?: HTMLMediaElement, config: any);
    /** @type { HTMLMediaElement | null } */
    media: HTMLMediaElement | null;
    /** @type { MediaSource | null } */
    mediaSource: MediaSource | null;
    _openPromise: Promise<any>;
    _queue: any;
    _sourceBuffer: any;
    _mseFullFlag: {};
    _st: number;
    _opst: number;
    _logger: any;
    _config: any;
    _url: any;
    get isOpened(): boolean;
    get url(): any;
    get duration(): number;
    get isEnded(): boolean;
    isFull(type: any): any;
    /**
     * @param { number } duration
     * @return { Promise }
     */
    updateDuration(duration: number): Promise<any>;
    /** @return { Promise } */
    open(): Promise<any>;
    /**
     * @param { HTMLMediaElement } media
     * @return { Promise }
     */
    bindMedia(media: HTMLMediaElement): Promise<any>;
    /** @return { Promise } */
    unbindMedia(): Promise<any>;
    /**
     * @param { string } type
     * @param { string } mimeType
     */
    createSource(type: string, mimeType: string): void;
    /**
     * @param { string } type
     * @param { string } mimeType
     * @return { Promise }
     */
    changeType(type: string, mimeType: string): Promise<any>;
    /**
     * @param { string } type
     * @param { string } mimeType
     * @return { Promise }
     */
    createOrChangeSource(type: string, mimeType: string): Promise<any>;
    /**
     * @param { string } type
     * @param { BufferSource } buffer
     * @return { Promise }
     */
    append(type: string, buffer: BufferSource, context: any): Promise<any>;
    /**
     * @param { string } type
     * @param { number } startTime
     * @param { number } endTime
     * @return { Promise }
     */
    remove(type: string, startTime: number, endTime: number, context: any): Promise<any>;
    clearBuffer(startTime: any, endTime: any): undefined;
    clearAllBuffer(): undefined;
    clearOpQueues(type: any): void;
    /**
     * @param {EndOfStreamError} [reason]
     * @returns {Promise}
     */
    endOfStream(reason?: EndOfStreamError): Promise<any>;
    setLiveSeekableRange(start: any, end: any): void;
    /**
     * @param {string} type
     * @returns {?SourceBuffer}
     */
    getSourceBuffer(type: string): SourceBuffer | null;
    /**
     * @param { string } type
     * @return { TimeRanges | void }
     */
    buffered(type: string): TimeRanges | void;
    /**
     * @param { string } type
     * @return { number }
     */
    bufferStart(type: string): number;
    /**
     * @param { string } type
     * @return { number }
     */
    bufferEnd(type: string): number;
    _enqueueOp(type: any, exec: any, opName: any, context: any, isInsertHead: any): Promise<any>;
    _enqueueBlockingOp(exec: any, opName: any): Promise<any>;
    _startQueue(type: any): void;
    _onSBUpdateEnd: (type: any) => void;
    _onSBUpdateError: (type: any, event: any) => void;
    setTimeoffset(type: any, timestampOffset: any, context: any): Promise<any>;
    /** *重置decode时间戳 */
    abort(type: any, context: any): Promise<any>;
}
declare const MediaSource: {
    new (): MediaSource;
    prototype: MediaSource;
    isTypeSupported(type: string): boolean;
};
export {};
