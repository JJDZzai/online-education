import { defineProperty as _defineProperty, inherits as _inherits, createSuper as _createSuper, createClass as _createClass, classCallCheck as _classCallCheck, wrapNativeSuper as _wrapNativeSuper, asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime } from "./_virtual/_rollupPluginBabelHelpers.js";
import { createPublicPromise, nowTime } from "./utils.js";
import { Buffer } from "./buffer.js";
import { StreamingError, ERR } from "./error.js";
import { isBrowser } from "./env.js";
import { Logger } from "./logger.js";
function getMediaSource() {
  try {
    return isBrowser ? window.MediaSource : null;
  } catch (e) {
  }
}
var MediaSource = getMediaSource();
var MSEErrorType = {
  UPDATE_ERROR: "updateError"
};
var OP_NAME = {
  APPEND: "appendBuffer",
  REMOVE: "removeBuffer"
};
var MSEError = /* @__PURE__ */ function(_Error) {
  _inherits(MSEError2, _Error);
  var _super = _createSuper(MSEError2);
  function MSEError2(type, msg) {
    var _this;
    _classCallCheck(this, MSEError2);
    _this = _super.call(this, msg || type);
    _this.type = type;
    _this.msg = msg;
    return _this;
  }
  return _createClass(MSEError2);
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var MSE = /* @__PURE__ */ function() {
  function MSE2(media, config) {
    var _this2 = this;
    _classCallCheck(this, MSE2);
    _defineProperty(this, "media", null);
    _defineProperty(this, "mediaSource", null);
    _defineProperty(this, "_openPromise", createPublicPromise());
    _defineProperty(this, "_queue", /* @__PURE__ */ Object.create(null));
    _defineProperty(this, "_sourceBuffer", /* @__PURE__ */ Object.create(null));
    _defineProperty(this, "_mseFullFlag", {});
    _defineProperty(this, "_st", 0);
    _defineProperty(this, "_opst", 0);
    _defineProperty(this, "_logger", null);
    _defineProperty(this, "_config", null);
    _defineProperty(this, "_url", null);
    _defineProperty(this, "_onSBUpdateEnd", function(type) {
      var queue = _this2._queue[type];
      if (queue) {
        var op = queue.shift();
        if (op) {
          var costtime = nowTime() - _this2._opst;
          _this2._logger.debug("UpdateEnd", op.opName, costtime, op.context);
          op.promise.resolve({
            name: op.opName,
            context: op.context,
            costtime
          });
          _this2._startQueue(type);
        }
      }
    });
    _defineProperty(this, "_onSBUpdateError", function(type, event) {
      var queue = _this2._queue[type];
      if (queue) {
        var op = queue[0];
        if (op) {
          _this2._logger.error("UpdateError", type, op.opName, op.context);
          op.promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_APPEND_BUFFER, event));
        }
      }
    });
    this._config = Object.assign(MSE2.getDefaultConfig(), config);
    if (media)
      this.bindMedia(media);
    this._logger = new Logger("MSE");
    if (this._config.openLog) {
      Logger.enable();
    }
  }
  _createClass(MSE2, [{
    key: "isOpened",
    get: function get() {
      var _this$mediaSource;
      return ((_this$mediaSource = this.mediaSource) === null || _this$mediaSource === void 0 ? void 0 : _this$mediaSource.readyState) === "open";
    }
  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
  }, {
    key: "duration",
    get: function get() {
      var _this$mediaSource2;
      return ((_this$mediaSource2 = this.mediaSource) === null || _this$mediaSource2 === void 0 ? void 0 : _this$mediaSource2.duration) || -1;
    }
  }, {
    key: "isEnded",
    get: function get() {
      return this.mediaSource ? this.mediaSource.readyState === "ended" : false;
    }
  }, {
    key: "isFull",
    value: function isFull(type) {
      return type ? this._mseFullFlag[type] : this._mseFullFlag[MSE2.VIDEO];
    }
  }, {
    key: "updateDuration",
    value: function updateDuration(duration) {
      var _this3 = this;
      if (this.mediaSource && this.mediaSource.duration > duration) {
        return Promise.resolve();
      }
      return this._enqueueBlockingOp(function() {
        if (_this3.isEnded) {
          _this3._logger.debug("[debug mse] setDuration ended");
          return;
        }
        if (_this3.mediaSource) {
          _this3.mediaSource.duration = duration;
          _this3._logger.debug("[debug mse] setDuration");
        }
      }, "updateDuration");
    }
  }, {
    key: "open",
    value: function open() {
      var _this4 = this;
      if (this._openPromise.used && !this.isOpened && this.mediaSource) {
        var ms = this.mediaSource;
        var onOpen = function onOpen2() {
          var costtime = nowTime() - _this4._st;
          _this4._logger.debug("MSE OPEN", costtime);
          ms.removeEventListener("sourceopen", onOpen2);
          _this4._openPromise.resolve({
            costtime
          });
        };
        ms.addEventListener("sourceopen", onOpen);
        this._openPromise = createPublicPromise();
      }
      return this._openPromise;
    }
  }, {
    key: "bindMedia",
    value: function() {
      var _bindMedia = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(media) {
        var _this5 = this;
        var ms, onOpen;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.mediaSource || this.media)) {
                  _context.next = 3;
                  break;
                }
                _context.next = 3;
                return this.unbindMedia();
              case 3:
                if (!(!media || !MediaSource)) {
                  _context.next = 5;
                  break;
                }
                throw new Error("Param media or MediaSource does not exist");
              case 5:
                this.media = media;
                ms = this.mediaSource = new MediaSource();
                this._st = nowTime();
                onOpen = function onOpen2() {
                  var costtime = nowTime() - _this5._st;
                  _this5._logger.debug("MSE OPEN");
                  ms.removeEventListener("sourceopen", onOpen2);
                  URL.revokeObjectURL(media.src);
                  _this5._openPromise.resolve({
                    costtime
                  });
                };
                ms.addEventListener("sourceopen", onOpen);
                this._url = URL.createObjectURL(ms);
                media.src = this._url;
                return _context.abrupt("return", this._openPromise);
              case 13:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function bindMedia(_x) {
        return _bindMedia.apply(this, arguments);
      }
      return bindMedia;
    }()
  }, {
    key: "unbindMedia",
    value: function() {
      var _unbindMedia = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2() {
        var _this6 = this;
        var ms, hasMetadata, mseOpen;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._openPromise.used)
                  this._openPromise.resolve();
                ms = this.mediaSource;
                if (ms) {
                  Object.keys(this._queue).forEach(function(t) {
                    var queue = _this6._queue[t];
                    if (queue) {
                      queue.forEach(function(x) {
                        return x.promise.resolve;
                      });
                    }
                  });
                  hasMetadata = !!this.media && this.media.readyState >= 1;
                  mseOpen = ms.readyState === "open";
                  if (hasMetadata && mseOpen) {
                    try {
                      ms.endOfStream();
                    } catch (error) {
                    }
                  }
                  Object.keys(this._sourceBuffer).forEach(function(k) {
                    try {
                      ms.removeSourceBuffer(_this6._sourceBuffer[k]);
                    } catch (error) {
                    }
                  });
                }
                if (this.media) {
                  this.media.removeAttribute("src");
                  try {
                    this.media.load();
                  } catch (error) {
                  }
                  this.media = null;
                }
                this.mediaSource = null;
                this._openPromise = createPublicPromise();
                this._queue = /* @__PURE__ */ Object.create(null);
                this._sourceBuffer = /* @__PURE__ */ Object.create(null);
              case 8:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function unbindMedia() {
        return _unbindMedia.apply(this, arguments);
      }
      return unbindMedia;
    }()
  }, {
    key: "createSource",
    value: function createSource(type, mimeType) {
      if (this._sourceBuffer[type] || !this.mediaSource)
        return;
      var sb;
      try {
        sb = this._sourceBuffer[type] = this.mediaSource.addSourceBuffer(mimeType);
      } catch (error) {
        throw new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_ADD_SB, error);
      }
      sb.mimeType = mimeType;
      sb.addEventListener("updateend", this._onSBUpdateEnd.bind(this, type));
      sb.addEventListener("error", this._onSBUpdateError.bind(this, type));
    }
  }, {
    key: "changeType",
    value: function changeType(type, mimeType) {
      var _this7 = this;
      var sb = this._sourceBuffer[type];
      if (!this.mediaSource || !sb || sb.mimeType === mimeType)
        return Promise.resolve();
      if (typeof sb.changeType !== "function")
        return Promise.reject();
      return this._enqueueOp(type, function() {
        sb.changeType(mimeType);
        sb.mimeType = mimeType;
        _this7._onSBUpdateEnd(type);
      });
    }
  }, {
    key: "createOrChangeSource",
    value: function createOrChangeSource(type, mimeType) {
      this.createSource(type, mimeType);
      return this.changeType(type, mimeType);
    }
  }, {
    key: "append",
    value: function append(type, buffer, context) {
      var _this8 = this;
      if (!buffer || !buffer.byteLength) {
        return Promise.resolve();
      }
      if (!this._sourceBuffer[type])
        return Promise.resolve();
      return this._enqueueOp(type, function() {
        var _this8$_sourceBuffer$;
        if (!_this8.mediaSource)
          return;
        _this8._logger.debug("MSE APPEND START", context);
        _this8._opst = nowTime();
        (_this8$_sourceBuffer$ = _this8._sourceBuffer[type]) === null || _this8$_sourceBuffer$ === void 0 ? void 0 : _this8$_sourceBuffer$.appendBuffer(buffer);
      }, OP_NAME.APPEND, context);
    }
  }, {
    key: "remove",
    value: function remove(type, startTime, endTime, context) {
      var _this9 = this;
      var isInsertHead = false;
      if (this._mseFullFlag[type]) {
        isInsertHead = true;
      }
      return this._enqueueOp(type, function() {
        if (!_this9.mediaSource)
          return;
        var sb = _this9._sourceBuffer[type];
        if (startTime >= endTime || !sb) {
          _this9._onSBUpdateEnd(type);
          return;
        }
        _this9._opst = nowTime();
        _this9._logger.debug("MSE REMOVE START", type, startTime, endTime, context);
        sb.remove(startTime, endTime);
      }, OP_NAME.REMOVE, context, isInsertHead);
    }
  }, {
    key: "clearBuffer",
    value: function clearBuffer(startTime, endTime) {
      var _this10 = this;
      var p;
      Object.keys(this._sourceBuffer).forEach(function(k) {
        p = _this10._enqueueOp(k, function() {
          if (!_this10.mediaSource)
            return;
          var sb = _this10._sourceBuffer[k];
          _this10._logger.debug("MSE clearBuffer START", k, startTime, endTime);
          sb.remove(startTime, endTime);
        });
      });
      return p;
    }
  }, {
    key: "clearAllBuffer",
    value: function clearAllBuffer() {
      var _this11 = this;
      var p;
      Object.keys(this._sourceBuffer).forEach(function(k) {
        p = _this11._enqueueOp(k, function() {
          if (!_this11.mediaSource)
            return;
          var sb = _this11._sourceBuffer[k];
          _this11._logger.debug("MSE clearAllBuffer START", k);
          sb.remove(0, Buffer.end(Buffer.get(sb)));
        });
      });
      return p;
    }
  }, {
    key: "clearOpQueues",
    value: function clearOpQueues(type) {
      var _this$_queue$type;
      this._logger.debug("MSE clearOpQueue START");
      var queue = this._queue[type];
      if (!queue || !queue[type] || queue.length < 5)
        return;
      var initOpque = [];
      queue.forEach(function(op) {
        if (op.context && op.context.isinit) {
          initOpque.push(op);
        }
      });
      this._queue[type] = queue.slice(0, 2);
      initOpque.length > 0 && (_this$_queue$type = this._queue[type]).push.apply(_this$_queue$type, initOpque);
    }
  }, {
    key: "endOfStream",
    value: function endOfStream(reason) {
      var _this12 = this;
      if (!this.mediaSource || this.mediaSource.readyState !== "open")
        return Promise.resolve();
      return this._enqueueBlockingOp(function() {
        var ms = _this12.mediaSource;
        if (!ms || ms.readyState !== "open")
          return;
        _this12._logger.debug("MSE endOfStream START");
        if (reason) {
          ms.endOfStream(reason);
        } else {
          ms.endOfStream();
        }
      }, "endOfStream");
    }
  }, {
    key: "setLiveSeekableRange",
    value: function setLiveSeekableRange(start, end) {
      var ms = this.mediaSource;
      if (start < 0 || end < start || !(ms !== null && ms !== void 0 && ms.setLiveSeekableRange) || ms.readyState !== "open")
        return;
      ms.setLiveSeekableRange(start, end);
    }
  }, {
    key: "getSourceBuffer",
    value: function getSourceBuffer(type) {
      return this._sourceBuffer[type];
    }
  }, {
    key: "buffered",
    value: function buffered(type) {
      return Buffer.get(this._sourceBuffer[type]);
    }
  }, {
    key: "bufferStart",
    value: function bufferStart(type) {
      return Buffer.start(this.buffered(type));
    }
  }, {
    key: "bufferEnd",
    value: function bufferEnd(type) {
      return Buffer.end(this.buffered(type));
    }
  }, {
    key: "_enqueueOp",
    value: function _enqueueOp(type, exec, opName, context, isInsertHead) {
      var _this13 = this;
      if (!this.mediaSource)
        return Promise.resolve();
      var queue = this._queue[type] = this._queue[type] || [];
      var op = {
        exec,
        promise: createPublicPromise(),
        opName,
        context
      };
      if (isInsertHead) {
        queue.splice(0, 0, op);
        this._mseFullFlag[type] = false;
        this._startQueue(type);
      } else {
        queue.push(op);
      }
      if (this.isOpened) {
        if (queue.length === 1) {
          this._startQueue(type);
        }
      } else {
        this._openPromise.then(function() {
          if (queue.length === 1) {
            _this13._startQueue(type);
          }
        });
      }
      return op.promise;
    }
  }, {
    key: "_enqueueBlockingOp",
    value: function() {
      var _enqueueBlockingOp2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(exec, opName) {
        var _this14 = this;
        var types, waiters;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.mediaSource) {
                  _context3.next = 2;
                  break;
                }
                return _context3.abrupt("return", Promise.resolve());
              case 2:
                types = Object.keys(this._sourceBuffer);
                if (types.length) {
                  _context3.next = 5;
                  break;
                }
                return _context3.abrupt("return", exec());
              case 5:
                waiters = [];
                types.forEach(function(t) {
                  var queue = _this14._queue[t];
                  var prom = createPublicPromise();
                  waiters.push(prom);
                  queue.push({
                    exec: function exec2() {
                      return prom.resolve();
                    },
                    promise: prom,
                    opName
                  });
                  if (queue.length === 1) {
                    _this14._startQueue(t);
                  }
                });
                return _context3.abrupt("return", Promise.all(waiters).then(function() {
                  try {
                    return exec();
                  } finally {
                    types.forEach(function(t) {
                      var queue = _this14._queue[t];
                      var sb = _this14._sourceBuffer[t];
                      queue === null || queue === void 0 ? void 0 : queue.shift();
                      if (!sb || !sb.updating) {
                        _this14._startQueue(t);
                      }
                    });
                  }
                }));
              case 8:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function _enqueueBlockingOp(_x2, _x3) {
        return _enqueueBlockingOp2.apply(this, arguments);
      }
      return _enqueueBlockingOp;
    }()
  }, {
    key: "_startQueue",
    value: function _startQueue(type) {
      var queue = this._queue[type];
      if (queue) {
        var op = queue[0];
        if (op && !this._mseFullFlag[type]) {
          try {
            op.exec();
          } catch (error) {
            if (error && error.message && error.message.indexOf("SourceBuffer is full") >= 0) {
              this._mseFullFlag[type] = true;
              this._logger.error("[MSE error],  context,", op.context, " ,name,", op.opName, ",err,SourceBuffer is full");
              op.promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_FULL, error));
            } else {
              this._logger.error(error);
              op.promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_OTHER, error));
              queue.shift();
              this._startQueue(type);
            }
          }
        }
      }
    }
  }, {
    key: "setTimeoffset",
    value: function setTimeoffset(type, timestampOffset, context) {
      var _this15 = this;
      return this._enqueueOp(type, function() {
        if (timestampOffset < 0) {
          timestampOffset += 1e-3;
        }
        _this15._sourceBuffer[type].timestampOffset = timestampOffset;
        _this15._onSBUpdateEnd(type);
      }, "setTimeoffset", context);
    }
  }, {
    key: "abort",
    value: function abort(type, context) {
      var _this16 = this;
      if (!this.isOpened) {
        return Promise.resolve();
      }
      return this._enqueueOp(type, function() {
        _this16._sourceBuffer[type].abort();
        _this16._onSBUpdateEnd(type);
      }, "abort", context);
    }
  }], [{
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      return {
        openLog: false
      };
    }
  }, {
    key: "isSupported",
    value: function isSupported() {
      var mime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'video/mp4; codecs="avc1.42E01E,mp4a.40.2"';
      if (!MediaSource)
        return false;
      try {
        return MediaSource.isTypeSupported(mime);
      } catch (error) {
        this._logger.error(mime, error);
        return false;
      }
    }
  }]);
  return MSE2;
}();
_defineProperty(MSE, "VIDEO", "video");
_defineProperty(MSE, "AUDIO", "audio");
export { MSE, MSEError, MSEErrorType };
