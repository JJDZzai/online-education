import { inherits as _inherits, createSuper as _createSuper, createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty, assertThisInitialized as _assertThisInitialized, asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime } from "../_virtual/_rollupPluginBabelHelpers.js";
import { FetchLoader } from "./fetch.js";
import { LoaderType } from "./types.js";
export { LoaderType, ResponseType } from "./types.js";
import { getConfig } from "./config.js";
import { Task } from "./task.js";
import { isPlainObject } from "../is.js";
import { sleep } from "../streaming-helper.js";
import { EVENT } from "../event.js";
import EventEmitter from "eventemitter3";
var NetLoader = /* @__PURE__ */ function(_EventEmitter) {
  _inherits(NetLoader2, _EventEmitter);
  var _super = _createSuper(NetLoader2);
  function NetLoader2(cfg) {
    var _this;
    _classCallCheck(this, NetLoader2);
    _this = _super.call(this, cfg);
    _defineProperty(_assertThisInitialized(_this), "type", LoaderType.FETCH);
    _defineProperty(_assertThisInitialized(_this), "_queue", []);
    _defineProperty(_assertThisInitialized(_this), "_alive", []);
    _defineProperty(_assertThisInitialized(_this), "_currentTask", null);
    _defineProperty(_assertThisInitialized(_this), "_config", void 0);
    _this._config = getConfig(cfg);
    if (_this._config.loaderType === LoaderType.XHR || !FetchLoader.isSupported()) {
      _this.type = LoaderType.XHR;
    }
    _this.log = cfg.logger;
    return _this;
  }
  _createClass(NetLoader2, [{
    key: "isFetch",
    value: function isFetch() {
      return this.type === LoaderType.FETCH;
    }
  }, {
    key: "load",
    value: function load(url) {
      var _this2 = this;
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (typeof url === "string" || !url) {
        config.url = url || config.url || this._config.url;
      } else {
        config = url;
      }
      config = Object.assign({}, this._config, config);
      if (config.params)
        config.params = Object.assign({}, config.params);
      if (config.headers && isPlainObject(config.headers))
        config.headers = Object.assign({}, config.headers);
      if (config.body && isPlainObject(config.body))
        config.body = Object.assign({}, config.body);
      if (config.transformRequest) {
        config = config.transformRequest(config) || config;
      }
      config.logger = this.log;
      var task = new Task(this.type, config);
      task.loader.on(EVENT.REAL_TIME_SPEED, function(data) {
        _this2.emit(EVENT.REAL_TIME_SPEED, data);
      });
      this._queue.push(task);
      if (this._queue.length === 1 && (!this._currentTask || !this._currentTask.running)) {
        this._processTask();
      }
      return task.promise;
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var cancels;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                cancels = this._queue.map(function(t) {
                  return t.cancel();
                }).concat(this._alive.map(function(t) {
                  return t.cancel();
                }));
                if (this._currentTask) {
                  cancels.push(this._currentTask.cancel());
                }
                this._queue = [];
                this._alive = [];
                _context.next = 6;
                return Promise.all(cancels);
              case 6:
                _context.next = 8;
                return sleep();
              case 8:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }, {
    key: "_processTask",
    value: function _processTask() {
      var _this3 = this;
      this._currentTask = this._queue.shift();
      if (!this._currentTask)
        return;
      if (this._currentTask.alive) {
        this._alive.push(this._currentTask);
      }
      var req = this._currentTask.exec().catch(function(e) {
      });
      if (!(req && typeof req.finally === "function"))
        return;
      req.finally(function() {
        var _this3$_currentTask, _this3$_alive;
        if ((_this3$_currentTask = _this3._currentTask) !== null && _this3$_currentTask !== void 0 && _this3$_currentTask.alive && ((_this3$_alive = _this3._alive) === null || _this3$_alive === void 0 ? void 0 : _this3$_alive.length) > 0) {
          _this3._alive = _this3._alive.filter(function(task) {
            return task && task !== _this3._currentTask;
          });
        }
        _this3._processTask();
      });
    }
  }], [{
    key: "isFetchSupport",
    value: function isFetchSupport() {
      return FetchLoader.isSupported();
    }
  }]);
  return NetLoader2;
}(EventEmitter);
export { NetLoader };
