import { createClass as _createClass, objectWithoutProperties as _objectWithoutProperties, classCallCheck as _classCallCheck, asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime } from "../_virtual/_rollupPluginBabelHelpers.js";
import { FetchLoader } from "./fetch.js";
import { XhrLoader } from "./xhr.js";
import { LoaderType } from "./types.js";
import { createPublicPromise } from "../utils.js";
import { Logger } from "../logger.js";
var _excluded = ["retry", "retryDelay", "onRetryError", "transformError"];
var Task = /* @__PURE__ */ function() {
  function Task2(type, config) {
    _classCallCheck(this, Task2);
    this.promise = createPublicPromise();
    this.alive = !!config.onProgress;
    !config.logger && (config.logger = new Logger("Loader"));
    this._loaderType = type;
    this._loader = type === LoaderType.FETCH && !!window.fetch ? new FetchLoader() : new XhrLoader();
    this._config = config;
    this._retryCount = 0;
    this._retryTimer = null;
    this._canceled = false;
    this._retryCheckFunc = config.retryCheckFunc;
    this._logger = config.logger;
  }
  _createClass(Task2, [{
    key: "exec",
    value: function exec() {
      var _this = this;
      var _this$_config = this._config, retry = _this$_config.retry, retryDelay = _this$_config.retryDelay, onRetryError = _this$_config.onRetryError, transformError = _this$_config.transformError, rest = _objectWithoutProperties(_this$_config, _excluded);
      var request = /* @__PURE__ */ function() {
        var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
          var response, error, isRetry;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1)
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return _this._loader.load(rest);
                case 3:
                  response = _context.sent;
                  _this.promise.resolve(response);
                  _context.next = 27;
                  break;
                case 7:
                  _context.prev = 7;
                  _context.t0 = _context["catch"](0);
                  _this._loader.running = false;
                  _this._logger.debug("[task request catch err]", _context.t0);
                  if (!_this._canceled) {
                    _context.next = 13;
                    break;
                  }
                  return _context.abrupt("return");
                case 13:
                  _context.t0.loaderType = _this._loaderType;
                  _context.t0.retryCount = _this._retryCount;
                  error = _context.t0;
                  if (transformError) {
                    error = transformError(error) || error;
                  }
                  if (onRetryError && _this._retryCount > 0)
                    onRetryError(error, _this._retryCount, {
                      index: rest.index,
                      vid: rest.vid,
                      range: rest.range,
                      priOptions: rest.priOptions
                    });
                  _this._retryCount++;
                  isRetry = true;
                  if (_this._retryCheckFunc) {
                    isRetry = _this._retryCheckFunc(_context.t0);
                  }
                  if (!(isRetry && _this._retryCount <= retry)) {
                    _context.next = 26;
                    break;
                  }
                  clearTimeout(_this._retryTimer);
                  _this._logger.debug("[task request setTimeout],retry", _this._retryCount, ",retry range,", rest.range);
                  _this._retryTimer = setTimeout(request, retryDelay);
                  return _context.abrupt("return");
                case 26:
                  _this.promise.reject(error);
                case 27:
                case "end":
                  return _context.stop();
              }
          }, _callee, null, [[0, 7]]);
        }));
        return function request2() {
          return _ref.apply(this, arguments);
        };
      }();
      request();
      return this.promise;
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                clearTimeout(this._retryTimer);
                this._canceled = true;
                this._loader.running = false;
                return _context2.abrupt("return", this._loader.cancel());
              case 4:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }, {
    key: "running",
    get: function get() {
      return this._loader && this._loader.running;
    }
  }, {
    key: "loader",
    get: function get() {
      return this._loader;
    }
  }]);
  return Task2;
}();
export { Task };
