{"version":3,"file":"index.min.js","sources":["../src/model/types.js","../src/model/video-track.js","../src/model/audio-track.js","../src/model/video-sample.js","../src/model/audio-sample.js","../src/model/metadata-track.js","../src/utils/exp-golomb.js","../src/utils/logger.js","../src/utils/utf8.js","../src/utils/env.js","../src/utils/index.js","../src/codec/nalu.js","../src/codec/avc.js","../src/codec/aac.js","../src/codec/hevc.js","../src/flv/fixer.js","../src/flv/amf.js","../src/flv/index.js","../src/mpeg-ts/fixer.js","../src/mpeg-ts/index.js","../src/mp4/mp4-parser.js","../src/mp4/fmp4-demuxer.js","../src/mp4/buffer.js","../src/mp4/mp4.js","../src/mp4/logger.js","../../../node_modules/crypto-es/lib/md5.js","../src/mp4/fmp4-remuxer.js","../../../node_modules/crypto-es/lib/core.js","../../../node_modules/crypto-es/lib/enc-base64.js","../../../node_modules/crypto-es/lib/evpkdf.js","../../../node_modules/crypto-es/lib/cipher-core.js","../../../node_modules/crypto-es/lib/aes.js","../../../node_modules/crypto-es/lib/mode-ctr.js","../../../node_modules/crypto-es/lib/pad-nopadding.js","../src/mp4/crypto/crypto.js","../src/mp4/mp4-demuxer.js","../src/mp4/mp4-remuxer.js","../src/index.umd.js"],"sourcesContent":["/** @enum {string} */\nexport const TrackType = {\n  VIDEO: 'video',\n  AUDIO: 'audio',\n  METADATA: 'metadata'\n}\n\n/** @enum {string} */\nexport const VideoCodecType = {\n  AVC: 'avc',\n  HEVC: 'hevc'\n}\n\n/** @enum {string} */\nexport const AudioCodecType = {\n  AAC: 'aac',\n  G711PCMA: 'g7110a',\n  G711PCMU: 'g7110m'\n}\n\n/** @enum {string} */\nexport const WarningType = {\n  LARGE_AV_SHIFT: 'LARGE_AV_SHIFT',\n  LARGE_VIDEO_GAP: 'LARGE_VIDEO_GAP',\n  LARGE_VIDEO_GAP_BETWEEN_CHUNK: 'LARGE_VIDEO_GAP_BETWEEN_CHUNK',\n  LARGE_AUDIO_GAP: 'LARGE_AUDIO_GAP',\n  AUDIO_FILLED: 'AUDIO_FILLED',\n  AUDIO_DROPPED: 'AUDIO_DROPPED'\n}\n","import { TrackType, VideoCodecType } from './types'\n\nexport class VideoTrack {\n  id = 1\n\n  /** @readonly */\n  type = TrackType.VIDEO\n\n  codecType = VideoCodecType.AVC\n\n  pid = -1 // ts use\n\n  /** @type {Uint8Array | Object} */\n  hvcC = undefined\n\n  codec = ''\n\n  timescale = 0\n\n  formatTimescale = 0\n\n  sequenceNumber = 0\n\n  baseMediaDecodeTime = 0\n\n  baseDts = 0\n\n  duration = 0\n\n  warnings = []\n\n  /** @type {import('./video-sample').VideoSample[]} */\n  samples = []\n\n  /** @type {Uint8Array[]} */\n  pps = []\n\n  /** @type {Uint8Array[]} */\n  sps = []\n\n  /** @type {Uint8Array[]} */\n  vps = []\n\n  fpsNum = 0\n\n  fpsDen = 0\n\n  /** @type {[number, number]} */\n  sarRatio = [] // [hSpacing, vSpacing]\n\n  width = 0\n\n  height = 0\n\n  nalUnitSize = 4\n\n  present = false\n\n  isVideoEncryption = false\n\n  isAudioEncryption = false\n\n  isVideo = true\n\n  kid = null\n\n  pssh = null\n\n  /** @type {any} */\n  ext\n\n  reset () {\n    this.sequenceNumber =\n    this.width =\n    this.height =\n    this.fpsDen =\n    this.fpsNum =\n    this.duration =\n    this.baseMediaDecodeTime =\n    this.timescale = 0\n    this.codec = ''\n    this.present = false\n    this.pid = -1\n    this.pps = []\n    this.sps = []\n    this.vps = []\n    this.sarRatio = []\n    this.samples = []\n    this.warnings = []\n    this.hvcC = null\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!(this.pps.length && this.sps.length && this.codec)\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!this.samples.length\n  }\n\n  get isEncryption (){\n    return this.isVideoEncryption\n  }\n}\n","import { TrackType, AudioCodecType } from './types'\n\nexport class AudioTrack {\n  id = 2\n\n  /** @readonly */\n  type = TrackType.AUDIO\n\n  codecType = AudioCodecType.AAC\n\n  pid = -1\n\n  codec = ''\n\n  sequenceNumber = 0\n\n  sampleDuration = 0\n\n  timescale = 0\n\n  formatTimescale = 0\n\n  baseMediaDecodeTime = 0\n\n  duration = 0\n\n  warnings = []\n\n  /** @type {import('./audio-sample').AudioSample[]} */\n  samples = []\n\n  baseDts = 0\n\n  sampleSize = 16\n\n  sampleRate = 0\n\n  channelCount = 0\n\n  objectType = 0\n\n  sampleRateIndex = 0\n\n  /** @type {number[]} */\n  config = []\n\n  present = false\n\n  isVideoEncryption = false\n\n  isAudioEncryption = false\n\n  kid = null\n\n  /** @type {any} */\n  ext\n\n  reset () {\n    this.sequenceNumber = 0\n    this.timescale = 0\n    this.sampleDuration = 0\n    this.sampleRate = 0\n    this.channelCount = 0\n    this.baseMediaDecodeTime = 0\n    this.present = false\n    this.pid = -1\n    this.codec = ''\n    this.samples = []\n    this.config = []\n    this.warnings = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!(this.sampleRate && this.channelCount && this.codec && this.codecType === AudioCodecType.AAC)\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!this.samples.length\n  }\n\n  get isEncryption (){\n    return this.isAudioEncryption\n  }\n}\n","/**\n * @typedef {Object} VideoFlag\n * @property {number} [isLeading=0]\n * @property {number} [dependsOn=1]\n * @property {number} [isDependedOn=0]\n * @property {number} [hasRedundancy=0]\n * @property {number} [paddingValue=0]\n * @property {number} [degradationPriority=0]\n * @property {number} [isNonSyncSample=1]\n */\n\nexport class VideoSample {\n  /** @type {VideoFlag} */\n  flag = {}\n\n  keyframe = false\n\n  gopId = 0\n\n  duration = 0\n\n  size = 0\n\n  units = []\n\n  chromaFormat = 420\n\n  // sampleOffset = 0\n\n  /**\n   * @param {number} pts\n   * @param {number} dts\n   * @param {Uint8Array[]} [units]\n   */\n  constructor (pts, dts, units) {\n    this.originPts = this.pts = pts\n    this.originDts = this.dts = dts\n    if (units) this.units = units\n  }\n\n  /**\n   * @returns {number}\n   */\n  get cts () {\n    return this.pts - this.dts\n  }\n\n  setToKeyframe () {\n    this.keyframe = true\n    this.flag.dependsOn = 2\n    this.flag.isNonSyncSample = 0\n  }\n}\n","export class AudioSample {\n  duration = 1024\n\n  flag = { dependsOn: 2, isNonSyncSample: 0 }\n  keyframe = true\n\n  /**\n   * @param {number} pts\n   * @param {Uint8Array} data\n   * @param {number} [duration=1024]\n   */\n  constructor (pts, data, duration, sampleOffset) {\n    this.originPts = this.pts = this.dts = pts\n    this.data = data\n    this.size = data.byteLength\n    this.sampleOffset = sampleOffset\n    if (duration) this.duration = duration\n  }\n}\n","import { TrackType } from './types'\n\nclass Sample {\n  time = 0 // second\n\n  /**\n   * @param {Object} data\n   * @param {number} pts\n   */\n  constructor (data, pts) {\n    this.data = data\n    this.originPts = this.pts = pts\n  }\n}\n\nexport class FlvScriptSample extends Sample {}\n\nexport class SeiSample extends Sample {}\n\nexport class MetadataTrack {\n  /** @readonly */\n  id = 3\n\n  /** @readonly */\n  type = TrackType.METADATA\n\n  timescale = 0\n\n  /** @type {FlvScriptSample[]} */\n  flvScriptSamples = []\n\n  /** @type {SeiSample[]} */\n  seiSamples = []\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!((this.flvScriptSamples.length || this.seiSamples.length) && this.timescale)\n  }\n\n  reset () {\n    this.timescale = 0\n    this.flvScriptSamples = []\n    this.seiSamples = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!(this.flvScriptSamples.length || this.seiSamples.length)\n  }\n}\n","export class ExpGolomb {\n  _bytesAvailable\n\n  _bitsAvailable = 0\n\n  _word = 0\n\n  constructor (data) {\n    if (!data) throw new Error('ExpGolomb data params is required')\n    this._data = data\n    this._bytesAvailable = data.byteLength\n    if (this._bytesAvailable) this._loadWord()\n  }\n\n  _loadWord () {\n    const position = this._data.byteLength - this._bytesAvailable\n    const availableBytes = Math.min(4, this._bytesAvailable)\n    if (availableBytes === 0) throw new Error('No bytes available')\n\n    const workingBytes = new Uint8Array(4)\n    workingBytes.set(this._data.subarray(position, position + availableBytes))\n\n    this._word = new DataView(workingBytes.buffer).getUint32(0)\n    this._bitsAvailable = availableBytes * 8\n    this._bytesAvailable -= availableBytes\n  }\n\n  skipBits (count) {\n    if (this._bitsAvailable > count) {\n      this._word <<= count\n      this._bitsAvailable -= count\n    } else {\n      count -= this._bitsAvailable\n      const skipBytes = Math.floor(count / 8)\n      count -= (skipBytes * 8)\n      this._bytesAvailable -= skipBytes\n      this._loadWord()\n      this._word <<= count\n      this._bitsAvailable -= count\n    }\n  }\n\n  readBits (size) {\n    if (size > 32) {\n      throw new Error('Cannot read more than 32 bits')\n    }\n\n    let bits = Math.min(this._bitsAvailable, size)\n    const val = this._word >>> (32 - bits)\n\n    this._bitsAvailable -= bits\n    if (this._bitsAvailable > 0) {\n      this._word <<= bits\n    } else if (this._bytesAvailable > 0) {\n      this._loadWord()\n    }\n\n    bits = size - bits\n    if (bits > 0 && this._bitsAvailable) {\n      return (val << bits) | this.readBits(bits)\n    }\n    return val\n  }\n\n  skipLZ () {\n    let leadingZeroCount\n    for (\n      leadingZeroCount = 0;\n      leadingZeroCount < this._bitsAvailable;\n      ++leadingZeroCount\n    ) {\n      if ((this._word & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        this._word <<= leadingZeroCount\n        this._bitsAvailable -= leadingZeroCount\n        return leadingZeroCount\n      }\n    }\n    this._loadWord()\n    return leadingZeroCount + this.skipLZ()\n  }\n\n  skipUEG () {\n    this.skipBits(1 + this.skipLZ())\n  }\n\n  readUEG () {\n    const clz = this.skipLZ()\n    return this.readBits(clz + 1) - 1\n  }\n\n  readEG () {\n    const val = this.readUEG()\n    if (1 & val) {\n      return (1 + val) >>> 1\n    }\n    return -1 * (val >>> 1)\n  }\n\n  readBool () {\n    return this.readBits(1) === 1\n  }\n\n  readUByte () {\n    return this.readBits(8)\n  }\n\n  skipScalingList (count) {\n    let lastScale = 8\n    let nextScale = 8\n    let deltaScale\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG()\n        nextScale = (lastScale + deltaScale + 256) % 256\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale\n    }\n  }\n}\n","export class Logger {\n  constructor (name) {\n    this.name = name || ''\n    this._prefix = `[${this.name}]`\n  }\n\n  warn (...args) {\n    if (Logger.disabled) return\n    console.warn(this._prefix, ...args)\n  }\n\n  static disabled = true\n\n  static enable () {\n    Logger.disabled = false\n  }\n\n  static disable () {\n    Logger.disabled = true\n  }\n}\n","export class UTF8 {\n  /**\n   *\n   * @param {Uint8Array} uint8array\n   * @return {string}\n   */\n  static decode (uint8array) {\n    const out = []\n    const input = uint8array\n    let i = 0\n    const length = uint8array.length\n\n    while (i < length) {\n      if (input[i] < 0x80) {\n        out.push(String.fromCharCode(input[i]))\n        ++i\n        continue\n      } else if (input[i] < 0xC0) {\n        // fallthrough\n      } else if (input[i] < 0xE0) {\n        if (UTF8._checkContinuation(input, i, 1)) {\n          const ucs4 = (input[i] & 0x1F) << 6 | (input[i + 1] & 0x3F)\n          if (ucs4 >= 0x80) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF))\n            i += 2\n            continue\n          }\n        }\n      } else if (input[i] < 0xF0) {\n        if (UTF8._checkContinuation(input, i, 2)) {\n          const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F\n          if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF))\n            i += 3\n            continue\n          }\n        }\n      } else if (input[i] < 0xF8) {\n        if (UTF8._checkContinuation(input, i, 3)) {\n          let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 |\n                    (input[i + 2] & 0x3F) << 6 | (input[i + 3] & 0x3F)\n          if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n            ucs4 -= 0x10000\n            out.push(String.fromCharCode((ucs4 >>> 10) | 0xD800))\n            out.push(String.fromCharCode((ucs4 & 0x3FF) | 0xDC00))\n            i += 4\n            continue\n          }\n        }\n      }\n      out.push(String.fromCharCode(0xFFFD))\n      ++i\n    }\n\n    return out.join('')\n  }\n\n  static _checkContinuation (uint8array, start, checkLength) {\n    const array = uint8array\n    if (start + checkLength < array.length) {\n      while (checkLength--) {\n        if ((array[++start] & 0xC0) !== 0x80) {\n          return false\n        }\n      }\n      return true\n    } else {\n      return false\n    }\n  }\n}\n","export const isBrowser = typeof window !== 'undefined'\n\nconst ua = isBrowser && navigator.userAgent.toLocaleLowerCase()\n\n// eslint-disable-next-line no-lookahead-lookbehind-regexp/no-lookahead-lookbehind-regexp\nexport const isSafari = isBrowser && /^((?!chrome|android).)*safari/.test(ua)\nexport const isFirefox = isBrowser && ua.includes('firefox')\nexport const isAndroid = isBrowser && ua.includes('android')\n","/* c8 ignore next 4 */\nexport { ExpGolomb } from './exp-golomb'\nexport { Logger } from './logger'\nexport { UTF8 } from './utf8'\nexport * from './env'\n\nexport function concatUint8Array (...arr) {\n  arr = arr.filter(Boolean)\n  const data = new Uint8Array(arr.reduce((p, c) => p + c.byteLength, 0))\n  let prevLen = 0\n  arr.forEach((d) => {\n    data.set(d, prevLen)\n    prevLen += d.byteLength\n  })\n  return data\n}\n\nexport const MAX_SIZE = Math.pow(2, 32)\n\nexport function readBig16 (data, i = 0) {\n  return (data[i] << 8) + (data[i + 1] || 0)\n}\n\nexport function readBig24 (data, i = 0) {\n  return (data[i] << 16) + (data[i + 1] << 8) + (data[i + 2] || 0)\n}\n\nexport function readBig32 (data, i = 0) {\n  return (data[i] << 24 >>> 0) + (data[i + 1] << 16) + (data[i + 2] << 8) + (data[i + 3] || 0)\n}\n\nexport function readBig64 (data, i = 0) {\n  return readBig32(data, i) * MAX_SIZE + readBig32(data, i + 4)\n}\n\nexport function getAvcCodec (codecs) {\n  let codec = 'avc1.'\n  let h\n  for (let i = 0; i < 3; i++) {\n    h = codecs[i].toString(16)\n    if (h.length < 2) h = `0${h}`\n    codec += h\n  }\n  return codec\n}\n\nexport function formatIV (arr) {\n  let iv = ''\n  arr.forEach(value => {\n    iv += bufferToString(value)\n  })\n  if (iv.length <= 32) {\n    const len = 32 - iv.length\n    for (let i = 0; i < len; i++) {\n      iv += '0'\n    }\n  }\n  return iv\n}\n\nexport function parse (a) {\n  if (!Array.isArray(a)) {\n    const arr = []\n    let value = ''\n    for (let i = 0; i < a.length; i++) {\n      if (i % 2) {\n        value = a[i - 1] + a[i]\n        arr.push(parseInt(value, 16))\n        value = ''\n      }\n    }\n    return arr\n  }\n  return a.map(item => { return parseInt(item, 16) })\n}\nfunction bufferToString (value) {\n  return ('0' + (Number(value).toString(16))).slice(-2).toUpperCase()\n}\n\nexport function hashVal (str) {\n  let hash = 0; let i; let chr\n  if (str.length === 0) return hash\n  for (i = 0; i < str.length; i++) {\n    chr = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + chr\n    hash |= 0\n  }\n  return hash\n}\n","import { readBig32 } from '../utils'\n\nexport class NALu {\n  static parseAnnexB (data) {\n    const len = data.length\n    let start = 2\n    let end = 0\n    while (data[start] !== null && data[start] !== undefined && data[start] !== 1) {\n      start++\n    }\n    start++\n    end = start + 2\n\n    if (end >= len) return []\n\n    const units = []\n\n    while (end < len) {\n      switch (data[end]) {\n        case 0:\n          if (data[end - 1] !== 0) {\n            end += 2\n            break\n          } else if (data[end - 2] !== 0) {\n            end++\n            break\n          }\n\n          if (start !== end - 2) units.push(data.subarray(start, end - 2))\n\n          do {\n            end++\n          } while (data[end] !== 1 && end < len)\n          start = end + 1\n          end = start + 2\n          break\n        case 1:\n          if (data[end - 1] !== 0 || data[end - 2] !== 0) {\n            end += 3\n            break\n          }\n          if (start !== end - 2) units.push(data.subarray(start, end - 2))\n          start = end + 1\n          end = start + 2\n          break\n        default:\n          end += 3\n          break\n      }\n    }\n\n    if (start < len) units.push(data.subarray(start))\n\n    return units\n  }\n\n  static parseAvcC (data, size = 4) {\n    if (data.length < 4) return\n    const dataLen = data.length\n    const units = []\n\n    let offset = 0\n    let length\n    while ((offset + size) < dataLen) {\n      length = readBig32(data, offset)\n      if (size === 3) length >>>= 8\n      offset += size\n\n      if (!length) continue\n      if (offset + length > dataLen) {\n        break\n      }\n\n      units.push(data.subarray(offset, offset + length))\n      offset += length\n    }\n\n    return units\n  }\n\n  static parseSEI (unit, isHevc) {\n    const len = unit.length\n    let i = isHevc ? 2 : 1\n    let type = 0\n    let size = 0\n    let uuid = ''\n\n    while (unit[i] === 255) {\n      type += 255\n      i++\n    }\n\n    type += unit[i++]\n\n    while (unit[i] === 255) {\n      size += 255\n      i++\n    }\n    size += unit[i++]\n\n    if (type === 5 && len > i + 16) {\n      for (let j = 0; j < 16; j++) {\n        uuid += unit[i].toString(16)\n        i++\n      }\n    }\n\n    return {\n      payload: unit.subarray(i), type, size, uuid\n    }\n  }\n\n  static removeEPB (uint) {\n    const length = uint.byteLength\n    const emulationPreventionBytesPositions = []\n    let i = 1\n\n    while (i < length - 2) {\n      if (uint[i] === 0 && uint[i + 1] === 0 && uint[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2)\n        i += 2\n      } else {\n        i++\n      }\n    }\n\n    if (!emulationPreventionBytesPositions.length) return uint\n\n    const newLength = length - emulationPreventionBytesPositions.length\n    const newData = new Uint8Array(newLength)\n\n    let sourceIndex = 0\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        sourceIndex++\n        emulationPreventionBytesPositions.shift()\n      }\n      newData[i] = uint[sourceIndex]\n    }\n\n    return newData\n  }\n}\n","import { NALu } from './nalu'\nimport { ExpGolomb, getAvcCodec } from '../utils'\n\nexport class AVC {\n  static parseAVCDecoderConfigurationRecord (data) {\n    if (data.length < 7) return\n    const nalUnitSize = (data[4] & 3) + 1\n\n    let spsParsed\n    const spsArr = []\n    const ppsArr = []\n\n    let offset = 6\n    const spsCount = data[5] & 0x1f\n    let spsSize\n    for (let i = 0; i < spsCount; i++) {\n      spsSize = (data[offset] << 8) | data[offset + 1]\n      offset += 2\n      if (!spsSize) continue\n\n      const sps = data.subarray(offset, offset + spsSize)\n      offset += spsSize\n      spsArr.push(sps)\n\n      if (!spsParsed) {\n        spsParsed = AVC.parseSPS(NALu.removeEPB(sps))\n      }\n    }\n\n    const ppsCount = data[offset]\n    offset++\n    let ppsSize\n    for (let i = 0; i < ppsCount; i++) {\n      ppsSize = (data[offset] << 8) | data[offset + 1]\n      offset += 2\n      if (!ppsSize) continue\n      ppsArr.push(data.subarray(offset, offset + ppsSize))\n      offset += ppsSize\n    }\n\n    return {\n      sps: spsParsed,\n      spsArr,\n      ppsArr,\n      nalUnitSize\n    }\n  }\n\n  static parseSPS (unit) {\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n\n    const profileIdc = eg.readUByte()\n    const profileCompatibility = eg.readUByte()\n    const levelIdc = eg.readUByte()\n    eg.skipUEG()\n\n    let chromaFormat = 420\n    if (\n      profileIdc === 100 ||\n      profileIdc === 110 ||\n      profileIdc === 122 ||\n      profileIdc === 244 ||\n      profileIdc === 44 ||\n      profileIdc === 83 ||\n      profileIdc === 86 ||\n      profileIdc === 118 ||\n      profileIdc === 128 ||\n      profileIdc === 138 ||\n      profileIdc === 144\n    ) {\n      const chromaFormatIdc = eg.readUEG()\n      if (chromaFormatIdc <= 3) chromaFormat = [0, 420, 422, 444][chromaFormatIdc]\n      if (chromaFormatIdc === 3) eg.skipBits(1)\n      eg.skipUEG()\n      eg.skipUEG()\n      eg.skipBits(1)\n      if (eg.readBool()) {\n        const scalingListCount = chromaFormatIdc !== 3 ? 8 : 12\n        for (let i = 0; i < scalingListCount; i++) {\n          if (eg.readBool()) {\n            if (i < 6) {\n              eg.skipScalingList(16)\n            } else {\n              eg.skipScalingList(64)\n            }\n          }\n        }\n      }\n    }\n\n    eg.skipUEG()\n    const picOrderCntType = eg.readUEG()\n    if (picOrderCntType === 0) {\n      eg.readUEG()\n    } else if (picOrderCntType === 1) {\n      eg.skipBits(1)\n      eg.skipUEG()\n      eg.skipUEG()\n      const numRefFramesInPicOrderCntCycle = eg.readUEG()\n      for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        eg.skipUEG()\n      }\n    }\n\n    eg.skipUEG()\n    eg.skipBits(1)\n    const picWidthInMbsMinus1 = eg.readUEG()\n    const picHeightInMapUnitsMinus1 = eg.readUEG()\n    const frameMbsOnlyFlag = eg.readBits(1)\n    if (frameMbsOnlyFlag === 0) eg.skipBits(1)\n    eg.skipBits(1)\n\n    let frameCropLeftOffset = 0\n    let frameCropRightOffset = 0\n    let frameCropTopOffset = 0\n    let frameCropBottomOffset = 0\n\n    if (eg.readBool()) {\n      frameCropLeftOffset = eg.readUEG()\n      frameCropRightOffset = eg.readUEG()\n      frameCropTopOffset = eg.readUEG()\n      frameCropBottomOffset = eg.readUEG()\n    }\n\n    let sarRatio\n    let fixedFrame\n    let fpsNum\n    let fpsDen\n    let fps\n    if (eg.readBool()) {\n      if (eg.readBool()) {\n        const aspectRatioIdc = eg.readUByte()\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break\n          case 2: sarRatio = [12, 11]; break\n          case 3: sarRatio = [10, 11]; break\n          case 4: sarRatio = [16, 11]; break\n          case 5: sarRatio = [40, 33]; break\n          case 6: sarRatio = [24, 11]; break\n          case 7: sarRatio = [20, 11]; break\n          case 8: sarRatio = [32, 11]; break\n          case 9: sarRatio = [80, 33]; break\n          case 10: sarRatio = [18, 11]; break\n          case 11: sarRatio = [15, 11]; break\n          case 12: sarRatio = [64, 33]; break\n          case 13: sarRatio = [160, 99]; break\n          case 14: sarRatio = [4, 3]; break\n          case 15: sarRatio = [3, 2]; break\n          case 16: sarRatio = [2, 1]; break\n          case 255: {\n            sarRatio = [\n              (eg.readUByte() << 8) | eg.readUByte(),\n              (eg.readUByte() << 8) | eg.readUByte()\n            ]\n            break\n          }\n          default:\n        }\n      }\n\n      if (eg.readBool()) eg.readBool()\n\n      if (eg.readBool()) {\n        eg.readBits(4)\n        if (eg.readBool()) eg.readBits(24)\n      }\n\n      if (eg.readBool()) {\n        eg.readUEG()\n        eg.readUEG()\n      }\n\n      if (eg.readBool()) {\n        const numUnitsInTick = eg.readBits(32)\n        const timeScale = eg.readBits(32)\n        fixedFrame = eg.readBool()\n\n        fpsNum = timeScale\n        fpsDen = numUnitsInTick * 2\n        fps = fpsNum / fpsDen\n      }\n    }\n\n    return {\n      codec: getAvcCodec(unit.subarray(1, 4)),\n      profileIdc,\n      profileCompatibility,\n      levelIdc,\n      chromaFormat,\n      width: Math.ceil(\n        (picWidthInMbsMinus1 + 1) * 16 -\n          2 * (frameCropLeftOffset + frameCropRightOffset)\n      ),\n      height:\n        (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 -\n        (frameMbsOnlyFlag ? 2 : 4) *\n          (frameCropTopOffset + frameCropBottomOffset),\n      sarRatio,\n      fpsNum,\n      fpsDen,\n      fps,\n      fixedFrame\n    }\n  }\n}\n","import { isFirefox, isAndroid } from '../utils'\n\nexport class AAC {\n  static FREQ = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n  static getRateIndexByRate (rate) {\n    return AAC.FREQ.indexOf(rate)\n  }\n\n  static parseADTS (data, pts) {\n    const len = data.length\n    let i = 0\n\n    while ((i + 2) < len) {\n      if (data[i] === 0xff && (data[i + 1] & 0xf6) === 0xf0) {\n        break\n      }\n      i++\n    }\n\n    if (i >= len) return\n\n    const skip = i\n    const frames = []\n    const samplingFrequencyIndex = (data[i + 2] & 0x3c) >>> 2\n    const sampleRate = AAC.FREQ[samplingFrequencyIndex]\n    if (!sampleRate) throw new Error(`Invalid sampling index: ${samplingFrequencyIndex}`)\n    const objectType = ((data[i + 2] & 0xc0) >>> 6) + 1\n    const channelCount = ((data[i + 2] & 1) << 2) | ((data[i + 3] & 0xc0) >>> 6)\n    const { config, codec } = AAC._getConfig(samplingFrequencyIndex, channelCount, objectType)\n\n    let protectionSkipBytes\n    let frameLength\n    let frameIndex = 0\n    const duration = AAC.getFrameDuration(sampleRate)\n\n    while ((i + 7) < len) {\n      if ((data[i] !== 0xff) || (data[i + 1] & 0xF6) !== 0xf0) {\n        i++\n        continue\n      }\n\n      frameLength = ((data[i + 3] & 0x03) << 11) | (data[i + 4] << 3) | ((data[i + 5] & 0xe0) >> 5)\n      if ((len - i) < frameLength) break\n\n      protectionSkipBytes = (~data[i + 1] & 0x01) * 2\n      frames.push({\n        pts: pts + frameIndex * duration,\n        data: data.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n      })\n\n      frameIndex++\n      i += frameLength\n    }\n\n    return {\n      skip,\n      remaining: i >= len ? undefined : data.subarray(i),\n      frames,\n      samplingFrequencyIndex,\n      sampleRate,\n      objectType,\n      channelCount,\n      codec,\n      config,\n      originCodec: `mp4a.40.${objectType}`\n    }\n  }\n\n  static parseAudioSpecificConfig (data) {\n    if (!data.length) return\n    const objectType = data[0] >>> 3\n    const samplingFrequencyIndex = ((data[0] & 0x07) << 1) | (data[1] >>> 7)\n    const channelCount = (data[1] & 0x78) >>> 3\n    const sampleRate = AAC.FREQ[samplingFrequencyIndex]\n    // play as no audio track stream\n    if (!sampleRate) return\n    const { config, codec } = AAC._getConfig(samplingFrequencyIndex, channelCount, objectType)\n\n    return {\n      samplingFrequencyIndex,\n      sampleRate,\n      objectType,\n      channelCount,\n      config,\n      codec,\n      originCodec: `mp4a.40.${objectType}`\n    }\n  }\n\n  static getFrameDuration (rate, timescale = 90000) {\n    return 1024 * timescale / rate\n  }\n\n  static _getConfig (samplingIndex, channelCount, originObjectType) {\n    const config = []\n    let objectType\n    let extensionSamplingIndex\n    if (isFirefox) {\n      if (samplingIndex >= 6) { // use SBR (HE-AAC)\n        objectType = 5\n        extensionSamplingIndex = samplingIndex - 3\n      } else { // use LC-AAC\n        objectType = 2\n        extensionSamplingIndex = samplingIndex\n      }\n    } else if (isAndroid) { // use LC-AAC\n      objectType = 2\n      extensionSamplingIndex = samplingIndex\n    } else { // use HE-AAC\n      objectType = (originObjectType === 2 || originObjectType === 5) ? originObjectType : 5\n      extensionSamplingIndex = samplingIndex\n\n      if (samplingIndex >= 6) {\n        extensionSamplingIndex = samplingIndex - 3\n      } else if (channelCount === 1) { // Mono channel, use LC-AAC\n        objectType = 2\n        extensionSamplingIndex = samplingIndex\n      }\n    }\n\n    config[0] = objectType << 3\n    config[0] |= (samplingIndex & 0x0e) >> 1\n    config[1] = (samplingIndex & 0x01) << 7\n    config[1] |= channelCount << 3\n    if (objectType === 5) {\n      config[1] |= ((extensionSamplingIndex & 0x0e) >> 1)\n      config[2] = (extensionSamplingIndex & 0x01) << 7\n      config[2] |= (2 << 2)\n      config[3] = 0\n    }\n\n    return {\n      config,\n      codec: `mp4a.40.${objectType}`\n    }\n  }\n\n  /* c8 ignore next 65 */\n  static getSilentFrame (codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80])\n        } if (channelCount === 2) {\n          return new Uint8Array([\n            0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80\n          ])\n        } if (channelCount === 3) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x8e\n          ])\n        } if (channelCount === 4) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38\n          ])\n        } if (channelCount === 5) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38\n          ])\n        } if (channelCount === 6) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2,\n            0x00, 0x20, 0x08, 0xe0\n          ])\n        }\n        break\n      default:\n        if (channelCount === 1) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        } if (channelCount === 2) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        } if (channelCount === 3) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        }\n        break\n    }\n  }\n}\n","import { NALu } from './nalu'\nimport { ExpGolomb } from '../utils'\n\nexport class HEVC {\n  static parseHEVCDecoderConfigurationRecord (data, hvcC = {}) {\n    if (data.length < 23) return\n    hvcC = hvcC || {}\n    const nalUnitSize = (data[21] & 3) + 1\n\n    let vpsParsed\n    let spsParsed\n    const spsArr = []\n    const ppsArr = []\n    const vpsArr = []\n\n    let offset = 23\n    const numOfArrays = data[22]\n\n    let nalUnitType\n    let numNalus\n    let nalSize\n    for (let i = 0; i < numOfArrays; i++) {\n      nalUnitType = data[offset] & 0x3f\n      numNalus = (data[offset + 1] << 8) | data[offset + 2]\n\n      offset += 3\n\n      for (let j = 0; j < numNalus; j++) {\n        nalSize = (data[offset] << 8) | data[offset + 1]\n        offset += 2\n        if (!nalSize) continue\n        switch (nalUnitType) {\n          case 32: {\n            const vps = data.subarray(offset, offset + nalSize)\n            if (!vpsParsed) vpsParsed = HEVC.parseVPS(NALu.removeEPB(vps), hvcC)\n            vpsArr.push(vps)\n          }\n            break\n          case 33: {\n            const sps = data.subarray(offset, offset + nalSize)\n            if (!spsParsed) spsParsed = HEVC.parseSPS(NALu.removeEPB(sps), hvcC)\n            spsArr.push(sps)\n          }\n            break\n          case 34:\n            ppsArr.push(data.subarray(offset, offset + nalSize))\n            break\n          default:\n        }\n\n        offset += nalSize\n      }\n    }\n\n    return {\n      hvcC,\n      sps: spsParsed,\n      spsArr,\n      ppsArr,\n      vpsArr,\n      nalUnitSize\n    }\n  }\n\n  static parseVPS (unit, hvcC) {\n    hvcC = hvcC || {}\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n    eg.readUByte()\n\n    eg.readBits(12)\n    const vpsMaxSubLayersMinus1 = eg.readBits(3)\n    hvcC.numTemporalLayers = Math.max(hvcC.numTemporalLayers || 0, vpsMaxSubLayersMinus1 + 1)\n    eg.readBits(17)\n    HEVC._parseProfileTierLevel(eg, vpsMaxSubLayersMinus1, hvcC)\n\n    return hvcC\n  }\n\n  static parseSPS (unit, hvcC = {}) {\n    hvcC = hvcC || {}\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n    eg.readUByte()\n\n    eg.readBits(4)\n    const spsMaxSubLayersMinus1 = eg.readBits(3)\n    hvcC.numTemporalLayers = Math.max(spsMaxSubLayersMinus1 + 1, hvcC.numTemporalLayers || 0)\n    hvcC.temporalIdNested = eg.readBits(1)\n    HEVC._parseProfileTierLevel(eg, spsMaxSubLayersMinus1, hvcC)\n\n    eg.readUEG() // sps_seq_parameter_set_id\n\n    const chromaFormatIdc = hvcC.chromaFormatIdc = eg.readUEG()\n    let chromaFormat = 420\n    if (chromaFormatIdc <= 3) chromaFormat = [0, 420, 422, 444][chromaFormatIdc]\n\n    let separateColourPlaneFlag = 0\n    if (chromaFormatIdc === 3) {\n      separateColourPlaneFlag = eg.readBits(1)\n    }\n\n    let width = eg.readUEG() // pic_width_in_luma_samples\n    let height = eg.readUEG() // pic_height_in_luma_samples\n\n    const conformanceWindowFlag = eg.readBits(1)\n\n    let confWinLeftOffset\n    let confWinRightOffset\n    let confWinTopOffset\n    let confWinBottomOffset\n    if (conformanceWindowFlag === 1) {\n      confWinLeftOffset = eg.readUEG() // conf_win_left_offset\n      confWinRightOffset = eg.readUEG() // conf_win_right_offset\n      confWinTopOffset = eg.readUEG() // conf_win_top_offset\n      confWinBottomOffset = eg.readUEG() // conf_win_bottom_offset\n    }\n\n    hvcC.bitDepthLumaMinus8 = eg.readUEG() // bit_depth_luma_minus8\n    hvcC.bitDepthChromaMinus8 = eg.readUEG() // bit_depth_chroma_minus8\n\n    if (conformanceWindowFlag === 1) {\n      const subWidthC = (((chromaFormatIdc === 1) || (chromaFormatIdc === 2)) && (separateColourPlaneFlag === 0)) ? 2 : 1\n      const subHeightC = ((chromaFormatIdc === 1) && (separateColourPlaneFlag === 0)) ? 2 : 1\n      width -= (subWidthC * (confWinRightOffset + confWinLeftOffset))\n      height -= (subHeightC * (confWinBottomOffset + confWinTopOffset))\n    }\n\n    return {\n      codec: 'hev1.1.6.L93.B0',\n      width,\n      height,\n      chromaFormat,\n      hvcC\n    }\n  }\n\n  static _parseProfileTierLevel (eg, maxSubLayersMinus1, hvcC) {\n    const generalTierFlag = hvcC.generalTierFlag || 0\n    hvcC.generalProfileSpace = eg.readBits(2)\n    hvcC.generalTierFlag = Math.max(eg.readBits(1), generalTierFlag)\n    hvcC.generalProfileIdc = Math.max(eg.readBits(5), hvcC.generalProfileIdc || 0)\n    hvcC.generalProfileCompatibilityFlags = eg.readBits(32)\n    hvcC.generalConstraintIndicatorFlags = [eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8)]\n    const generalLevelIdc = eg.readBits(8)\n    if (generalTierFlag < hvcC.generalTierFlag) {\n      hvcC.generalLevelIdc = generalLevelIdc\n    } else {\n      hvcC.generalLevelIdc = Math.max(generalLevelIdc, hvcC.generalLevelIdc || 0)\n    }\n\n    const subLayerProfilePresentFlag = []\n    const subLayerLevelPresentFlag = []\n    for (let j = 0; j < maxSubLayersMinus1; j++) {\n      subLayerProfilePresentFlag[j] = eg.readBits(1)\n      subLayerLevelPresentFlag[j] = eg.readBits(1)\n    }\n\n    if (maxSubLayersMinus1 > 0) {\n      eg.readBits((8 - maxSubLayersMinus1) * 2)\n    }\n\n    for (let i = 0; i < maxSubLayersMinus1; i++) {\n      if (subLayerProfilePresentFlag[i] !== 0) {\n        eg.readBits(2)\n        eg.readBits(1)\n        eg.readBits(5)\n\n        eg.readBits(16)\n        eg.readBits(16)\n\n        eg.readBits(4)\n\n        eg.readBits(16)\n        eg.readBits(16)\n        eg.readBits(12)\n      }\n      if (subLayerLevelPresentFlag[i] !== 0) {\n        eg.readBits(8)\n      }\n    }\n  }\n}\n","import { AudioCodecType, AudioSample, WarningType } from '../model'\nimport { AAC } from '../codec'\nimport { isSafari } from '../utils'\n\nconst LARGE_AV_FIRST_FRAME_GAP = 500 // ms\nconst AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3\nconst MAX_SILENT_FRAME_DURATION = 1000 // ms\nconst AUDIO_EXCETION_LOG_EMIT_DURATION = 5000 // 5s\nconst MAX_VIDEO_FRAME_DURATION = 1000 // ms\nconst MAX_DTS_DELTA_WITH_NEXT_CHUNK = 200 // ms\nconst VIDEO_EXCETION_LOG_EMIT_DURATION = 5000 // 5s\nconst TRACK_BREACKED_CHECK_TIME = 5\n\nexport class FlvFixer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    this.metadataTrack = metadataTrack\n\n    this._baseDts = -1\n    this._baseDtsInited = false\n\n    this._audioNextPts = undefined\n    this._videoNextDts = undefined\n\n    this._audioTimestampBreak = 0\n    this._videoTimestampBreak = 0\n    this._lastVideoDuration = 0\n\n    // 在视频帧遇到下一个关键帧之前，如果音频时间戳发生了跳变，不能确定是否音视频都发生跳变还是单纯音频发生跳变.\n    // 这里记录关键帧标识, 从下一个关键帧开始，如果视频没有跳变，才能判断是只有音频发生了跳变\n    this._keyFrameInNextChunk = false\n\n    this._lastAudioExceptionGapDot = -Infinity\n    this._lastAudioExceptionOverlapDot = -Infinity\n    this._lastAudioExceptionLargeGapDot = -Infinity\n\n    this._lastVideoExceptionLargeGapDot = -Infinity\n    this._lastVideoExceptionChunkFirstDtsDot = -Infinity\n  }\n\n  /**\n   * @param {number} startTime 点播seek到的时间点\n   * @param {boolean} discontinuity 是否换流\n   * @param {boolean} contiguous 前后chunk时间戳是否连续\n   */\n  fix (startTime = 0, discontinuity = false, contiguous = true) {\n    startTime = Math.round(startTime * 1000)\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    if (discontinuity || !contiguous) {\n      this._videoLastSample = null\n      this._audioNextPts = undefined\n      this._videoNextDts = undefined\n      this._audioTimestampBreak = 0\n      this._videoTimestampBreak = 0\n      this._lastAudioExceptionGapDot = -Infinity\n      this._lastAudioExceptionOverlapDot = -Infinity\n      this._lastAudioExceptionLargeGapDot = -Infinity\n      this._lastVideoExceptionLargeGapDot = -Infinity\n      this._lastVideoExceptionChunkFirstDtsDot = -Infinity\n    }\n\n    if (discontinuity && !contiguous) {\n      this._baseDtsInited = false\n    }\n\n    if (!this._baseDtsInited) {\n      this._calculateBaseDts(audioTrack, videoTrack)\n    }\n\n    if (!contiguous && startTime) {\n      this._audioNextPts = this._videoNextDts = startTime\n    }\n\n    const resetBaseDts = this._baseDtsInited &&\n      (this._videoTimestampBreak || !this.videoTrack.exist()) &&\n      (this._audioTimestampBreak || !this.audioTrack.exist())\n\n    if (resetBaseDts) {\n      this._resetBaseDtsWhenStreamBreaked()\n    }\n\n    this._fixAudio(audioTrack)\n\n    this._keyFrameInNextChunk = false\n\n    this._fixVideo(videoTrack)\n\n    if (this.metadataTrack.exist()) {\n      const timescale = this.metadataTrack.timescale\n      this.metadataTrack.seiSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n      this.metadataTrack.flvScriptSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n    }\n\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 1000\n    }\n  }\n\n  _fixVideo (videoTrack) {\n    const samples = videoTrack.samples\n\n    if (!samples.length) return\n\n    samples.forEach(x => {\n      x.dts -= this._baseDts\n      x.pts -= this._baseDts\n      if (x.keyframe) this._keyFrameInNextChunk = true\n    })\n\n    let refSampleDurationInt\n    if (videoTrack.fpsNum && videoTrack.fpsDen) {\n      refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum)\n    } else if (videoTrack.length > 1) {\n      const first = videoTrack.samples[0]\n      const last = videoTrack.samples[samples.length - 1]\n      refSampleDurationInt = Math.floor((last.dts - first.dts) / (samples.length - 1))\n    } else {\n      refSampleDurationInt = this._lastVideoDuration || 40\n    }\n\n    const lastSample = samples.pop()\n\n    if (this._videoLastSample) {\n      samples.unshift(this._videoLastSample)\n    }\n\n    this._videoLastSample = lastSample\n\n    if (!samples.length) return\n\n    if (this._videoNextDts === undefined) {\n      const samp0 = samples[0]\n      this._videoNextDts = samp0.dts\n    }\n\n    const len = samples.length\n    let sampleDuration = 0\n    const firstSample = samples[0]\n    const vDelta = this._videoNextDts - firstSample.dts\n\n    if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {\n      // emit large delta of first sample with expect\n      if (Math.abs(firstSample.dts - this._lastVideoExceptionChunkFirstDtsDot) > VIDEO_EXCETION_LOG_EMIT_DURATION) {\n        this._lastVideoExceptionChunkFirstDtsDot = firstSample.dts\n\n        videoTrack.warnings.push({\n          type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,\n          nextDts: this._videoNextDts,\n          firstSampleDts: firstSample.dts,\n          nextSampleDts: samples[1]?.dts,\n          sampleDuration: vDelta\n        })\n      }\n\n      // only video breaked\n      if (this._videoTimestampBreak >= TRACK_BREACKED_CHECK_TIME) {\n        this._videoNextDts = firstSample.dts\n        this._videoTimestampBreak = 0\n      } else {\n        // resolve first frame only\n        firstSample.dts += vDelta\n        firstSample.pts += vDelta\n        if (!this.audioTrack.exist()) {\n          this._videoTimestampBreak = 1\n        }\n      }\n    }\n\n    for (let i = 0; i < len; i++) {\n      const dts = samples[i].dts\n      const nextSample = samples[i + 1]\n\n      if (i < len - 1) {\n        sampleDuration = nextSample.dts - dts\n      } else if (lastSample) {\n        sampleDuration = lastSample.dts - dts\n      } else {\n        sampleDuration = refSampleDurationInt\n      }\n\n      if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {\n        this._videoTimestampBreak++\n        // emit stream breaked\n        if (Math.abs(dts - this._lastVideoExceptionLargeGapDot) > VIDEO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastVideoExceptionLargeGapDot = dts\n          videoTrack.warnings.push({\n            type: WarningType.LARGE_VIDEO_GAP,\n            time: dts / videoTrack.timescale,\n            dts,\n            originDts: samples[i].originDts,\n            nextDts: this._videoNextDts,\n            sampleDuration,\n            refSampleDuration: refSampleDurationInt\n          })\n        }\n\n        sampleDuration = refSampleDurationInt\n      }\n\n      samples[i].duration = sampleDuration\n      this._videoNextDts += sampleDuration\n      this._lastVideoDuration = sampleDuration\n    }\n  }\n\n  _fixAudio (audioTrack) {\n    const samples = audioTrack.samples\n    if (!samples.length) return\n\n    // offset origin timestamp\n    samples.forEach(x => {\n      x.dts = x.pts -= this._baseDts\n    })\n\n    this._doFixAudioInternal(audioTrack, samples, 1000)\n  }\n\n  _calculateBaseDts (audioTrack, videoTrack) {\n    const audioSamps = audioTrack.samples\n    const videoSamps = videoTrack.samples\n\n    if (!audioSamps.length && !videoSamps.length) {\n      return false\n    }\n\n    let audioBasePts = Infinity\n    let videoBaseDts = Infinity\n\n    if (audioSamps.length) {\n      audioTrack.baseDts = audioBasePts = audioSamps[0].pts\n    }\n\n    if (videoSamps.length) {\n      videoTrack.baseDts = videoBaseDts = videoSamps[0].dts\n    }\n\n    this._baseDts = Math.min(audioBasePts, videoBaseDts)\n\n    const delta = videoBaseDts - audioBasePts\n\n    if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_AV_SHIFT,\n        videoBaseDts,\n        audioBasePts,\n        baseDts: this._baseDts,\n        delta\n      })\n    }\n\n    this._baseDtsInited = true\n    return true\n  }\n\n  _resetBaseDtsWhenStreamBreaked () {\n    /**\n       * timestamp breaked\n       *                     _audioNextDts\n       *  ---------------------|\n       * (_baseDts)          _videoNextDts\n       * ----------------------|\n       *                        <----------------\n       *                                       nextVideo.dts\n       * ----------------------------------------|\n       *                                       nextAudio.dts\n       * ---------------------------------------|\n       */\n\n    // calc baseDts base on new samples\n    const calc = this._calculateBaseDts(this.audioTrack, this.videoTrack)\n\n    if (!calc) return\n\n    // consider the expect dts for next frame\n    if (!this.audioTrack.exist()){\n      this._baseDts -= this._videoNextDts\n    } else if (!this.videoTrack.exist()){\n      this._baseDts -= this._audioNextPts\n    } else {\n      this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts)\n    }\n    this._videoTimestampBreak = 0\n    this._audioTimestampBreak = 0\n  }\n\n  _doFixAudioInternal (audioTrack, samples, timescale) {\n    if (!audioTrack.sampleDuration) {\n      audioTrack.sampleDuration = audioTrack.codecType === AudioCodecType.AAC\n        ? AAC.getFrameDuration(audioTrack.timescale, timescale)\n        : this._getG711Duration(audioTrack)\n    }\n    const refSampleDuration = audioTrack.sampleDuration\n\n    const sampleDurationInSampleRate = audioTrack.codecType === AudioCodecType.AAC ? 1024 : refSampleDuration * audioTrack.timescale / 1000\n\n    if (this._audioNextPts === undefined) {\n      const samp0 = samples[0]\n      this._audioNextPts = samp0.pts\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      let nextPts = this._audioNextPts\n      const sample = samples[i]\n      let delta = sample.pts - nextPts\n\n      // only audio breaked\n      if (i === 0 && this._audioTimestampBreak >= TRACK_BREACKED_CHECK_TIME && this._keyFrameInNextChunk) {\n        nextPts = this._audioNextPts = sample.dts\n        delta = 0\n        this._audioTimestampBreak = 0\n      }\n\n      // fill frames\n      // delta >= 3 * refSampleDurationInt\n      // delta <= 500s\n      if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {\n        const silentFrame = this._getSilentFrame(audioTrack) || samples[0].data.subarray()\n        const count = Math.floor(delta / refSampleDuration)\n\n        if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionGapDot = sample.pts\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_FILLED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            count,\n            nextPts,\n            refSampleDuration\n          })\n        }\n\n        for (let j = 0; j < count; j++) {\n          const silentSample = new AudioSample(Math.floor(this._audioNextPts + refSampleDuration) - Math.floor(this._audioNextPts), silentFrame, sampleDurationInSampleRate)\n          silentSample.originPts = Math.floor(this._baseDts + nextPts)\n          samples.splice(i, 0, silentSample)\n          this._audioNextPts += refSampleDuration\n          i++\n        }\n\n        i--\n        // delta  <= -3 * refSampleDurationInt\n        // delta  >= -500ms\n      } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {\n        // need discard frames\n        if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionOverlapDot = sample.pts\n\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_DROPPED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            nextPts,\n            refSampleDuration\n          })\n        }\n        samples.splice(i, 1)\n        i--\n      } else {\n        if (Math.abs(delta) > MAX_SILENT_FRAME_DURATION) {\n          this._audioTimestampBreak++\n\n          if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n            this._lastAudioExceptionLargeGapDot = sample.pts\n            audioTrack.warnings.push({\n              type: WarningType.LARGE_AUDIO_GAP,\n              time: sample.pts / 1000,\n              pts: sample.pts,\n              originPts: sample.originPts,\n              nextPts,\n              sampleDuration: delta,\n              refSampleDuration\n            })\n          }\n        }\n\n        sample.dts = sample.pts = nextPts\n        sample.duration = sampleDurationInSampleRate\n        this._audioNextPts += refSampleDuration\n      }\n    }\n  }\n\n  _getG711Duration (track) {\n    const { sampleSize, channelCount, sampleRate } = track\n    const samp0 = track.samples[0]\n    if (!samp0) return\n    return samp0.data.byteLength * 2 / channelCount / (sampleSize / 8) / sampleRate * 1000\n  }\n\n  _getSilentFrame (track) {\n    if (track.codecType === AudioCodecType.AAC) return AAC.getSilentFrame(track.codec, track.channelCount)\n    return new Uint8Array(8 * track.sampleDuration * track.channelCount)\n  }\n}\n","import { UTF8 } from '../utils'\n\nexport class AMF {\n  static parse (data) {\n    if (data.length < 3) return\n\n    const ret = {}\n    const name = AMF._parseValue(new DataView(data.buffer, data.byteOffset, data.byteLength))\n    const value = AMF._parseValue(new DataView(data.buffer, data.byteOffset + name.size, data.byteLength - name.size))\n    ret[name.data] = value.data\n\n    return ret\n  }\n\n  static _parseValue (view) {\n    const dataLen = view.byteLength\n    const type = view.getUint8(0)\n    let offset = 1\n    let isEnd = false\n    let value\n\n    switch (type) {\n      case 0: // Number(Double) type\n        value = view.getFloat64(1)\n        offset += 8\n        break\n      case 1: { // Boolean type\n        value = !!view.getUint8(1)\n        offset += 1\n        break\n      }\n      case 2: { // String type\n        const { data, size } = AMF._parseString(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset))\n        value = data\n        offset += size\n      }\n        break\n      case 3: { // Object(s) type\n        value = {}\n        let terminal = 0\n        if ((view.getUint32(dataLen - 4) & 0x00FFFFFF) === 9) {\n          terminal = 3\n        }\n        while (offset < dataLen - 4) { // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n          const { size, data, isEnd } = AMF._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal))\n          if (isEnd) break\n          value[data.name] = data.value\n          offset += size\n        }\n        if (offset <= dataLen - 3) {\n          const marker = view.getUint32(offset - 1) & 0x00FFFFFF\n          if (marker === 9) offset += 3\n        }\n      }\n        break\n      case 8: { // ECMA array type (Mixed array)\n        value = {}\n        offset += 4 // ECMAArrayLength(UI32)\n        let terminal = 0 // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n        if ((view.getUint32(dataLen - 4) & 0x00FFFFFF) === 9) {\n          terminal = 3\n        }\n        while (offset < dataLen - 8) { // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n          const { size, data, isEnd } = AMF._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal))\n          if (isEnd) break\n          value[data.name] = data.value\n          offset += size\n        }\n        if (offset <= dataLen - 3) {\n          const marker = view.getUint32(offset - 1) & 0x00FFFFFF\n          if (marker === 9) {\n            offset += 3\n          }\n        }\n      }\n        break\n      case 9: // ScriptDataObjectEnd\n        value = undefined\n        offset = 1\n        isEnd = true\n        break\n      case 10: { // Strict array type\n        value = []\n        const strictArrayLength = view.getUint32(1)\n        offset += 4\n        for (let i = 0; i < strictArrayLength; i++) {\n          const { data, size } = AMF._parseValue(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset))\n          value.push(data)\n          offset += size\n        }\n      }\n        break\n      case 11: { // Date type\n        const timestamp = view.getFloat64(offset) + view.getInt16(offset + 8) * 60000\n        value = new Date(timestamp)\n        offset += 10\n      }\n        break\n      case 12: { // Long string type\n        const length = view.getUint32(1)\n        offset += 4\n        value = ''\n        if (length > 0) {\n          value = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + offset, length))\n        }\n        offset += length\n      }\n        break\n      default:\n        offset = dataLen\n        break\n    }\n\n    return {\n      data: value,\n      size: offset,\n      isEnd\n    }\n  }\n\n  static _parseString (view) {\n    const length = view.getUint16(0)\n    let data = ''\n    if (length > 0) {\n      data = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + 2, length))\n    }\n\n    return {\n      data,\n      size: 2 + length\n    }\n  }\n\n  static _parseObject (view) {\n    if (view.byteLength < 3) return\n\n    const name = AMF._parseString(view)\n    const value = AMF._parseValue(new DataView(view.buffer, view.byteOffset + name.size, view.byteLength - name.size))\n\n    return {\n      data: {\n        name: name.data,\n        value: value.data\n      },\n      size: name.size + value.size,\n      isEnd: value.isEnd\n    }\n  }\n}\n","import { VideoTrack, AudioTrack, MetadataTrack, AudioSample, VideoSample, VideoCodecType, AudioCodecType, FlvScriptSample, SeiSample } from '../model'\nimport { FlvFixer } from './fixer'\nimport { concatUint8Array, Logger, readBig32 } from '../utils'\nimport { AAC, AVC, HEVC, NALu } from '../codec'\nimport { AMF } from './amf'\n\nconst logger = new Logger('FlvDemuxer')\n\n/**\n * @typedef {Object} DemuxResult\n * @property {VideoTrack} videoTrack\n * @property {AudioTrack} audioTrack\n * @property {MetadataTrack} metadataTrack\n */\n\nexport class FlvDemuxer {\n  _headerParsed = false\n  _remainingData = null\n  _gopId = 0\n  _needAddMetaBeforeKeyFrameNal = true // 标识H265流中关键帧Nal之前是否需要插入vps、sps、pps Nal\n\n  static AUDIO_RATE = [5500, 11000, 22000, 44000]\n\n  /**\n   * @param {VideoTrack} [videoTrack]\n   * @param {AudioTrack} [audioTrack]\n   * @param {MetadataTrack} [metadataTrack]\n   */\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this._fixer = new FlvFixer(this.videoTrack, this.audioTrack, this.metadataTrack)\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {DemuxResult}\n   */\n  demux (data, discontinuity = false, contiguous = true) {\n    const { audioTrack, videoTrack, metadataTrack } = this\n\n    if (discontinuity || !contiguous) {\n      this._remainingData = null\n      this._headerParsed = false\n    }\n\n    if (discontinuity) {\n      videoTrack.reset()\n      audioTrack.reset()\n      metadataTrack.reset()\n    } else {\n      videoTrack.samples = []\n      audioTrack.samples = []\n      metadataTrack.seiSamples = []\n      metadataTrack.flvScriptSamples = []\n      videoTrack.warnings = []\n      audioTrack.warnings = []\n\n      if (this._remainingData) {\n        data = concatUint8Array(this._remainingData, data)\n        this._remainingData = null\n      }\n    }\n\n    if (!data.length) {\n      return {\n        videoTrack,\n        audioTrack,\n        metadataTrack\n      }\n    }\n\n    let offset = 0\n    if (!this._headerParsed) {\n      if (!FlvDemuxer.probe(data)) {\n        throw new Error('Invalid flv file')\n      }\n      audioTrack.present = ((data[4] & 4) >>> 2) !== 0\n      videoTrack.present = (data[4] & 1) !== 0\n      this._headerParsed = true\n      offset = readBig32(data, 5) + 4 // skip prev tag size\n    }\n\n    const dataLen = data.length\n\n    let tagType\n    let dataSize\n    let timestamp\n    let bodyData\n    let prevTagSize\n    while ((offset + 15) < dataLen) { // header and prev tag size\n      tagType = data[offset]\n      dataSize = (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3]\n      if (offset + 15 + dataSize > dataLen) break\n      timestamp = (\n        (data[offset + 7] << 24 >>> 0) +\n        (data[offset + 4] << 16) +\n        (data[offset + 5] << 8) +\n        data[offset + 6]\n      )\n\n      offset += 11\n      bodyData = data.subarray(offset, offset + dataSize)\n      if (tagType === 8) {\n        this._parseAudio(bodyData, timestamp)\n      } else if (tagType === 9) {\n        this._parseVideo(bodyData, timestamp)\n      } else if (tagType === 18) {\n        this._parseScript(bodyData, timestamp)\n      } else {\n        logger.warn(`Invalid tag type: ${tagType}`)\n      }\n\n      offset += dataSize\n      prevTagSize = readBig32(data, offset)\n      if (prevTagSize !== 11 + dataSize) {\n        logger.warn(`Invalid PrevTagSize ${prevTagSize} (${11 + dataSize})`)\n      }\n\n      offset += 4\n    }\n\n    if (offset < dataLen) {\n      this._remainingData = data.subarray(offset)\n    }\n\n    audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 1000\n    audioTrack.timescale = audioTrack.sampleRate || 0\n\n    if (!audioTrack.exist() && audioTrack.hasSample()) {\n      audioTrack.reset()\n    }\n    if (!videoTrack.exist() && videoTrack.hasSample()) {\n      videoTrack.reset()\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack\n    }\n  }\n\n  /**\n   * @param {number} [startTime=0]\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {DemuxResult}\n   */\n  fix (startTime, discontinuity, contiguous) {\n    this._fixer.fix(startTime, discontinuity, contiguous)\n    return {\n      videoTrack: this.videoTrack,\n      audioTrack: this.audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @param {number} [startTime=0]\n   * @returns {DemuxResult}\n   */\n  demuxAndFix (data, discontinuity, contiguous, startTime) {\n    this.demux(data, discontinuity, contiguous)\n    return this.fix(startTime, discontinuity, contiguous)\n  }\n\n  /**\n   * @param { Uint8Array } data\n   * @returns {boolean}\n   */\n  static probe (data) {\n    if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n      return false\n    }\n    return readBig32(data, 5) >= 9\n  }\n\n  _parseAudio (data, pts) {\n    if (!data.length) return\n\n    const format = (data[0] & 0xf0) >>> 4\n    const track = this.audioTrack\n\n    if (\n      format !== 10 && // AAC\n      format !== 7 && // G.711 A-law logarithmic PCM\n      format !== 8 // G.711 mu-law logarithmic PCM\n    ) {\n      logger.warn(`Unsupported sound format: ${format}`)\n      track.reset()\n      return\n    }\n\n    if (format !== 10) {\n      const soundRate = (data[0] & 0x0c) >> 2\n      const soundSize = (data[0] & 0x02) >> 1\n      const soundType = (data[0] & 0x01)\n      track.sampleRate = FlvDemuxer.AUDIO_RATE[soundRate]\n      track.sampleSize = soundSize ? 16 : 8\n      track.channelCount = soundType + 1\n    }\n\n    if (format === 10) {\n      this._parseAac(data, pts)\n    } else {\n      this._parseG711(data, pts, format)\n    }\n  }\n\n  _parseG711 (data, pts, format) {\n    const track = this.audioTrack\n    track.codecType = format === 7 ? AudioCodecType.G711PCMA : AudioCodecType.G711PCMU\n    track.sampleRate = 8000\n    track.codec = track.codecType\n    track.samples.push(new AudioSample(pts, data.subarray(1)))\n  }\n\n  _parseAac (data, pts) {\n    const track = this.audioTrack\n    track.codecType = AudioCodecType.AAC\n\n    if (data[1] === 0) { // AACPacketType\n      const ret = AAC.parseAudioSpecificConfig(data.subarray(2))\n      if (ret) {\n        track.codec = ret.codec\n        track.channelCount = ret.channelCount\n        track.sampleRate = ret.sampleRate\n        track.config = ret.config\n        track.objectType = ret.objectType\n        track.sampleRateIndex = ret.samplingFrequencyIndex\n      } else {\n        track.reset()\n        logger.warn('Cannot parse AudioSpecificConfig', data)\n      }\n    } else if (data[1] === 1) { // Raw AAC frame data\n      if (pts === undefined || pts === null) return\n      track.samples.push(new AudioSample(pts, data.subarray(2)))\n    } else {\n      logger.warn(`Unknown AACPacketType: ${data[1]}`)\n    }\n  }\n\n  _parseVideo (data, dts) {\n    if (data.length < 6) return\n\n    const frameType = (data[0] & 0xf0) >>> 4\n    const codecId = data[0] & 0x0f\n\n    const track = this.videoTrack\n\n    if (\n      codecId !== 7 && // AVC\n      codecId !== 12 // HEVC\n    ) {\n      track.reset()\n      logger.warn(`Unsupported codecId: ${codecId}`)\n      return\n    }\n\n    const isHevc = codecId === 12\n    track.codecType = isHevc ? VideoCodecType.HEVC : VideoCodecType.AVC\n\n    const packetType = data[1]\n    const cts = (((data[2] << 16) | (data[3] << 8) | (data[4])) << 8) >> 8\n\n    if (packetType === 0) { // DecoderConfigurationRecord\n      const configData = data.subarray(5)\n      const ret = isHevc\n        ? HEVC.parseHEVCDecoderConfigurationRecord(configData)\n        : AVC.parseAVCDecoderConfigurationRecord(configData)\n      if (ret) {\n        const { hvcC, sps, ppsArr, spsArr, vpsArr, nalUnitSize } = ret\n        if (hvcC) {\n          track.hvcC = track.hvcC || hvcC\n        }\n        if (sps) {\n          track.codec = sps.codec\n          track.width = sps.width\n          track.height = sps.height\n          track.sarRatio = sps.sarRatio\n          track.fpsNum = sps.fpsNum\n          track.fpsDen = sps.fpsDen\n        }\n        if (spsArr.length) track.sps = spsArr\n        if (ppsArr.length) track.pps = ppsArr\n        if (vpsArr && vpsArr.length) track.vps = vpsArr\n        if (nalUnitSize) track.nalUnitSize = nalUnitSize\n      } else {\n        logger.warn(`Cannot parse ${isHevc ? 'HEVC' : 'AVC'}DecoderConfigurationRecord`, data)\n      }\n    } else if (packetType === 1) { // One or more NALUs\n      let units = NALu.parseAvcC(data.subarray(5), track.nalUnitSize)\n\n      units = this._checkAddMetaNalToUnits(isHevc, units, track)\n\n      if (units && units.length) {\n        const sample = new VideoSample(dts + cts, dts, units)\n        if (frameType === 1) {\n          sample.setToKeyframe()\n        }\n        track.samples.push(sample)\n\n        units.forEach(unit => {\n          const type = isHevc ? (unit[0] >>> 1) & 0x3f : unit[0] & 0x1f\n          switch (type) {\n            case 5: // IDR\n            case 16: // HEVC BLA_W_LP\n            case 17: // HEVC BLA_W_RADL\n            case 18: // HEVC BLA_N_LP\n            case 19: // HEVC IDR_W_RADL\n            case 20: // HEVC IDR_N_LP\n            case 21: // HEVC CRA_NUT\n            case 22: // HEVC RSV_IRAP_VCL22\n            case 23: // HEVC RSV_IRAP_VCL23\n              if ((!isHevc && type !== 5) || (isHevc && type === 5)) break\n              sample.setToKeyframe()\n              break\n            case 6: // SEI\n            case 39: // HEVC PREFIX_SEI\n            case 40: // HEVC SUFFIX_SEI\n              if ((!isHevc && type !== 6) || (isHevc && type === 6)) break\n              this.metadataTrack.seiSamples.push(new SeiSample(\n                NALu.parseSEI(NALu.removeEPB(unit), isHevc),\n                dts + cts\n              ))\n              break\n            default:\n          }\n        })\n\n        if (sample.keyframe) {\n          this._gopId++\n        }\n        sample.gopId = this._gopId\n      } else {\n        logger.warn('Cannot parse NALUs', data)\n      }\n    } else if (packetType === 2) {\n      // AVC end of sequence, Empty\n    } else {\n      logger.warn(`Unknown AVCPacketType: ${packetType}`)\n    }\n  }\n\n  _checkAddMetaNalToUnits (hevc, units, track) {\n    if (!hevc || !this._needAddMetaBeforeKeyFrameNal) {\n      this._needAddMetaBeforeKeyFrameNal = false\n      return units\n    }\n\n    const nalTypes = units.map(x => (x[0] >>> 1) & 0x3f)\n\n    if (nalTypes.includes(32)) {\n      this._needAddMetaBeforeKeyFrameNal = false\n      return units\n    }\n\n    units.unshift(track.pps[0])\n    units.unshift(track.sps[0])\n    units.unshift(track.vps[0])\n\n    return units.filter(Boolean)\n  }\n\n  _parseScript (data, pts) {\n    this.metadataTrack.flvScriptSamples.push(new FlvScriptSample(AMF.parse(data), pts))\n  }\n}\n","import { AudioSample, WarningType } from '../model'\nimport { AAC } from '../codec'\nimport { isSafari } from '../utils'\n\nconst LARGE_AV_FIRST_FRAME_GAP = 90000 / 2 // 500ms\nconst AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3\nconst MAX_SILENT_FRAME_DURATION = 90000 // 1s\nconst AUDIO_EXCETION_LOG_EMIT_DURATION = 5 * 90000 // 5s\nconst MAX_VIDEO_FRAME_DURATION = 90000 // 1s\nconst MAX_DTS_DELTA_WITH_NEXT_CHUNK = 90000 / 2 // 500ms\n\nexport class TsFixer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    this.metadataTrack = metadataTrack\n\n    this._baseDts = -1\n    this._baseDtsInited = false\n\n    this._audioNextPts = undefined\n    this._videoNextDts = undefined\n\n    this._audioTimestampBreak = false\n    this._videoTimestampBreak = false\n\n    this._lastAudioExceptionGapDot = 0\n    this._lastAudioExceptionOverlapDot = 0\n    this._lastAudioExceptionLargeGapDot = 0\n  }\n\n  fix (startTime = 0, discontinuity = false, contiguous = true) {\n    startTime = Math.round(startTime * 90000)\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    const vSamples = videoTrack.samples\n    const aSamples = audioTrack.samples\n\n    if (!vSamples.length && !aSamples.length) return\n\n    const firstVideoSample = vSamples[0]\n    const firstAudioSample = aSamples[0]\n\n    // consider av delta\n    let vaDelta = 0\n\n    if (vSamples.length && aSamples.length) {\n      vaDelta = firstVideoSample.dts - firstAudioSample.pts\n    }\n\n    if (!this._baseDtsInited) {\n      this._calculateBaseDts(this.audioTrack, this.videoTrack)\n    }\n\n    // recalc baseDts\n    if (discontinuity) {\n      this._calculateBaseDts(this.audioTrack, this.videoTrack)\n      this._baseDts -= startTime\n    }\n\n    // id discontinue, recalc nextDts, consider av delta of firstframe\n    if (!contiguous) {\n      /**\n       *  segment.start = min(a, v)\n       *  segment.start\n       *      |\n       *      a\n       *       -- vaDelta --\n       *                   v\n       */\n      this._videoNextDts = vaDelta > 0 ? startTime + vaDelta : startTime\n      this._audioNextPts = vaDelta > 0 ? startTime : startTime - vaDelta\n\n      const vDeltaToNextDts = firstVideoSample ? firstVideoSample.dts - this._baseDts - this._videoNextDts : 0\n      const aDeltaToNextDts = firstAudioSample ? firstAudioSample.pts - this._baseDts - this._audioNextPts : 0\n\n      if (Math.abs(vDeltaToNextDts || aDeltaToNextDts) > MAX_VIDEO_FRAME_DURATION) {\n        this._calculateBaseDts(this.audioTrack, this.videoTrack)\n        this._baseDts -= startTime\n      }\n    }\n\n    this._resetBaseDtsWhenStreamBreaked()\n\n    // fix audio first\n    this._fixAudio(audioTrack)\n\n    this._fixVideo(videoTrack)\n\n    if (this.metadataTrack.exist()) {\n      const timescale = this.metadataTrack.timescale\n      this.metadataTrack.seiSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n    }\n\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 90000\n    }\n  }\n\n  _fixVideo (videoTrack) {\n    const samples = videoTrack.samples\n\n    if (!samples.length) return\n    samples.forEach(x => {\n      x.dts -= this._baseDts\n      x.pts -= this._baseDts\n    })\n\n    if (this._videoNextDts === undefined) {\n      const samp0 = samples[0]\n      this._videoNextDts = samp0.dts\n    }\n\n    const len = samples.length\n    let sampleDuration = 0\n    const firstSample = samples[0]\n    const nextSample = samples[1]\n    const vDelta = this._videoNextDts - firstSample.dts\n\n    if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {\n      // resolve first frame first\n      firstSample.dts += vDelta\n      firstSample.pts += vDelta\n\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,\n        nextDts: this._videoNextDts,\n        firstSampleDts: firstSample.dts,\n        nextSampleDts: samples[1]?.dts,\n        sampleDuration: vDelta\n      })\n\n      // check to ajust the whole segment\n      if (nextSample && Math.abs(nextSample.dts - firstSample.dts) > MAX_VIDEO_FRAME_DURATION) {\n        this._videoTimestampBreak = true\n        samples.forEach((x, i) => {\n          if (i === 0) return\n          x.dts += vDelta\n          x.pts += vDelta\n        })\n      }\n    }\n\n    let refSampleDurationInt\n    if (videoTrack.fpsNum && videoTrack.fpsDen) {\n      refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum)\n    } else {\n      const first = videoTrack.samples[0]\n      const last = videoTrack.samples[len - 1]\n      // 100ms default\n      refSampleDurationInt = len === 1 ? 9000 : Math.floor((last.dts - first.dts) / (len - 1))\n    }\n\n    for (let i = 0; i < len; i++) {\n      const dts = samples[i].dts\n      const nextSample = samples[i + 1]\n      if (i < len - 1) {\n        sampleDuration = nextSample.dts - dts\n      } else if (samples[i - 1]) {\n        sampleDuration = Math.min(dts - samples[i - 1].dts, refSampleDurationInt)\n      } else {\n        sampleDuration = refSampleDurationInt\n      }\n\n      if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {\n        // dts exception of adjacent frame\n        this._videoTimestampBreak = true\n\n        // check if only video breaked!\n        sampleDuration = this._audioTimestampBreak ? refSampleDurationInt : Math.max(sampleDuration, 30 * 90) // 30ms\n\n        // check if sample breaked within current fragment\n        const expectFragEnd = (this._audioNextPts || 0)\n        if (nextSample && nextSample.dts > expectFragEnd) {\n          sampleDuration = refSampleDurationInt\n        }\n\n        videoTrack.warnings.push({\n          type: WarningType.LARGE_VIDEO_GAP,\n          time: dts / videoTrack.timescale,\n          dts,\n          originDts: samples[i].originDts,\n          nextDts: this._videoNextDts,\n          sampleDuration,\n          refSampleDuration: refSampleDurationInt\n        })\n      }\n\n      samples[i].duration = sampleDuration\n      this._videoNextDts += sampleDuration\n    }\n  }\n\n  _fixAudio (audioTrack) {\n    const samples = audioTrack.samples\n\n    if (!samples.length) return\n    samples.forEach(x => {\n      x.pts -= this._baseDts\n      x.dts = x.pts\n    })\n\n    this._doFixAudioInternal(audioTrack, samples, 90000)\n  }\n\n  _calculateBaseDts (audioTrack, videoTrack) {\n    const audioSamps = audioTrack.samples\n    const videoSamps = videoTrack.samples\n\n    if (!audioSamps.length && !videoSamps.length) {\n      return false\n    }\n\n    let audioBasePts = Infinity\n    let videoBaseDts = Infinity\n\n    if (audioSamps.length) {\n      audioTrack.baseDts = audioBasePts = audioSamps[0].pts\n    }\n\n    if (videoSamps.length) {\n      videoTrack.baseDts = videoBaseDts = videoSamps[0].dts\n    }\n\n    this._baseDts = Math.min(audioBasePts, videoBaseDts)\n\n    const delta = videoBaseDts - audioBasePts\n\n    if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_AV_SHIFT,\n        videoBaseDts,\n        audioBasePts,\n        baseDts: this._baseDts,\n        delta\n      })\n    }\n\n    this._baseDtsInited = true\n    return true\n  }\n\n  _resetBaseDtsWhenStreamBreaked () {\n    if (this._baseDtsInited && this._videoTimestampBreak && this._audioTimestampBreak) {\n      /**\n       * timestamp breaked\n       *                     _audioNextDts\n       *  ---------------------|\n       * (_baseDts)          _videoNextDts\n       * ----------------------|\n       *                        <----------------\n       *                                       nextVideo.dts\n       * ----------------------------------------|\n       *                                       nextAudio.dts\n       * ---------------------------------------|\n       */\n\n      // calc baseDts base on new samples\n      const calc = this._calculateBaseDts(this.audioTrack, this.videoTrack)\n\n      if (!calc) return\n\n      // consider the expect dts for next frame\n      this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts)\n      this._audioLastSample = null\n      this._videoLastSample = null\n      this._videoTimestampBreak = false\n      this._audioTimestampBreak = false\n    }\n  }\n\n  _doFixAudioInternal (audioTrack, samples, timescale) {\n    if (!audioTrack.sampleDuration) audioTrack.sampleDuration = AAC.getFrameDuration(audioTrack.timescale, timescale)\n    const refSampleDuration = audioTrack.sampleDuration\n\n    if (this._audioNextPts === undefined) {\n      const samp0 = samples[0]\n      this._audioNextPts = samp0.pts\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      const nextPts = this._audioNextPts\n      const sample = samples[i]\n      const delta = sample.pts - nextPts\n\n      // fill frames\n      // delta >= 3 * refSampleDurationInt\n      // delta <= 500s\n      if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {\n        const silentFrame = AAC.getSilentFrame(audioTrack.codec, audioTrack.channelCount) || samples[0].data.subarray()\n        const count = Math.floor(delta / refSampleDuration)\n\n        if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionGapDot = sample.pts\n        }\n\n        audioTrack.warnings.push({\n          type: WarningType.AUDIO_FILLED,\n          pts: sample.pts,\n          originPts: sample.originPts,\n          count,\n          nextPts,\n          refSampleDuration\n        })\n\n        for (let j = 0; j < count; j++) {\n          const silentSample = new AudioSample(Math.floor(nextPts), silentFrame)\n          silentSample.originPts = Math.floor(this._baseDts + nextPts)\n          samples.splice(i, 0, silentSample)\n          this._audioNextPts += refSampleDuration\n          i++\n        }\n\n        i--\n        // delta  <= -3 * refSampleDurationInt\n        // delta  >= -500ms\n      } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {\n        // need discard frames\n        if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionOverlapDot = sample.pts\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_DROPPED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            nextPts,\n            refSampleDuration\n          })\n        }\n        samples.splice(i, 1)\n        i--\n      } else {\n        if (Math.abs(delta) >= MAX_SILENT_FRAME_DURATION) {\n          this._audioTimestampBreak = true\n\n          if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n            this._lastAudioExceptionLargeGapDot = sample.pts\n            audioTrack.warnings.push({\n              type: WarningType.LARGE_AUDIO_GAP,\n              time: sample.pts / 1000,\n              pts: sample.pts,\n              originPts: sample.originPts,\n              nextPts,\n              sampleDuration: delta,\n              refSampleDuration\n            })\n          }\n        }\n\n        sample.dts = sample.pts = nextPts\n        this._audioNextPts += refSampleDuration\n      }\n    }\n  }\n}\n","import { TsFixer } from './fixer'\nimport { AVC, AAC, HEVC, NALu } from '../codec'\nimport { VideoSample, AudioSample, VideoCodecType, VideoTrack, AudioTrack, MetadataTrack, SeiSample } from '../model'\nimport { Logger, concatUint8Array } from '../utils'\n\nconst logger = new Logger('TsDemuxer')\n\nexport class TsDemuxer {\n  _pmtId = -1\n  _remainingPacketData = null\n  _videoPesData = []\n  _audioPesData = []\n  _gopId = 0\n\n  /**\n   * @param {VideoTrack} [videoTrack]\n   * @param {AudioTrack} [audioTrack]\n   * @param {MetadataTrack} [metadataTrack]\n   */\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this._fixer = new TsFixer(this.videoTrack, this.audioTrack, this.metadataTrack)\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {import('../flv').DemuxResult}\n   */\n  demux (data, discontinuity = false, contiguous = true) {\n    const { audioTrack, videoTrack, metadataTrack } = this\n\n    if (discontinuity) {\n      this._pmtId = -1\n      videoTrack.reset()\n      audioTrack.reset()\n      metadataTrack.reset()\n    }\n\n    if (!contiguous || discontinuity) {\n      this._remainingPacketData = null\n      this._videoPesData = []\n      this._audioPesData = []\n    } else {\n      videoTrack.samples = []\n      audioTrack.samples = []\n      metadataTrack.seiSamples = []\n      videoTrack.warnings = []\n      audioTrack.warnings = []\n\n      if (this._remainingPacketData) {\n        data = concatUint8Array(this._remainingPacketData, data)\n        this._remainingPacketData = null\n      }\n    }\n\n    let dataLen = data.length\n    const remainingLength = dataLen % 188\n    if (remainingLength) {\n      this._remainingPacketData = data.subarray(dataLen - remainingLength)\n      dataLen -= remainingLength\n    }\n\n    let videoPid = videoTrack.pid\n    let audioPid = audioTrack.pid\n\n    for (let start = 0; start < dataLen; start += 188) {\n      if (data[start] !== 0x47) throw new Error('TS packet did not start with 0x47')\n      const payloadUnitStartIndicator = !!(data[start + 1] & 0x40)\n      const pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2]\n      const adaptationFiledControl = (data[start + 3] & 0x30) >> 4\n\n      let offset\n      if (adaptationFiledControl > 1) {\n        offset = start + 5 + data[start + 4]\n        if (offset === start + 188) continue\n      } else {\n        offset = start + 4\n      }\n\n      switch (pid) {\n        case 0: // PAT\n          if (payloadUnitStartIndicator) offset += data[offset] + 1\n          this._pmtId = ((data[offset + 10] & 0x1f) << 8) | data[offset + 11]\n          break\n        case this._pmtId: {\n          if (payloadUnitStartIndicator) offset += data[offset] + 1\n          const tableEnd = offset + 3 + (((data[offset + 1] & 0x0f) << 8) | data[offset + 2]) - 4\n          const programInfoLength = ((data[offset + 10] & 0x0f) << 8) | data[offset + 11]\n          offset += 12 + programInfoLength\n\n          while (offset < tableEnd) {\n            const esPid = ((data[offset + 1] & 0x1f) << 8) | data[offset + 2]\n            switch (data[offset]) {\n              case 0x0f: // AAC ADTS\n                audioTrack.pid = audioPid = esPid\n                break\n              case 0x1b: // AVC\n                if (videoPid !== -1) break\n                videoTrack.codecType = VideoCodecType.AVC\n                videoTrack.pid = videoPid = esPid\n                break\n              case 0x24: // HEVC\n                if (videoPid !== -1) break\n                videoTrack.codecType = VideoCodecType.HEVC\n                videoTrack.pid = videoPid = esPid\n                break\n              default:\n                logger.warn(`Unsupported stream. type: ${data[offset]}, pid: ${esPid}`)\n            }\n\n            offset += (((data[offset + 3] & 0x0f) << 8) | data[offset + 4]) + 5\n          }\n        }\n          break\n        case videoPid:\n          if (payloadUnitStartIndicator && this._videoPesData.length) {\n            this._parseVideoData()\n          }\n          this._videoPesData.push(data.subarray(offset, start + 188))\n          break\n        case audioPid:\n          if (payloadUnitStartIndicator && this._audioPesData.length) {\n            this._parseAudioData()\n          }\n          this._audioPesData.push(data.subarray(offset, start + 188))\n          break\n        case 17:\n        case 0x1fff:\n          break\n        default:\n          logger.warn(`Unknown pid: ${pid}`)\n      }\n    }\n\n    this._parseVideoData()\n    this._parseAudioData()\n\n    audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 90000\n\n    audioTrack.timescale = audioTrack.sampleRate || 0\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack\n    }\n  }\n\n  /**\n   * @param {number} [startTime=0]\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   */\n  fix (startTime, discontinuity, contiguous) {\n    this._fixer.fix(startTime, discontinuity, contiguous)\n    return {\n      videoTrack: this.videoTrack,\n      audioTrack: this.audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @param {number} [startTime=0]\n   */\n  demuxAndFix (data, discontinuity, contiguous, startTime) {\n    this.demux(data, discontinuity, contiguous)\n    return this.fix(startTime, discontinuity, contiguous)\n  }\n\n  /**\n   * @param { Uint8Array } data\n   * @returns {boolean}\n   */\n  static probe (data) {\n    if (!data.length) return false\n    return data[0] === 0x47 && data[188] === 0x47 && data[376] === 0x47\n  }\n\n  _parseVideoData () {\n    if (!this._videoPesData.length) return\n    const pes = TsDemuxer._parsePES(concatUint8Array(...this._videoPesData))\n    if (!pes) {\n      logger.warn('Cannot parse video pes', this._videoPesData)\n      return\n    }\n\n    const units = NALu.parseAnnexB(pes.data)\n    if (units) {\n      this._createVideoSample(units, pes.pts, pes.dts)\n    } else {\n      logger.warn('Cannot parse avc units', pes)\n    }\n\n    this._videoPesData = []\n  }\n\n  _createVideoSample (units, pts, dts) {\n    if (!units.length) return\n    const track = this.videoTrack\n    const isHevc = track.codecType === VideoCodecType.HEVC\n\n    const sample = new VideoSample(pts, dts)\n    units.forEach((unit) => {\n      const type = isHevc ? (unit[0] >>> 1) & 0x3f : unit[0] & 0x1f\n      switch (type) {\n        case 5: // IDR\n        case 16: // HEVC BLA_W_LP\n        case 17: // HEVC BLA_W_RADL\n        case 18: // HEVC BLA_N_LP\n        case 19: // HEVC IDR_W_RADL\n        case 20: // HEVC IDR_N_LP\n        case 21: // HEVC CRA_NUT\n        case 22: // HEVC RSV_IRAP_VCL22\n        case 23: // HEVC RSV_IRAP_VCL23\n          if ((!isHevc && type !== 5) || (isHevc && type === 5)) break\n          sample.setToKeyframe()\n          this._gopId++\n          break\n        case 6: // SEI\n        case 39: // HEVC PREFIX_SEI\n        case 40: // HEVC SUFFIX_SEI\n          if ((!isHevc && type !== 6) || (isHevc && type === 6)) break\n          this.metadataTrack.seiSamples.push(new SeiSample(\n            NALu.parseSEI(NALu.removeEPB(unit), isHevc),\n            pts\n          ))\n          // fix 分割nal之前只要sei信息被当做单独一个sample\n          return\n        case 32: // HEVC VPS\n          if (!isHevc) break\n          if (!track.vps.length) {\n            const hvcC = HEVC.parseVPS(NALu.removeEPB(unit), track.hvcC)\n            track.hvcC = track.hvcC || hvcC\n            track.vps = [unit]\n          }\n          break\n        case 7: // SPS\n        case 33: // HEVC SPS\n          if ((!isHevc && type !== 7) || (isHevc && type === 7)) break\n          if (!track.sps.length) {\n            const data = NALu.removeEPB(unit)\n            const spsInfo = isHevc ? HEVC.parseSPS(data, track.hvcC) : AVC.parseSPS(data)\n            track.sps = [unit]\n            track.hvcC = track.hvcC || spsInfo.hvcC\n            track.codec = spsInfo.codec\n            track.width = spsInfo.width\n            track.height = spsInfo.height\n            track.sarRatio = spsInfo.sarRatio\n            track.fpsNum = spsInfo.fpsNum\n            track.fpsDen = spsInfo.fpsDen\n          }\n          break\n        case 8: // PPS\n        case 34: // HEVC PPS\n          if ((!isHevc && type !== 8) || (isHevc && type === 8)) break\n          if (!track.pps.length) track.pps = [unit]\n          break\n        case 9: // AUD\n        case 35: // HEVC AUD\n          // if ((!isHevc && type !== 9) || (isHevc && type === 9)) break\n          // sample.gopId = this._gopId\n          // if (sample.units.length && !keyFrame) {\n          //   this._pushVideoSample(track, sample)\n          //   sample = this.prevAvcSample = new VideoSample(pts, dts)\n          // }\n          break\n        default:\n      }\n      sample.units.push(unit)\n    })\n    sample.gopId = this._gopId\n    this._pushVideoSample(track, sample)\n  }\n\n  _pushVideoSample (track, sample) {\n    if (sample.units.length) {\n      if (sample.pts === null || sample.pts === undefined) {\n        logger.warn('Video sample no pts', sample)\n        const lastSample = track.samples[track.samples.length - 1]\n        if (lastSample) {\n          sample.pts = lastSample.pts\n          sample.dts = lastSample.dts\n        } else {\n          logger.warn('Drop video sample', sample)\n        }\n      } else {\n        track.samples.push(sample)\n      }\n    }\n  }\n\n  _parseAudioData () {\n    if (!this._audioPesData.length) return\n    const pes = TsDemuxer._parsePES(concatUint8Array(...this._audioPesData))\n    if (!pes) {\n      logger.warn('Cannot parse audio pes', this._audioPesData)\n      return\n    }\n\n    this._parseAacData(pes)\n\n    this._audioPesData = []\n  }\n\n  _parseAacData (pes) {\n    const track = this.audioTrack\n    let pts = pes.pts\n    if (pts === null || pts === undefined) {\n      logger.warn('AAC pes not pts', track)\n      if (!track.samples.length || !track.sampleRate) {\n        return\n      }\n      pts = track.samples[track.samples.length - 1].pts + AAC.getFrameDuration(track.sampleRate)\n    }\n\n    const ret = AAC.parseADTS(pes.data, pts)\n    if (ret) {\n      track.codec = ret.codec\n      track.channelCount = ret.channelCount\n      track.sampleRate = ret.sampleRate\n      track.objectType = ret.objectType\n      track.sampleRateIndex = ret.samplingFrequencyIndex\n      track.config = ret.config\n      track.samples.push(...ret.frames.map((s) => new AudioSample(s.pts, s.data)))\n\n      if (ret.skip) {\n        logger.warn(`Skip aac adts ${ret.skip} bits`)\n      }\n      if (ret.remaining) {\n        logger.warn(`Remaining aac adts ${ret.remaining} bits`)\n      }\n    } else {\n      logger.warn('Cannot parse aac adts', pes)\n    }\n  }\n\n  static _parsePES (data) {\n    const headerDataLen = data[8]\n    if (headerDataLen === null || headerDataLen === undefined || data.length < (headerDataLen + 9)) return\n    const startPrefix = data[0] << 16 | data[1] << 8 | data[2]\n    if (startPrefix !== 1) return\n    const pesLen = (data[4] << 8) + data[5]\n    if (pesLen && pesLen > data.length - 6) return\n\n    let pts\n    let dts\n    const ptsDtsFlags = data[7]\n    if (ptsDtsFlags & 0xc0) {\n      pts = (data[9] & 0x0e) * 536870912 +\n        (data[10] & 0xff) * 4194304 +\n        (data[11] & 0xfe) * 16384 +\n        (data[12] & 0xff) * 128 +\n        (data[13] & 0xfe) / 2\n\n      if (ptsDtsFlags & 0x40) {\n        dts = (data[14] & 0x0e) * 536870912 +\n          (data[15] & 0xff) * 4194304 +\n          (data[16] & 0xfe) * 16384 +\n          (data[17] & 0xff) * 128 +\n          (data[18] & 0xfe) / 2\n        if (pts - dts > 60 * 90000) pts = dts\n      } else {\n        dts = pts\n      }\n    }\n\n    return { data: data.subarray(9 + headerDataLen), pts, dts }\n  }\n}\n","import { AudioCodecType, VideoCodecType } from '../model'\nimport { getAvcCodec, readBig16, readBig24, readBig32, readBig64 } from '../utils'\nimport { AAC } from '../codec'\nexport class MP4Parser {\n  static findBox (data, names, start = 0) {\n    const ret = []\n    if (!data) return ret\n\n    let size = 0\n    let type = ''\n    let headerSize = 0\n    while (data.length > 7) {\n      size = readBig32(data)\n      type = String.fromCharCode.apply(null, data.subarray(4, 8))\n      headerSize = 8\n      if (size === 1) {\n        size = readBig64(data, 8)\n        headerSize += 8\n      } else if (!size) {\n        size = data.length\n      }\n      if (!names[0] || type === names[0]) {\n        const subData = data.subarray(0, size)\n        if (names.length < 2) {\n          ret.push({\n            start,\n            size,\n            headerSize,\n            type,\n            data: subData\n          })\n        } else {\n          return MP4Parser.findBox(subData.subarray(headerSize), names.slice(1), start + headerSize)\n        }\n      }\n\n      start += size\n      data = data.subarray(size)\n    }\n\n    return ret\n  }\n\n  static tfhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.trackId = readBig32(data)\n      let start = 4\n      const baseDataOffsetPresent = (ret.flags & 0xff) & 0x01\n      const sampleDescriptionIndexPresent = (ret.flags & 0xff) & 0x02\n      const defaultSampleDurationPresent = (ret.flags & 0xff) & 0x08\n      const defaultSampleSizePresent = (ret.flags & 0xff) & 0x10\n      const defaultSampleFlagsPresent = (ret.flags & 0xff) & 0x20\n\n      if (baseDataOffsetPresent) {\n        start += 4 // truncate top 4 bytes\n        ret.baseDataOffset = readBig32(data, start)\n        start += 4\n      }\n      if (sampleDescriptionIndexPresent) {\n        ret.sampleDescriptionIndex = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleDurationPresent) {\n        ret.defaultSampleDuration = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleSizePresent) {\n        ret.defaultSampleSize = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleFlagsPresent) {\n        ret.defaultSampleFlags = readBig32(data, start)\n      }\n    })\n  }\n\n  static sidx (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      ret.reference_ID = readBig32(data, start)// stream.readUint32();\n      start += 4\n      ret.timescale = readBig32(data, start)\n      start += 4\n      if (ret.version === 0) {\n        ret.earliest_presentation_time = readBig32(data, start)\n        start += 4\n        ret.first_offset = readBig32(data, start)\n        start += 4\n      } else {\n        ret.earliest_presentation_time = readBig64(data, start)\n        start += 8\n        ret.first_offset = readBig64(data, start)\n        start += 8\n      }\n      start += 2\n      ret.references = []\n      const count = readBig16(data, start)\n      start += 2\n      for (let i = 0; i < count; i++) {\n        const ref = {}\n        ret.references.push(ref)\n        let tmp32 = readBig32(data, start)\n        start += 4\n        ref.reference_type = (tmp32 >> 31) & 0x1\n        ref.referenced_size = tmp32 & 0x7FFFFFFF\n        ref.subsegment_duration = readBig32(data, start)\n        start += 4\n        tmp32 = readBig32(data, start)\n        start += 4\n        ref.starts_with_SAP = (tmp32 >> 31) & 0x1\n        ref.SAP_type = (tmp32 >> 28) & 0x7\n        ref.SAP_delta_time = tmp32 & 0xFFFFFFF\n      }\n    })\n  }\n\n  static moov (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mvhd = MP4Parser.mvhd(MP4Parser.findBox(data, ['mvhd'], start)[0])\n      ret.trak = MP4Parser.findBox(data, ['trak'], start).map(trak => MP4Parser.trak(trak))\n      ret.pssh = MP4Parser.pssh(MP4Parser.findBox(data, ['pssh'], start)[0])\n    })\n  }\n\n  static mvhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.timescale = readBig32(data, 16)\n        ret.duration = readBig64(data, 20)\n        start += 28\n      } else {\n        ret.timescale = readBig32(data, 8)\n        ret.duration = readBig32(data, 12)\n        start += 16\n      }\n      ret.nextTrackId = readBig32(data, start + 76)\n    })\n  }\n\n  static trak (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tkhd = MP4Parser.tkhd(MP4Parser.findBox(data, ['tkhd'], start)[0])\n      ret.mdia = MP4Parser.mdia(MP4Parser.findBox(data, ['mdia'], start)[0])\n    })\n  }\n\n  static tkhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.trackId = readBig32(data, 16)\n        ret.duration = readBig64(data, 24)\n        start += 32\n      } else {\n        ret.trackId = readBig32(data, 8)\n        ret.duration = readBig32(data, 16)\n        start += 20\n      }\n      ret.width = readBig32(data, start + 52)\n      ret.height = readBig32(data, start + 56)\n    })\n  }\n\n  static mdia (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mdhd = MP4Parser.mdhd(MP4Parser.findBox(data, ['mdhd'], start)[0])\n      ret.hdlr = MP4Parser.hdlr(MP4Parser.findBox(data, ['hdlr'], start)[0])\n      ret.minf = MP4Parser.minf(MP4Parser.findBox(data, ['minf'], start)[0])\n    })\n  }\n\n  static mdhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.timescale = readBig32(data, 16)\n        ret.duration = readBig64(data, 20)\n        start += 28\n      } else {\n        ret.timescale = readBig32(data, 8)\n        ret.duration = readBig32(data, 12)\n        start += 16\n      }\n      const lang = readBig16(data, start)\n      ret.language = String.fromCharCode(((lang >> 10) & 0x1F) + 0x60, ((lang >> 5) & 0x1F) + 0x60, (lang & 0x1F) + 0x60)\n    })\n  }\n\n  static hdlr (box) {\n    return parseBox(box, true, (ret, data) => {\n      if (ret.version === 0) {\n        ret.handlerType = String.fromCharCode.apply(null, data.subarray(4, 8))\n      }\n    })\n  }\n\n  static minf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.vmhd = MP4Parser.vmhd(MP4Parser.findBox(data, ['vmhd'], start)[0])\n      ret.smhd = MP4Parser.smhd(MP4Parser.findBox(data, ['smhd'], start)[0])\n      ret.stbl = MP4Parser.stbl(MP4Parser.findBox(data, ['stbl'], start)[0])\n    })\n  }\n\n  static vmhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.graphicsmode = readBig16(data)\n      ret.opcolor = [readBig16(data, 2), readBig16(data, 4), readBig16(data, 6)]\n    })\n  }\n\n  static smhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.balance = readBig16(data)\n    })\n  }\n\n  static stbl (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.stsd = MP4Parser.stsd(MP4Parser.findBox(data, ['stsd'], start)[0])\n      ret.stts = MP4Parser.stts(MP4Parser.findBox(data, ['stts'], start)[0])\n      ret.ctts = MP4Parser.ctts(MP4Parser.findBox(data, ['ctts'], start)[0])\n      ret.stsc = MP4Parser.stsc(MP4Parser.findBox(data, ['stsc'], start)[0])\n      ret.stsz = MP4Parser.stsz(MP4Parser.findBox(data, ['stsz'], start)[0])\n      ret.stco = MP4Parser.stco(MP4Parser.findBox(data, ['stco'], start)[0])\n      if (!ret.stco) {\n        ret.co64 = MP4Parser.co64(MP4Parser.findBox(data, ['co64'], start)[0])\n        ret.stco = ret.co64\n      }\n      const default_IV_size = ret.stsd.entries[0]?.sinf?.schi?.tenc.default_IV_size\n      ret.stss = MP4Parser.stss(MP4Parser.findBox(data, ['stss'], start)[0])\n      ret.senc = MP4Parser.senc(MP4Parser.findBox(data, ['senc'], start)[0], default_IV_size)\n    })\n  }\n\n  static senc (box, iv = 8) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      const sampleCount = readBig32(data, start)\n      start += 4\n      ret.samples = []\n      for (let i = 0; i < sampleCount; i++) {\n        const sample = {}\n        sample.InitializationVector = []\n        for (let j = 0; j < iv; j++){\n          sample.InitializationVector[j] = data[start + j]\n        }\n        start += iv\n        if (ret.flags & 0x2) {\n          sample.subsamples = []\n          const subsampleCount = readBig16(data, start)\n          start += 2\n          for (let j = 0; j < subsampleCount; j++) {\n            const subsample = {}\n            subsample.BytesOfClearData = readBig16(data, start)\n            start += 2\n            subsample.BytesOfProtectedData = readBig32(data, start)\n            start += 4\n            sample.subsamples.push(subsample)\n          }\n        }\n        ret.samples.push(sample)\n      }\n    })\n  }\n\n  static pssh (box) {\n    return parseBox(box, true, (ret, data) => {\n      const keyIds = []\n      const systemId = []\n      let start = 0\n      for (let i = 0; i < 16; i++) {\n        systemId.push(toHex(data[start + i]))\n      }\n      start += 16\n      if (ret.version > 0) {\n        const numKeyIds = readBig32(data, start)\n        start += 4\n        for (let i = 0; i < ('' + numKeyIds).length; i++) {\n          for (let j = 0; j < 16; j++) {\n            const keyId = data[start]\n            start += 1\n            keyIds.push(toHex(keyId))\n          }\n        }\n      }\n      const dataSize = readBig32(data, start)\n      ret.data_size = dataSize\n      start += 4\n      ret.kid = keyIds\n      ret.system_id = systemId\n      ret.buffer = data\n    })\n  }\n\n  static stsd (box) {\n    return parseBox(box, true, (ret, data, start) => {\n      ret.entryCount = readBig32(data)\n      ret.entries = MP4Parser.findBox(data.subarray(4), [], start + 4).map(b => {\n        switch (b.type) {\n          case 'avc1':\n          case 'avc2':\n          case 'avc3':\n          case 'avc4':\n            return MP4Parser.avc1(b)\n          case 'hvc1':\n          case 'hev1':\n            return MP4Parser.hvc1(b)\n          case 'mp4a':\n            return MP4Parser.mp4a(b)\n          case 'alaw':\n          case 'ulaw':\n            return MP4Parser.alaw(b)\n          case 'enca':\n            // sinf->schi->tenc\n            return parseBox(b, false, (ret, data, start) => {\n              ret.channelCount = readBig16(data, 16)\n              ret.samplesize = readBig16(data, 18)\n              ret.sampleRate = (readBig32(data, 24) / (1 << 16))\n              data = data.subarray(28)\n              ret.sinf = MP4Parser.sinf(MP4Parser.findBox(data, ['sinf'], start)[0])\n              ret.esds = MP4Parser.esds(MP4Parser.findBox(data, ['esds'], start)[0])\n            })\n          case 'encv':\n            // sinf->schi->tenc\n            return parseBox(b, false, (ret, data, start) => {\n              ret.width = readBig16(data, 24)\n              ret.height = readBig16(data, 26)\n              ret.horizresolution = readBig32(data, 28)\n              ret.vertresolution = readBig32(data, 32)\n              data = data.subarray(78)\n              ret.sinf = MP4Parser.sinf(MP4Parser.findBox(data, ['sinf'], start)[0])\n              ret.avcC = MP4Parser.avcC(MP4Parser.findBox(data, ['avcC'], start)[0])\n              ret.hvcC = MP4Parser.hvcC(MP4Parser.findBox(data, ['hvcC'], start)[0])\n              ret.pasp = MP4Parser.pasp(MP4Parser.findBox(data, ['pasp'], start)[0])\n            })\n          default:\n        }\n      }).filter(Boolean)\n    })\n  }\n\n  static tenc (box) {\n    return parseBox(box, false, (ret, data) => {\n      let start = 6\n      ret.default_IsEncrypted = data[start]\n      start += 1\n      ret.default_IV_size = data[start]\n      start += 1\n      ret.default_KID = []\n      for (let i = 0; i < 16; i++) {\n        ret.default_KID.push(toHex(data[start]))\n        start += 1\n      }\n    })\n  }\n\n  static schi (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tenc = MP4Parser.tenc(MP4Parser.findBox(data, ['tenc'], start)[0])\n    })\n  }\n\n  static sinf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.schi = MP4Parser.schi(MP4Parser.findBox(data, ['schi'], start)[0])\n      ret.frma = MP4Parser.frma(MP4Parser.findBox(data, ['frma'], start)[0])\n    })\n  }\n\n  static frma (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data_format = ''\n      for (let i = 0; i < 4; i++) {\n        ret.data_format += String.fromCharCode(data[i])\n      }\n    })\n  }\n\n  static avc1 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.avcC = MP4Parser.avcC(MP4Parser.findBox(bodyData, ['avcC'], start)[0])\n      ret.pasp = MP4Parser.pasp(MP4Parser.findBox(bodyData, ['pasp'], start)[0])\n    })\n  }\n\n  static avcC (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.configurationVersion = data[0]\n      ret.AVCProfileIndication = data[1]\n      ret.profileCompatibility = data[2]\n      ret.AVCLevelIndication = data[3]\n      ret.codec = getAvcCodec([data[1], data[2], data[3]])\n      ret.lengthSizeMinusOne = data[4] & 0x3\n      ret.spsLength = data[5] & 0x1F\n      ret.sps = []\n      let start = 6\n      for (let i = 0; i < ret.spsLength; i++) {\n        const size = readBig16(data, start)\n        start += 2\n        ret.sps.push(data.subarray(start, start + size))\n        // ret.spsInfo = SpsParser.parseSPS(ret.sps[i])\n        // ret.pixelRatio = ret.spsInfo.par_ratio\n        start += size\n      }\n      ret.ppsLength = data[start]\n      start += 1\n      ret.pps = []\n      for (let i = 0; i < ret.ppsLength; i++) {\n        const size = readBig16(data, start)\n        start += 2\n        ret.pps.push(data.subarray(start, start += size))\n        start += size\n      }\n    })\n  }\n\n  static hvc1 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.hvcC = MP4Parser.hvcC(MP4Parser.findBox(bodyData, ['hvcC'], start)[0])\n      ret.pasp = MP4Parser.pasp(MP4Parser.findBox(bodyData, ['pasp'], start)[0])\n    })\n  }\n\n  static hvcC (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data = box.data\n      ret.codec = 'hev1.1.6.L93.B0'\n      ret.configurationVersion = data[0]\n      const tmp = data[1]\n      ret.generalProfileSpace = tmp >> 6\n      ret.generalTierFlag = (tmp & 0x20) >> 5\n      ret.generalProfileIdc = tmp & 0x1F\n      ret.generalProfileCompatibility = readBig32(data, 2)\n      ret.generalConstraintIndicatorFlags = data.subarray(6, 12)\n      ret.generalLevelIdc = data[12]\n      ret.avgFrameRate = readBig16(data, 19)\n      ret.numOfArrays = data[22]\n      ret.vps = []\n      ret.sps = []\n      ret.pps = []\n      let start = 23\n      let type = 0\n      let numNalus = 0\n      let size = 0\n      for (let i = 0; i < ret.numOfArrays; i++) {\n        type = data[start] & 0x3F\n        numNalus = readBig16(data, start + 1)\n        start += 3\n        const nalus = []\n        for (let j = 0; j < numNalus; j++) {\n          size = readBig16(data, start)\n          start += 2\n          nalus.push(data.subarray(start, start + size))\n          start += size\n        }\n\n        if (type === 32) {\n          ret.vps.push(...nalus)\n        } else if (type === 33) {\n          ret.sps.push(...nalus)\n        } else if (type === 34) {\n          ret.pps.push(...nalus)\n        }\n      }\n    })\n  }\n\n  static pasp (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.hSpacing = readBig32(data)\n      ret.vSpacing = readBig32(data, 4)\n    })\n  }\n\n  static mp4a (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseAudioSampleEntry(ret, data)\n      ret.esds = MP4Parser.esds(MP4Parser.findBox(data.subarray(bodyStart), ['esds'], start + bodyStart)[0])\n    })\n  }\n\n  static esds (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.codec = 'mp4a.'\n      let start = 0\n      let byteRead = 0\n      let size = 0\n      let tag = 0\n      while (data.length) {\n        start = 0\n        tag = data[start]\n        byteRead = data[start + 1]\n        start += 2\n        while (byteRead & 0x80) {\n          size = (byteRead & 0x7F) << 7\n          byteRead = data[start]\n          start += 1\n        }\n        size += byteRead & 0x7F\n        if (tag === 3) {\n          data = data.subarray(start + 3)\n        } else if (tag === 4) {\n          ret.codec += (data[start].toString(16) + '.').padStart(3, '0')\n          data = data.subarray(start + 13)\n        } else if (tag === 5) {\n          const config = ret.config = data.subarray(start, start + size)\n          let objectType = (config[0] & 0xF8) >> 3\n          if (objectType === 31 && config.length >= 2) {\n            objectType = 32 + ((config[0] & 0x7) << 3) + ((config[1] & 0xE0) >> 5)\n          }\n          ret.objectType = objectType\n          ret.codec += objectType.toString(16)\n          if (ret.codec[ret.codec.length - 1] === '.') {\n            ret.codec = ret.codec.substring(0, ret.codec.length - 1)\n          }\n          return\n        } else {\n          if (ret.codec[ret.codec.length - 1] === '.') {\n            ret.codec = ret.codec.substring(0, ret.codec.length - 1)\n          }\n          return\n        }\n      }\n    })\n  }\n\n  static alaw (box) {\n    return parseBox(box, false, (ret, data) => {\n      parseAudioSampleEntry(ret, data)\n    })\n  }\n\n  static stts (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push({\n          count: readBig32(data, start),\n          delta: readBig32(data, start + 4)\n        })\n        start += 8\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static ctts (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      if (ret.version === 1) {\n        for (let i = 0; i < entryCount; i++) {\n          entries.push({\n            count: readBig32(data, start),\n            offset: readBig32(data, start + 4)\n          })\n          start += 8\n        }\n      } else {\n        for (let i = 0; i < entryCount; i++) {\n          entries.push({\n            count: readBig32(data, start),\n            offset: -(~readBig32(data, start + 4) + 1)\n          })\n          start += 8\n        }\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stsc (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push({\n          firstChunk: readBig32(data, start),\n          samplesPerChunk: readBig32(data, start + 4),\n          sampleDescriptionIndex: readBig32(data, start + 8)\n        })\n        start += 12\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stsz (box) {\n    return parseBox(box, true, (ret, data) => {\n      const sampleSize = readBig32(data)\n      const sampleCount = readBig32(data, 4)\n      const entrySizes = []\n      if (!sampleSize) {\n        let start = 8\n        for (let i = 0; i < sampleCount; i++) {\n          entrySizes.push(readBig32(data, start))\n          start += 4\n        }\n      }\n      ret.sampleSize = sampleSize\n      ret.sampleCount = sampleCount\n      ret.entrySizes = entrySizes\n    })\n  }\n\n  static stco (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig32(data, start))\n        start += 4\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static co64 (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig64(data, start))\n        start += 8\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stss (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig32(data, start))\n        start += 4\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static moof (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mfhd = MP4Parser.mfhd(MP4Parser.findBox(data, ['mfhd'], start)[0])\n      ret.traf = MP4Parser.findBox(data, ['traf'], start).map(t => MP4Parser.traf(t))\n    })\n  }\n\n  static mfhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.sequenceNumber = readBig32(data)\n    })\n  }\n\n  static traf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tfhd = MP4Parser.tfhd(MP4Parser.findBox(data, ['tfhd'], start)[0])\n      ret.tfdt = MP4Parser.tfdt(MP4Parser.findBox(data, ['tfdt'], start)[0])\n      ret.trun = MP4Parser.trun(MP4Parser.findBox(data, ['trun'], start)[0])\n    })\n  }\n\n  static trun (box) {\n    return parseBox(box, true, (ret, data) => {\n      const { version, flags } = ret\n      const dataLen = data.length\n      const sampleCount = ret.sampleCount = readBig32(data)\n      let offset = 4\n      if (dataLen > offset && flags & 1) {\n        ret.dataOffset = -(~readBig32(data, offset) + 1)\n        offset += 4\n      }\n      if (dataLen > offset && flags & 4) {\n        ret.firstSampleFlags = readBig32(data, offset)\n        offset += 4\n      }\n      ret.samples = []\n      if (dataLen > offset) {\n        let sample\n        for (let i = 0; i < sampleCount; i++) {\n          sample = {}\n          if (flags & 0x100) {\n            sample.duration = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x200) {\n            sample.size = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x400) {\n            sample.flags = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x800) {\n            if (version) {\n              sample.cts = -(~readBig32(data, offset + 4) + 1)\n            } else {\n              sample.cts = readBig32(data, offset)\n            }\n            offset += 4\n          }\n          ret.samples.push(sample)\n        }\n      }\n    })\n  }\n\n  static tfdt (box) {\n    return parseBox(box, true, (ret, data) => {\n      if (ret.version === 1) {\n        ret.baseMediaDecodeTime = readBig64(data)\n      } else {\n        ret.baseMediaDecodeTime = readBig32(data)\n      }\n    })\n  }\n\n  static probe (data) {\n    return !!MP4Parser.findBox(data, ['ftyp'])\n  }\n\n  static parseSampleFlags (flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: (flags[2] << 8) | flags[3]\n    }\n  }\n\n  static moovToTrack (moov, videoTrack, audioTrack) {\n    const tracks = moov.trak\n    if (!tracks || !tracks.length) return\n    const vTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'vide')\n    const aTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'soun')\n    if (vTrack && videoTrack) {\n      const v = videoTrack\n      const _vTrackId = vTrack.tkhd?.trackId\n      if (_vTrackId !== null && _vTrackId !== undefined) v.id = vTrack.tkhd.trackId\n      v.tkhdDuration = vTrack.tkhd.duration\n      v.mvhdDurtion = moov.mvhd.duration\n      v.mvhdTimecale = moov.mvhd.timescale\n      v.timescale = v.formatTimescale = vTrack.mdia.mdhd.timescale\n      v.duration = vTrack.mdia.mdhd.duration || (v.mvhdDurtion / v.mvhdTimecale * v.timescale)\n      const e1 = vTrack.mdia.minf.stbl.stsd.entries[0]\n      v.width = e1.width\n      v.height = e1.height\n      if (e1.pasp) {\n        v.sarRatio = [e1.pasp.hSpacing, e1.pasp.vSpacing]\n      }\n      if (e1.hvcC) {\n        v.codecType = VideoCodecType.HEVC\n        v.codec = e1.hvcC.codec\n        v.vps = e1.hvcC.vps\n        v.sps = e1.hvcC.sps\n        v.pps = e1.hvcC.pps\n        v.hvcC = e1.hvcC.data\n      } else if (e1.avcC) {\n        v.codec = e1.avcC.codec\n        v.sps = e1.avcC.sps\n        v.pps = e1.avcC.pps\n      } else {\n        throw new Error('unknown video stsd entry')\n      }\n      v.present = true\n      v.ext = {}\n      v.ext.stss = vTrack.mdia?.minf?.stbl?.stss\n      v.ext.ctts = vTrack.mdia?.minf?.stbl?.ctts\n\n      if (e1 && e1.type === 'encv') {\n        v.isVideoEncryption = true\n        e1.default_KID = e1.sinf?.schi?.tenc.default_KID\n        e1.default_IsEncrypted = e1.sinf?.schi?.tenc.default_IsEncrypted\n        e1.default_IV_size = e1.sinf?.schi?.tenc.default_IV_size\n        v.videoSenc = vTrack.mdia.minf.stbl.senc && vTrack.mdia.minf.stbl.senc.samples\n        e1.data_format = e1.sinf?.frma?.data_format\n        v.useEME = moov.useEME\n        v.kidValue = moov.kidValue\n        v.pssh = moov.pssh\n        v.encv = e1\n      }\n    }\n\n    if (aTrack && audioTrack) {\n      const a = audioTrack\n      const _aTrackId = aTrack.tkhd?.trackId\n      if (_aTrackId !== null && _aTrackId !== undefined) a.id = aTrack.tkhd.trackId\n      a.tkhdDuration = aTrack.tkhd.duration\n      a.mvhdDurtion = moov.mvhd.duration\n      a.mvhdTimecale = moov.mvhd.timescale\n      a.timescale = a.formatTimescale = aTrack.mdia.mdhd.timescale\n      a.duration = aTrack.mdia.mdhd.duration || (a.mvhdDurtion / a.mvhdTimecale * a.timescale)\n      const e1 = aTrack.mdia.minf.stbl.stsd.entries[0]\n      a.sampleSize = e1.sampleSize\n      a.sampleRate = e1.sampleRate\n      a.channelCount = e1.channelCount\n      a.present = true\n\n      switch (e1.type) {\n        case 'alaw':\n          a.codecType = a.codec = AudioCodecType.G711PCMA\n          a.sampleRate = 8000\n          break\n        case 'ulaw':\n          a.codecType = a.codec = AudioCodecType.G711PCMU\n          a.sampleRate = 8000\n          break\n        default:\n          a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale)\n          a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate)\n          a.objectType = e1.esds?.objectType || 2\n          if (e1.esds) a.config = Array.from(e1.esds.config)\n          a.codec = e1.esds?.codec || 'mp4a.40.2'\n          break\n      }\n      a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale)\n      a.objectType = e1.esds?.objectType || 2\n      if (e1.esds) {\n        if (e1.esds.config) {\n          a.config = Array.from(e1.esds.config)\n        } else {\n          console.warn('esds config is null')\n        }\n      }\n      a.codec = e1.esds?.codec || 'mp4a.40.2'\n      a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate)\n      a.ext = {}\n      a.ext.stss = aTrack.mdia?.minf?.stbl?.stss\n      a.ext.ctts = aTrack.mdia?.minf?.stbl?.ctts\n      a.present = true\n      if (e1 && e1.type === 'enca') {\n        a.isAudioEncryption = true\n        e1.data_format = e1.sinf?.frma?.data_format\n        e1.default_KID = e1.sinf?.schi?.tenc.default_KID\n        e1.default_IsEncrypted = e1.sinf?.schi?.tenc.default_IsEncrypted\n        e1.default_IV_size = e1.sinf?.schi?.tenc.default_IV_size\n        a.audioSenc = aTrack.mdia.minf.stbl.senc && aTrack.mdia.minf.stbl.senc.samples\n        a.useEME = moov.useEME\n        a.kidValue = moov.kidValue\n        a.enca = e1\n      }\n    }\n\n    audioTrack && (audioTrack.isVideoEncryption = videoTrack ? videoTrack.isVideoEncryption : false)\n    videoTrack && (videoTrack.isAudioEncryption = audioTrack ? audioTrack.isAudioEncryption : false)\n\n    if (videoTrack?.encv || audioTrack?.enca) {\n      const vkid = videoTrack?.encv?.default_KID\n      const akid = audioTrack?.enca?.default_KID\n      const kid = (vkid || akid) ? (vkid || akid).join('') : null\n      videoTrack && (videoTrack.kid = kid)\n      audioTrack && (audioTrack.kid = kid)\n    }\n\n    videoTrack && (videoTrack.flags = 0xf01)\n    audioTrack && (audioTrack.flags = 0x701)\n\n    return {\n      videoTrack,\n      audioTrack\n    }\n  }\n\n  static evaluateDefaultDuration (videoTrack, audioTrack, videoSampleCount) {\n    const audioSampleCount = audioTrack?.samples?.length\n\n    // audio\n    if (!audioSampleCount) return 1024\n\n    const segmentDuration = 1024 * audioSampleCount / audioTrack.timescale\n\n    return segmentDuration * videoTrack.timescale / videoSampleCount\n  }\n\n  static moofToSamples (moof, videoTrack, audioTrack) {\n    const ret = {}\n\n    if (moof.mfhd) {\n      if (videoTrack) videoTrack.sequenceNumber = moof.mfhd.sequenceNumber\n      if (audioTrack) audioTrack.sequenceNumber = moof.mfhd.sequenceNumber\n    }\n\n    moof.traf.forEach(({ tfhd, tfdt, trun }) => {\n      if (!tfhd || !trun) return\n      if (tfdt) {\n        if (videoTrack && videoTrack.id === tfhd.trackId) videoTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime\n        if (audioTrack && audioTrack.id === tfhd.trackId) audioTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime\n      }\n      const defaultSize = tfhd.defaultSampleSize || 0\n      const defaultDuration = tfhd.defaultSampleDuration || MP4Parser.evaluateDefaultDuration(videoTrack, audioTrack, trun.samples.length || trun.sampleCount)\n      let offset = trun.dataOffset || 0\n      let dts = 0\n      let gopId = -1\n      if (!trun.samples.length && trun.sampleCount) {\n        ret[tfhd.trackId] = []\n        for (let i = 0; i < trun.sampleCount; i++) {\n          ret[tfhd.trackId].push({\n            offset,\n            dts,\n            duration: defaultDuration,\n            size: defaultSize\n          })\n          dts += defaultDuration\n          offset += defaultSize\n        }\n      } else {\n        ret[tfhd.trackId] = trun.samples.map((s, index) => {\n          s = {\n            offset,\n            dts,\n            pts: dts + (s.cts || 0),\n            duration: s.duration || defaultDuration,\n            size: s.size || defaultSize,\n            gopId,\n            keyframe: index === 0 || ((s.flags !== null && s.flags !== undefined) && ((s.flags & 65536) >>> 0) !== 65536)\n          }\n          if (s.keyframe) {\n            gopId++\n            s.gopId = gopId\n          }\n          dts += s.duration\n          offset += s.size\n          return s\n        })\n      }\n    })\n\n    return ret\n  }\n\n  static moovToSamples (moov) {\n    const tracks = moov.trak\n    if (!tracks || !tracks.length) return\n    const vTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'vide')\n    const aTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'soun')\n    if (!vTrack && !aTrack) return\n    let videoSamples\n    let audioSamples\n    if (vTrack) {\n      const videoStbl = vTrack.mdia?.minf?.stbl\n      if (!videoStbl) return\n      const { stts, stsc, stsz, stco, stss, ctts } = videoStbl\n      if (!stts || !stsc || !stsz || !stco || !stss) return\n      videoSamples = getSamples(stts, stsc, stsz, stco, ctts, stss)\n    }\n    if (aTrack) {\n      const audioStbl = aTrack.mdia?.minf?.stbl\n      if (!audioStbl) return\n      const timescale = aTrack.mdia.mdhd?.timescale\n      const { stts, stsc, stsz, stco } = audioStbl\n      if (!timescale || !stts || !stsc || !stsz || !stco) return\n      audioSamples = getSamples(stts, stsc, stsz, stco)\n    }\n\n    return {\n      videoSamples,\n      audioSamples\n    }\n  }\n}\n\nfunction getSamples (stts, stsc, stsz, stco, ctts, stss) {\n  const samples = []\n  const cttsEntries = ctts?.entries\n  const stscEntries = stsc.entries\n  const stcoEntries = stco.entries\n  const stszEntrySizes = stsz.entrySizes\n  const stssEntries = stss?.entries\n  let keyframeMap\n  if (stssEntries) {\n    keyframeMap = {}\n    stssEntries.forEach(x => { keyframeMap[x - 1] = true })\n  }\n  let cttsArr\n  if (cttsEntries) {\n    cttsArr = []\n    cttsEntries.forEach(({ count, offset }) => {\n      for (let i = 0; i < count; i++) {\n        cttsArr.push(offset)\n      }\n    })\n  }\n\n  let sample\n  let gopId = -1\n  let dts = 0\n  let pos = 0\n  let chunkIndex = 0\n  let chunkRunIndex = 0\n  let offsetInChunk = 0\n  let lastSampleInChunk = stscEntries[0].samplesPerChunk\n  let lastChunkInRun = stscEntries[1] ? stscEntries[1].firstChunk - 1 : Infinity\n  stts.entries.forEach(({ count, delta }) => {\n    for (let i = 0; i < count; i++) {\n      sample = {\n        dts,\n        duration: delta,\n        size: stszEntrySizes[pos] || stsz.sampleSize,\n        offset: stcoEntries[chunkIndex] + offsetInChunk,\n        index: pos\n      }\n      if (stssEntries) {\n        sample.keyframe = keyframeMap[pos]\n        if (sample.keyframe) {\n          gopId++\n        }\n        sample.gopId = gopId\n      }\n      // sample.timeOffset = 0\n      if (cttsArr && pos < cttsArr.length) {\n        sample.pts = sample.dts + cttsArr[pos]\n        // sample.timeOffset = cttsArr[pos]\n        // if (pos === 0) {\n        //   sample.pts = sample.dts\n        //   sample.timeOffset = 0\n        // }\n      }\n      samples.push(sample)\n      dts += delta\n      pos++\n\n      if (pos < lastSampleInChunk) {\n        offsetInChunk += sample.size\n      } else {\n        chunkIndex++\n        offsetInChunk = 0\n        if (chunkIndex >= lastChunkInRun) {\n          chunkRunIndex++\n          lastChunkInRun = stscEntries[chunkRunIndex + 1] ? stscEntries[chunkRunIndex + 1].firstChunk - 1 : Infinity\n        }\n        lastSampleInChunk += stscEntries[chunkRunIndex].samplesPerChunk\n      }\n    }\n  })\n\n  return samples\n}\n\nfunction parseVisualSampleEntry (ret, data) {\n  ret.dataReferenceIndex = readBig16(data, 6)\n  ret.width = readBig16(data, 24)\n  ret.height = readBig16(data, 26)\n  ret.horizresolution = readBig32(data, 28)\n  ret.vertresolution = readBig32(data, 32)\n  ret.frameCount = readBig16(data, 40)\n  ret.depth = readBig16(data, 74)\n  return 78\n}\n\nfunction parseAudioSampleEntry (ret, data) {\n  ret.dataReferenceIndex = readBig16(data, 6)\n  ret.channelCount = readBig16(data, 16)\n  ret.sampleSize = readBig16(data, 18)\n  ret.sampleRate = readBig32(data, 24) / (1 << 16)\n  return 28\n}\n\nfunction parseBox (box, isFullBox, parse) {\n  if (!box) return\n  if (box.size !== box.data.length) throw new Error(`box ${box.type} size !== data.length`)\n  const ret = {\n    start: box.start,\n    size: box.size,\n    headerSize: box.headerSize,\n    type: box.type\n  }\n  if (isFullBox) {\n    ret.version = box.data[box.headerSize]\n    ret.flags = readBig24(box.data, box.headerSize + 1)\n    ret.headerSize += 4\n  }\n  parse(ret, box.data.subarray(ret.headerSize), ret.start + ret.headerSize)\n  return ret\n}\n\nconst padStart = function (str, length, pad) {\n  const charstr = String(pad)\n  const len = length >> 0\n  let maxlen = Math.ceil(len / charstr.length)\n  const chars = []\n  const r = String(str)\n  while (maxlen--) {\n    chars.push(charstr)\n  }\n  return chars.join('').substring(0, len - r.length) + r\n}\n\nconst toHex = function (...value) {\n  const hex = []\n  value.forEach(item => {\n    hex.push(padStart(Number(item).toString(16), 2, 0))\n  })\n  return hex[0]\n}\n","import { VideoTrack, AudioTrack, MetadataTrack, VideoSample, AudioSample } from '../model'\nimport { readBig32 } from '../utils'\nimport { MP4Parser } from './mp4-parser'\n\nexport class FMP4Demuxer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n  }\n\n  demux (videoData, audioData) {\n    const { videoTrack, audioTrack } = this\n    const videoExist = videoTrack.exist()\n    const audioExist = audioTrack.exist()\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    if (audioData) {\n      if (!audioExist) {\n        const moovBox = MP4Parser.findBox(audioData, ['moov'])[0]\n        if (!moovBox) throw new Error('cannot found moov box')\n        MP4Parser.moovToTrack(MP4Parser.moov(moovBox), null, audioTrack)\n      }\n      const moofBox = MP4Parser.findBox(audioData, ['moof'])[0]\n      if (moofBox) {\n        const samples = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), null, audioTrack)[audioTrack.id]\n        const baseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        if (samples) {\n          const baseOffset = moofBox.start\n          samples.map(x => {\n            x.offset += baseOffset\n            const sampleData = audioData.subarray(x.offset, x.offset + x.size)\n            audioTrack.samples.push(new AudioSample(x.dts + baseMediaDecodeTime, sampleData, x.duration))\n          })\n        }\n      }\n    }\n\n    if (videoData) {\n      if (!videoExist && !audioExist) {\n        const moovBox = MP4Parser.findBox(videoData, ['moov'])[0]\n        if (!moovBox) throw new Error('cannot found moov box')\n        MP4Parser.moovToTrack(MP4Parser.moov(moovBox), videoTrack, audioTrack)\n      }\n      const moofBox = MP4Parser.findBox(videoData, ['moof'])[0]\n      if (moofBox) {\n        const tracks = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), videoTrack, audioTrack)\n        const videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime\n        const audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        const baseOffset = moofBox.start\n        let nalSize\n        Object.keys(tracks).forEach(k => {\n          // eslint-disable-next-line eqeqeq\n          if (videoTrack.id == k) {\n            tracks[k].map(x => {\n              x.offset += baseOffset\n              const sample = new VideoSample((x.pts || x.dts) + videoBaseMediaDecodeTime, x.dts + videoBaseMediaDecodeTime)\n              sample.duration = x.duration\n              sample.gopId = x.gopId\n              if (x.keyframe) sample.setToKeyframe()\n              const sampleData = videoData.subarray(x.offset, x.offset + x.size)\n              sample.data = sampleData\n              let start = 0\n              const len = sampleData.length - 1\n              while (start < len) {\n                nalSize = readBig32(sampleData, start)\n                start += 4\n                sample.units.push(sampleData.subarray(start, start + nalSize))\n                start += nalSize\n              }\n              videoTrack.samples.push(sample)\n            })\n            // eslint-disable-next-line eqeqeq\n          } else if (audioTrack.id == k) {\n            tracks[k].map(x => {\n              x.offset += baseOffset\n              const sampleData = videoData.subarray(x.offset, x.offset + x.size)\n              audioTrack.samples.push(new AudioSample(x.dts + audioBaseMediaDecodeTime, sampleData, x.duration))\n            })\n          }\n        })\n      }\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  reset () {\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n    this.metadataTrack.reset()\n  }\n\n  static probe (data) {\n    return MP4Parser.probe(data)\n  }\n}\n","\n// 改造为兼容IE11\nfunction Concat (ResultConstructor, ...arrays){\n  let totalLength = 0\n  arrays.forEach(function (arr){\n    totalLength += arr.length\n  })\n  const result = new ResultConstructor(totalLength)\n  let offset = 0\n  arrays.forEach(function (arr){\n    result.set(arr, offset)\n    offset += arr.length\n  })\n  return result\n}\n\nclass Buffer {\n  constructor () {\n    this.buffer = new Uint8Array(0)\n  }\n\n  write (...buffer) {\n    const self = this\n    buffer.forEach(item => {\n      if (item) {\n        self.buffer = Concat(Uint8Array, self.buffer, item)\n      } else {\n        window.console.warn(item)\n      }\n    })\n  }\n\n  static writeUint16 (value) {\n    return new Uint8Array([\n      (value >> 8) & 0xff,\n      value & 0xff\n    ])\n  }\n\n  static writeUint32 (value) {\n    return new Uint8Array([\n      value >> 24,\n      (value >> 16) & 0xff,\n      (value >> 8) & 0xff,\n      value & 0xff\n    ])\n  }\n}\n\nexport default Buffer\n","import { TrackType, VideoCodecType } from '../model'\nimport { concatUint8Array, parse /* hashVal */ } from '../utils'\nimport Buffer from './buffer'\n// import Crypto from './crypto/crypto'\nconst UINT32_MAX = 2 ** 32 - 1\n\nexport class MP4 {\n  static types = [\n    'avc1',\n    'avcC',\n    'hvc1',\n    'hvcC',\n    'dinf',\n    'dref',\n    'esds',\n    'ftyp',\n    'hdlr',\n    'mdat',\n    'mdhd',\n    'mdia',\n    'mfhd',\n    'minf',\n    'moof',\n    'moov',\n    'mp4a',\n    'mvex',\n    'mvhd',\n    'pasp',\n    'stbl',\n    'stco',\n    'stsc',\n    'stsd',\n    'stsz',\n    'stts',\n    'tfdt',\n    'tfhd',\n    'traf',\n    'trak',\n    'trex',\n    'tkhd',\n    'vmhd',\n    'smhd',\n    'ctts',\n    'stss',\n    'styp',\n    'pssh',\n    'sidx',\n    'sbgp',\n    'saiz',\n    'saio',\n    'senc',\n    'trun',\n    'encv',\n    'enca',\n    'sinf',\n    'btrt',\n    'frma',\n    'tenc',\n    'schm',\n    'schi',\n    'mehd',\n    'fiel',\n    'sdtp'\n  ].reduce((p, c) => {\n    p[c] = [c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2), c.charCodeAt(3)]\n    return p\n  }, Object.create(null));\n\n  static HDLR_TYPES = {\n    video: new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61,\n      0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]),\n    audio: new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61,\n      0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ])\n  }\n\n  static FTYPAVC1 = MP4.box(MP4.types.ftyp, new Uint8Array([\n    105, 115, 111, 109, // isom\n    0, 0, 0, 1,\n    105, 115, 111, 109,\n    97, 118, 99, 49 // avc1\n  ]))\n\n  static FTYPHEV1 = MP4.box(MP4.types.ftyp, new Uint8Array([\n    105, 115, 111, 109, // isom\n    0, 0, 0, 1,\n    105, 115, 111, 109,\n    104, 101, 118, 49 // hev1\n  ]))\n\n  static DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version\n    0x00, 0x00, 0x01 // entry_flags\n  ])))\n\n  static VMHD = MP4.box(MP4.types.vmhd, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphics mode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // op color\n  ]))\n\n  static SMHD = MP4.box(MP4.types.smhd, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance\n    0x00, 0x00 // reserved\n  ]))\n\n  static StblTable = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ])\n\n  static STTS = MP4.box(MP4.types.stts, MP4.StblTable)\n\n  static STSC = MP4.box(MP4.types.stsc, MP4.StblTable)\n\n  static STSZ = MP4.box(MP4.types.stsz, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]))\n\n  static STCO = MP4.box(MP4.types.stco, MP4.StblTable)\n\n  static box (type, ...payload) {\n    payload = payload.filter(Boolean)\n    const size = 8 + payload.reduce((p, c) => (p + c.byteLength), 0)\n    const ret = new Uint8Array(size)\n    ret[0] = (size >> 24) & 0xff\n    ret[1] = (size >> 16) & 0xff\n    ret[2] = (size >> 8) & 0xff\n    ret[3] = size & 0xff\n    ret.set(type, 4)\n    let offset = 8\n    payload.forEach((data) => {\n      ret.set(data, offset)\n      offset += data.byteLength\n    })\n    return ret\n  }\n\n  static ftyp (tracks) {\n    const isHevc = tracks.find(t => t.type === TrackType.VIDEO && t.codecType === VideoCodecType.HEVC)\n    return isHevc ? MP4.FTYPHEV1 : MP4.FTYPAVC1\n  }\n\n  static initSegment (tracks) {\n    const ftyp = MP4.ftyp(tracks)\n    // console.log('[remux],ftyp ,len ', ftyp.byteLength, hashVal(ftyp.toString()))\n    const init = concatUint8Array(ftyp, MP4.moov(tracks))\n    // console.log('[remux],init ,len ', init.byteLength, hashVal(init.toString()))\n    return init\n  }\n\n  static pssh (data) {\n    // const buffer = new Buffer()\n    const content = new Uint8Array(\n      [\n        0x01, 0x00, 0x00, 0x00 // version\n      ].concat(\n        [\n          0x10, 0x77, 0xef, 0xec,\n          0xc0, 0xb2, 0x4d, 0x02,\n          0xac, 0xe3, 0x3c, 0x1e,\n          0x52, 0xe2, 0xfb, 0x4b\n        ],\n        [0x00, 0x00, 0x00, 0x01],\n        parse(data.kid),\n        [0x00, 0x00, 0x00, 0x00]\n      )\n    )\n    return MP4.box(MP4.types.pssh, content)\n  }\n\n  static moov (tracks) {\n    if (tracks[0].useEME && (tracks[0].encv || tracks[0].enca)) {\n      if (!tracks[0].pssh) {\n        tracks[0].pssh = {\n          kid: tracks[0].kid\n        }\n      }\n      const pssh = this.pssh(tracks[0].pssh)\n      // console.log('[remux],pssh,', hashVal(pssh.toString()))\n      return MP4.box(MP4.types.moov,\n        MP4.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale),\n        MP4.mvex(tracks),\n        ...tracks.map((t) => MP4.trak(t)),\n        pssh)\n    } else {\n      return MP4.box(MP4.types.moov,\n        MP4.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale),\n        ...tracks.map((t) => MP4.trak(t)),\n        MP4.mvex(tracks)\n      )\n    }\n  }\n\n  static mvhd (duration, timescale = 90000) {\n    const mvhd = MP4.box(MP4.types.mvhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time\n      (timescale >> 24) & 0xff, (timescale >> 16) & 0xff, (timescale >> 8) & 0xff, timescale & 0xff,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,\n      0x00, 0x01, 0x00, 0x00, // rate\n      0x01, 0x00, // volume\n      0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // todo 0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]))\n    // console.log('[remux],mvhd, len,', mvhd.byteLength, hashVal(mvhd.toString()))\n    return mvhd\n  }\n\n  static trak (track) {\n    const trak = MP4.box(\n      MP4.types.trak,\n      MP4.tkhd(track.id, track.tkhdDuration || 0, track.width, track.height),\n      MP4.mdia(track)\n    )\n    // console.log('[remux],trak, len,', trak.byteLength, track.id, hashVal(trak.toString()))\n    return trak\n  }\n\n  static tkhd (id, duration, width = 0, height = 0) {\n    const tkhd = MP4.box(MP4.types.tkhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x07, // flags、todo 0x07\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time todo\n      (id >> 24) & 0xff, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff,\n      0x00, 0x00, 0x00, 0x00,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff, // todo (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // /*0x00*/ alternate_group  //todo type === 'video' ? 0x01 : 0x00（第二个位置）\n      0x01, 0x00, // /* 0x01 */, 0x00, // non-audio track volume  //todo type === 'audio' ? 0x01 : 0x00（第一个位置）\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // matrix\n      (width >> 8) & 0xff, width & 0xff, 0x00, 0x00,\n      (height >> 8) & 0xff, height & 0xff, 0x00, 0x00\n    ]))\n    // console.log('[remux],tkhd, len,', tkhd.byteLength, hashVal(tkhd.toString()))\n    return tkhd\n  }\n\n  static mdia (track) {\n    const mdia = MP4.box(MP4.types.mdia, MP4.mdhd(track.duration, track.timescale), MP4.hdlr(track.type), MP4.minf(track))\n    // console.log('[remux],mdia, len,', mdia.byteLength, hashVal(mdia.toString()))\n    return mdia\n  }\n\n  static mdhd (duration, timescale = 90000) {\n    const mdhd = MP4.box(MP4.types.mdhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // todo 0x00, 0x00, 0x00, 0x00, // modification_time\n      (timescale >> 24) & 0xff, (timescale >> 16) & 0xff, (timescale >> 8) & 0xff, timescale & 0xff,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff, // (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,//todo\n      0x55, 0xc4, // 'und' language (undetermined) //todo 0x15, 0xC7\n      0x00, 0x00 // pre_defined\n    ]))\n    // console.log('[remux],mdhd, len,', mdhd.byteLength, hashVal(mdhd.toString()))\n    return mdhd\n  }\n\n  static hdlr (type) {\n    const hdlr = MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type])\n    // console.log('[remux],hdlr, len,', hdlr.byteLength, hashVal(hdlr.toString()))\n    return hdlr\n  }\n\n  static minf (track) {\n    const minf = MP4.box(MP4.types.minf, track.type === TrackType.VIDEO ? MP4.VMHD : MP4.SMHD, MP4.DINF, MP4.stbl(track))\n    // console.log('[remux],minf, len,', minf.byteLength, hashVal(minf.toString()))\n    return minf\n  }\n\n  static stbl (track) {\n    const extBox = []\n    if (track && track.ext) {\n      track.ext.stss && extBox.push(MP4.stss(track.ext.stss.entries))\n      // track.ext.stss && extBox.push(MP4.ctts(track.ext.stss.entries))\n    }\n    const stbl = MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.STTS, extBox[0], MP4.STSC, MP4.STSZ, MP4.STCO)\n    // console.log('[remux],stbl, len,', stbl.byteLength, hashVal(stbl.toString()))\n    return stbl\n  }\n\n  static stsd (track) {\n    let content\n    if (track.type === 'audio') {\n      if (track.useEME && track.enca) {\n        content = MP4.enca(track)\n        // console.log('[remux],enca, len,', content.byteLength, track.type, hashVal(content.toString()))\n      } else {\n        content = MP4.mp4a(track)\n        // console.log('[remux],mp4a, len,', content.byteLength, track.type, hashVal(content.toString()))\n      }\n    } else if (track.useEME && track.encv) {\n      content = MP4.encv(track)\n      // console.log('[remux],encv, len,', content.byteLength, track.type, hashVal(content.toString()))\n    } else {\n      content = MP4.avc1hev1(track)\n      // console.log('[remux],avc1hev1, len,', content.byteLength, track.type, hashVal(content.toString()))\n    }\n    const stsd = MP4.box(MP4.types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01 // entry_count\n    ]), content)\n    // console.log('[remux],stsd, len,', stsd.byteLength, hashVal(stsd.toString()))\n    return stsd\n  }\n\n  static enca (data) {\n    const channelCount = data.enca.channelCount\n    const sampleRate = data.enca.sampleRate\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      (sampleRate >> 8) & 0xff,\n      sampleRate & 0xff, //\n      0x00, 0x00\n    ])\n    const esds = MP4.esds(data.config)\n    // console.log('[remux],esds, len,', esds.byteLength, hashVal(esds.toString()))\n    const sinf = MP4.sinf(data.enca)\n    // console.log('[remux],sinf, len,', sinf.byteLength, hashVal(sinf.toString()))\n    return MP4.box(MP4.types.enca, content, esds, sinf)\n  }\n\n  static encv (track) {\n    const sps = track.sps.length > 0 ? track.sps[0] : []\n    const pps = track.pps.length > 0 ? track.pps[0] : []\n    const width = track.width\n    const height = track.height\n    const hSpacing = track.sarRatio[0]\n    const vSpacing = track.sarRatio[1]\n\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (width >> 8) & 0xff,\n      width & 0xff, // width\n      (height >> 8) & 0xff,\n      height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n\n      0x12,\n      0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n      0x79, 0x6D, 0x6F, 0x74,\n      0x69, 0x6F, 0x6E, 0x2F,\n      0x68, 0x6C, 0x73, 0x2E,\n      0x6A, 0x73, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11]) // pre_defined = -1;\n    const avcc = new Uint8Array([\n      0x01, // version\n      sps[1], // profile\n      sps[2], // profile compatible\n      sps[3], // level\n      0xfc | 3,\n      0xE0 | 1, // 目前只处理一个sps\n      sps.length >>> 8 & 0xff,\n      sps.length & 0xff\n    ].concat(...sps).concat([\n      0x01,\n      pps.length >>> 8 & 0xff,\n      pps.length & 0xff\n    ]).concat(...pps))\n    const btrt = new Uint8Array([\n      0x00, 0x00, 0x58, 0x39,\n      0x00, 0x0F, 0xC8, 0xC0,\n      0x00, 0x04, 0x56, 0x48\n    ])\n    const sinf = MP4.sinf(track.encv)\n    const pasp = new Uint8Array([\n      (hSpacing >> 24), // hSpacing\n      (hSpacing >> 16) & 0xff,\n      (hSpacing >> 8) & 0xff,\n      hSpacing & 0xff,\n      (vSpacing >> 24), // vSpacing\n      (vSpacing >> 16) & 0xff,\n      (vSpacing >> 8) & 0xff,\n      vSpacing & 0xff\n    ])\n    return MP4.box(MP4.types.encv, content, MP4.box(MP4.types.avcC, avcc), MP4.box(MP4.types.btrt, btrt), sinf, MP4.box(MP4.types.pasp, pasp))\n  }\n\n  static schi (data) {\n    const content = new Uint8Array([])\n    const tenc = MP4.tenc(data)\n    return MP4.box(MP4.types.schi, content, tenc)\n  }\n\n  static tenc (data) {\n    //  用于每个track的加密参数（包括KID、初始化向量、加密标志位），包含在TrackEncryptionBox(‘tenc’)中。\n    const content = new Uint8Array(\n      [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // skip\n        data.default_IsEncrypted & 0xff, // default_isProtected\n        data.default_IV_size & 0xff // default_Per_Sample_IV_Size\n      ].concat(parse(data.default_KID)))\n    return MP4.box(MP4.types.tenc, content)\n  }\n\n  static sinf (data) {\n    const content = new Uint8Array([])\n    const frma = new Uint8Array([\n      data.data_format.charCodeAt(0),\n      data.data_format.charCodeAt(1),\n      data.data_format.charCodeAt(2),\n      data.data_format.charCodeAt(3)\n    ])\n    const schm = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x63, 0x65, 0x6E, 0x63, // cenc\n      0x00, 0x01, 0x00, 0x00 // version\n    ])\n    const schi = MP4.schi(data)\n    return MP4.box(MP4.types.sinf, content, MP4.box(MP4.types.frma, frma), MP4.box(MP4.types.schm, schm), schi)\n  }\n\n  static avc1hev1 (track) {\n    const isHevc = track.codecType === VideoCodecType.HEVC\n    const typ = isHevc ? MP4.types.hvc1 : MP4.types.avc1\n    const config = isHevc ? MP4.hvcC(track) : MP4.avcC(track)\n    const boxes = [\n      new Uint8Array([\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // data_reference_index\n        0x00, 0x00, // pre_defined\n        0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n        (track.width >> 8) & 0xff, track.width & 0xff, // width\n        (track.height >> 8) & 0xff, track.height & 0xff, // height\n        0x00, 0x48, 0x00, 0x00, // horizresolution\n        0x00, 0x48, 0x00, 0x00, // vertresolution\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // frame_count\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, // compressor name\n        0x00, 0x18, // depth\n        0x11, 0x11 // pre_defined = -1 //todo\n      ]), config\n    ]\n    // console.log('[remux],avc1hev1_0, len,', boxes[0].byteLength, hashVal(boxes[0].toString()))\n    // console.log('[remux],avc1hev1_1, len,', boxes[1].byteLength, hashVal(boxes[1].toString()))\n    if (isHevc) {\n      boxes.push(MP4.box(MP4.types.fiel, new Uint8Array([0x01, 0x00])))\n      // console.log('[remux],fiel, len,', boxes[2].byteLength, hashVal(boxes[2].toString()))\n    } else if (track.sarRatio && track.sarRatio.length > 1) {\n      boxes.push(MP4.pasp(track.sarRatio))\n      // console.log('[remux],pasp, len,', boxes[2].byteLength, hashVal(boxes[2].toString()))\n    }\n    return MP4.box(typ, ...boxes)\n  }\n\n  static avcC (track) {\n    const sps = []\n    const pps = []\n\n    let len\n    track.sps.forEach((s) => {\n      len = s.byteLength\n      sps.push((len >>> 8) & 0xff)\n      sps.push(len & 0xff)\n      sps.push(...s)\n    })\n\n    track.pps.forEach((p) => {\n      len = p.byteLength\n      pps.push((len >>> 8) & 0xff)\n      pps.push(len & 0xff)\n      pps.push(...p)\n    })\n\n    return MP4.box(MP4.types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      sps[3], // AVCProfileIndication\n      sps[4], // profile_compatibility\n      sps[5], // AVCLevelIndication\n      0xfc | 3, // lengthSizeMinusOne\n      0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(...sps)\n      .concat([track.pps.length]) // numOfPictureParameterSets\n      .concat(...pps)))\n  }\n\n  static hvcC (track) {\n    const hvcC = track.hvcC\n    if (hvcC instanceof ArrayBuffer || hvcC instanceof Uint8Array) return hvcC\n    const { vps, sps, pps } = track\n    let data\n    if (hvcC) {\n      const pcf = hvcC.generalProfileCompatibilityFlags\n      const cif = hvcC.generalConstraintIndicatorFlags\n      const numOfArrays = (vps.length && 1) + (sps.length && 1) + (pps.length && 1)\n      data = [\n        0x01, // configurationVersion\n        hvcC.generalProfileSpace << 6 | hvcC.generalTierFlag << 5 | hvcC.generalProfileIdc,\n        pcf >>> 24, pcf >>> 16, pcf >>> 8, pcf,\n        cif[0], cif[1], cif[2], cif[3], cif[4], cif[5],\n        hvcC.generalLevelIdc,\n        0xF0, 0x00, // min_spatial_segmentation_idc\n        0xFC, // parallelismType\n        hvcC.chromaFormatIdc | 0xFC,\n        hvcC.bitDepthLumaMinus8 | 0xF8,\n        hvcC.bitDepthChromaMinus8 | 0xF8,\n        0x00, 0x00, // avgFrameRate\n        hvcC.numTemporalLayers << 3 | hvcC.temporalIdNested << 2 | 3,\n        numOfArrays\n      ]\n      const write = (x) => {\n        data.push(x.length >> 8, x.length)\n        data.push(...x)\n      }\n      if (vps.length) {\n        data.push(0xA0, 0x00, vps.length)\n        vps.forEach(write)\n      }\n      if (sps.length) {\n        data.push(0xA1, 0x00, sps.length)\n        sps.forEach(write)\n      }\n      if (pps.length) {\n        data.push(0xA2, 0x00, pps.length)\n        pps.forEach(write)\n      }\n    } else {\n      data = [\n        0x01, // configurationVersion\n        0x01, // profile_space + tier_flag + profile_idc\n        0x60, 0x00, 0x00, 0x00, // general_profile_compatibility\n        0x90, 0x00, 0x00, 0x00, 0x00, 0x00, // constraint_indicator_flags\n        0x5D, // level_idc=90\n        0xF0, 0x00, 0xFC, 0xFD, // profile_compatibility_indications\n        0xF8, // ‘11111’b + bitDepthLumaMinus8\n        0xF8, // ‘11111’b + bitDepthChromaMinus8\n        0x00, 0x00, // avgFrameRate\n        0x0F, // constantFrameRate + numTemporalLayers + ‘1’b + lengthSizeMinusOne\n        0x03, // numOfArrays\n\n        // vps\n        0xA0, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x18, // nalUnitLength\n        0x40, 0x01, 0x0C, 0x01, 0xFF, 0xFF, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5D, 0x99, 0x98, 0x09,\n\n        // sps\n        0xA1, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x2D, // nalUnitLength\n        0x42, 0x01, 0x01, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5D, 0xA0, 0x02,\n        0x80, 0x80, 0x2D, 0x16, 0x59, 0x99, 0xA4, 0x93, 0x2B, 0x9A, 0x80, 0x80, 0x80, 0x82, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00,\n        0x00, 0x03, 0x00, 0x32, 0x10,\n\n        // pps\n        0xA2, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x07, // nalUnitLength\n        0x44, 0x01, 0xC1, 0x72, 0xB4, 0x62, 0x40\n      ]\n    }\n    return MP4.box(MP4.types.hvcC, new Uint8Array(data))\n  }\n\n  static pasp ([hSpacing, vSpacing]) {\n    return MP4.box(MP4.types.pasp, new Uint8Array([\n      hSpacing >> 24, (hSpacing >> 16) & 0xff, (hSpacing >> 8) & 0xff, hSpacing & 0xff,\n      vSpacing >> 24, (vSpacing >> 16) & 0xff, (vSpacing >> 8) & 0xff, vSpacing & 0xff\n    ]))\n  }\n\n  static mp4a (track) {\n    return MP4.box(MP4.types.mp4a, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount,\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      (track.sampleRate >> 8) & 0xff, track.sampleRate & 0xff,\n      0x00, 0x00\n    ]), track.config.length ? MP4.esds(track.config) : undefined)\n  }\n\n  static esds (config) {\n    const len = config.length\n    const esds = MP4.box(MP4.types.esds, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x03, // tag\n      0x17 + len, // length\n      0x00, 0x00, // ES_ID\n      0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n      0x04, // tag\n      0x0f + len, // length\n      0x40, // object type\n      0x15, // streamType\n      0x00, 0x06, 0x00, // bufferSizeDB\n      0x00, 0x00, 0xda, 0xc0, // maxBitrate\n      0x00, 0x00, 0xda, 0xc0, // avgBitrate\n      0x05 // tag, DecoderSpecificInfoTag\n    ].concat([len])\n      .concat(config)\n      .concat(\n        [0x06, 0x01, 0x02]// GASpecificConfig\n      )\n    ))\n    // console.log('[remux],esds ,len ', esds.byteLength, hashVal(esds.toString()))\n    return esds\n  }\n\n  static mvex (tracks) {\n    // const mehd = MP4.box(MP4.types.mehd, this.extension(0, 0), Buffer.writeUint32(tracks[0].tkhdDuration))\n    // const mvex = MP4.box(MP4.types.mvex, mehd, MP4.trex1(1), MP4.trex2(2))\n    // // console.log('[remux],mvex, len,', mvex.byteLength, hashVal(mvex.toString()))\n    // const mvex = MP4.box(MP4.types.mvex, MP4.trex1(1), MP4.trex2(2))\n    const mvex = MP4.box(MP4.types.mvex, ...tracks.map((t) => MP4.trex(t.id)))\n    // console.log('[remux],mvex, len,', mvex.byteLength, hashVal(mvex.toString()))\n    return mvex\n  }\n\n  static trex (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      id >> 24, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static trex1 (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0xff,\n      (id >> 8) & 0xff,\n      (id & 0xff), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x02, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x00 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static trex2 (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0xff,\n      (id >> 8) & 0xff,\n      (id & 0xff), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x04, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x02, 0x00, 0x00, 0x00 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static moof (tracks) {\n    const moof = MP4.box(MP4.types.moof, MP4.mfhd(tracks[0].samples ? tracks[0].samples[0].gopId : 0), ...tracks.map((t) => MP4.traf(t)))\n    // console.log('[remux],moof, len', moof.byteLength)\n    return moof\n    // return MP4.box(MP4.types.moof, MP4.mfhd(tracks[0].gopId), ...tracks.map((t) => MP4.traf(t)))\n  }\n\n  static mfhd (sequenceNumber) {\n    // sequenceNumber += 1\n    const mfhd = MP4.box(MP4.types.mfhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      sequenceNumber >> 24, (sequenceNumber >> 16) & 0xff, (sequenceNumber >> 8) & 0xff, sequenceNumber & 0xff\n    ]))\n    // console.log('[remux],mfhd, len,', mfhd.byteLength, hashVal(mfhd.toString()))\n    return mfhd\n  }\n\n  static traf (track) {\n    const tfhd = MP4.tfhd(track.id)\n    // console.log('[remux],tfhd, len,', tfhd.byteLength, hashVal(tfhd.toString()), ', trackid = ', track.id)\n    // console.log('[remux],tfdt,baseMediaDecodeTime,', track.baseMediaDecodeTime)\n    const tfdt = MP4.tfdt(track, track.baseMediaDecodeTime)\n    let sencLength = 0\n    let samples\n    if (track.isVideo && track.videoSenc) {\n      samples = track.videoSenc\n      samples.forEach(function (item) {\n        sencLength = sencLength + 8\n        if (item.subsamples && item.subsamples.length) {\n          sencLength = sencLength + 2\n          sencLength = sencLength + item.subsamples.length * 6\n        }\n      })\n    }\n    track.videoSencLength = sencLength\n    // console.log('[remux],tfdt, len,', tfdt.toString().length)\n    // console.log('[remux],tfdt, len,', tfdt.byteLength, hashVal(tfdt.toString()))\n    if (!track.useEME || (!track.isVideoEncryption && !track.isAudioEncryption)) {\n      const sdtp = MP4.sdtp(track)\n      // console.log('[remux],sdtp, len,', sdtp.byteLength, hashVal(sdtp.toString()))\n      const offset = 16 + // tfhd\n        20 + // tfdt\n        8 + // traf header\n        16 + // mfhd\n        8 + // moof header\n        8 // mdat header\n      return MP4.box(MP4.types.traf, tfhd, tfdt, sdtp, MP4.trun(track.samples, sdtp.byteLength + offset))\n    } else if (track.isVideoEncryption) {\n      if (track.isVideo) {\n        // 加密视频\n        const saiz = MP4.saiz(track)\n        const saio = MP4.saio(track)\n        const trun = MP4.trun1(track)\n        const senc = MP4.senc(track)\n        const traf = MP4.box(MP4.types.traf, tfhd, tfdt, saiz, saio, trun, senc)\n        // console.log('[remux],trex_video, len,', traf.byteLength, hashVal(traf.toString()))\n        return traf\n      } else {\n        // 视频加密，音频加密和未加密处理\n        if (!track.isAudioEncryption) {\n          // 音频未加密\n          const sbgp = MP4.sbgp()\n          const trun = MP4.trun1(track)\n          return MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, trun)\n        } else {\n          // 音频加密\n          const sbgp = MP4.sbgp()\n          const saiz = MP4.saiz(track)\n          const saio = MP4.saio(track)\n          const senc = MP4.senc(track)\n          const trun = MP4.trun1(track)\n          const traf = MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, saiz, saio, senc, trun)\n          // console.log('[remux],trex_audio, len,', traf.byteLength, hashVal(traf.toString()))\n          return traf\n        }\n      }\n    } else {\n      // 视频未加密，音频加密\n      if (track.isVideo) {\n        const trun = MP4.trun1(track)\n        return MP4.box(MP4.types.traf, tfhd, tfdt, trun)\n      } else {\n        const sbgp = MP4.sbgp()\n        const saiz = MP4.saiz(track)\n        const saio = MP4.saio(track)\n        const senc = MP4.senc(track)\n        const trun = MP4.trun1(track)\n        const traf = MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, saiz, saio, senc, trun)\n        // console.log('[remux],trex, len,', traf.byteLength, hashVal(traf.toString()))\n        return traf\n      }\n    }\n  }\n\n  static sdtp (data) {\n    const buffer = new Buffer()\n    data.samples.forEach(item => {\n      buffer.write(new Uint8Array(data.isVideo ? [item.keyframe ? 32 : 16] : [16]))\n    })\n    return MP4.box(MP4.types.sdtp, this.extension(0, 0), buffer.buffer)\n  }\n\n  static trun1 (data) {\n    // const id = data.id\n    // const ceil = id === 1 ? 12 : 4\n    const buffer = new Buffer()\n    const sampleCount = Buffer.writeUint32(data.samples.length)\n    let offset = null\n    if (data.isVideo) {\n      const sencLength = data.videoSencLength\n      /*\n      16 + // mfhd\n      16 + // tfhd\n      20 + // tfdt\n      17 + //saiz\n      24 + //saio\n      data.samples.length*16\n      4(offset) + 4(sampleCount) + 12(header)  //trun\n      12(header) + sencLength //senc\n      8 + // traf header\n      8 + // moof header\n      8 // mdat header\n      = 149+data.samples.length * 16 + sencLength\n       */\n      offset = Buffer.writeUint32(data.samples.length * 16 + sencLength + 149)\n      if (!data.isVideoEncryption && data.isAudioEncryption) {\n        offset = Buffer.writeUint32(data.samples.length * 16 + 92)\n      }\n    } else {\n      /*\n      16 + // mfhd\n      16 + // tfhd\n      20 + // tfdt\n      28 + //sbgp\n      4(offset) + 4(sampleCount) + 12(header)  //trun\n      8 + // traf header\n      8 + // moof header\n      8 // mdat header\n       */\n      let len = data.samples.length * 12 + 124\n      if (data.isAudioEncryption) {\n        len = data.samples.length * 12 + 8 * data.audioSenc.length + 177\n      }\n      offset = Buffer.writeUint32(len)\n    }\n\n    data.samples.forEach(item => {\n      buffer.write(Buffer.writeUint32(item.duration))\n      buffer.write(Buffer.writeUint32(item.size))\n      buffer.write(Buffer.writeUint32(item.keyframe ? 0x02000000 : 0x00010000))\n      if (data.isVideo) {\n        buffer.write(Buffer.writeUint32(item.cts ? item.cts : 0))\n      }\n    })\n\n    return MP4.box(MP4.types.trun, this.extension(0, data.flags), sampleCount, offset, buffer.buffer)\n  }\n\n  static senc (data) {\n    const buffer = new Buffer()\n    const len = data.samples.length\n    const ceil = data.isVideo ? 16 : 8\n    const flag = data.isVideo ? 2 : 0\n    let samples = []\n    let samplesLength = 0\n    if (data.isVideo) {\n      samples = data.videoSenc\n      samplesLength = data.videoSencLength\n    } else {\n      samples = data.audioSenc\n    }\n    samplesLength = samplesLength || ceil * len\n    buffer.write(\n      Buffer.writeUint32(16 + samplesLength), MP4.types.senc, this.extension(0, flag)\n    )\n    buffer.write(Buffer.writeUint32(len))\n    samples.forEach(item => {\n      for (let i = 0; i < item.InitializationVector.length; i++) {\n        buffer.write(new Uint8Array([item.InitializationVector[i]]))\n      }\n      if (item.subsamples && item.subsamples.length) {\n        buffer.write(Buffer.writeUint16(item.subsamples.length))\n        item.subsamples.forEach(value => {\n          buffer.write(Buffer.writeUint16(value.BytesOfClearData))\n          buffer.write(Buffer.writeUint32(value.BytesOfProtectedData))\n        })\n      }\n    })\n    return buffer.buffer\n    // return MP4.box(MP4.types.senc, this.extension(0, flag), buffer.buffer)\n  }\n\n  static saio (data) {\n    let length = data.samples.length * 12 + 141\n    if (!data.isVideo && data.isAudioEncryption) {\n      length = 149\n    }\n    const content = new Uint8Array([\n      0x01, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x01,\n      0x00, 0x00, 0x00, 0x00,\n      (length >> 24) & 0xff,\n      (length >> 16) & 0xff,\n      (length >> 8) & 0xff,\n      length & 0xff\n    ])\n    return MP4.box(MP4.types.saio, content)\n  }\n\n  static saiz (data) {\n    const samplesLength = data.samples.length\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x10, // default sample info size\n      (samplesLength >> 24) & 0xff,\n      (samplesLength >> 16) & 0xff,\n      (samplesLength >> 8) & 0xff,\n      samplesLength & 0xff\n    ])\n    return MP4.box(MP4.types.saiz, content)\n  }\n\n  static sbgp () {\n    const content = new Uint8Array([\n      0x72, 0x6F, 0x6C, 0x6C, // sgpd, grouping_type\n      0x00, 0x00, 0x00, 0x01,\n      0x00, 0x00, 0x01, 0x19,\n      0x00, 0x00, 0x00, 0x01\n    ])\n    return MP4.box(MP4.types.sbgp, this.extension(0, 0), content)\n  }\n\n  static extension (version, flag) {\n    return new Uint8Array([\n      version,\n      (flag >> 16) & 0xff,\n      (flag >> 8) & 0xff,\n      flag & 0xff\n    ])\n  }\n\n  static tfhd (id) {\n    return MP4.box(MP4.types.tfhd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags todo 0x00\n      id >> 24, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff // track_ID\n    ]))\n  }\n\n  static tfdt (data, baseMediaDecodeTime) {\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1))\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1))\n    if (data.useEME && (data.isVideoEncryption || data.isAudioEncryption)) {\n      return MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x00, // version 0\n        0x00, 0x00, 0x00, // flags\n        lowerWordBaseMediaDecodeTime >> 24,\n        (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n        lowerWordBaseMediaDecodeTime & 0xff\n      ]))\n    } else {\n      return MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x01, // version 1\n        0x00, 0x00, 0x00, // flags\n        upperWordBaseMediaDecodeTime >> 24,\n        (upperWordBaseMediaDecodeTime >> 16) & 0xff,\n        (upperWordBaseMediaDecodeTime >> 8) & 0xff,\n        upperWordBaseMediaDecodeTime & 0xff,\n        lowerWordBaseMediaDecodeTime >> 24,\n        (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n        lowerWordBaseMediaDecodeTime & 0xff\n      ]))\n    }\n  }\n\n  static trun (samples, offset) {\n    const sampleLen = samples.length\n    const dataLen = 12 + (16 * sampleLen)\n    offset += 8 + dataLen\n    const data = new Uint8Array(dataLen)\n    data.set([\n      0x00, // version\n      0x00, 0x0f, 0x01, // flags\n      (sampleLen >>> 24) & 0xff, (sampleLen >>> 16) & 0xff, (sampleLen >>> 8) & 0xff, sampleLen & 0xff,\n      (offset >>> 24) & 0xff, (offset >>> 16) & 0xff, (offset >>> 8) & 0xff, offset & 0xff // data_offset\n    ], 0)\n    for (let i = 0; i < sampleLen; i++) {\n      const {\n        duration, size, flag = {}, cts = 0\n      } = samples[i]\n      data.set([\n        (duration >>> 24) & 0xff, (duration >>> 16) & 0xff, (duration >>> 8) & 0xff, duration & 0xff,\n        (size >>> 24) & 0xff, (size >>> 16) & 0xff, (size >>> 8) & 0xff, size & 0xff,\n        (flag.isLeading << 2) | (flag.dependsOn === null || flag.dependsOn === undefined ? 1 : flag.dependsOn),\n        (flag.isDependedOn << 6) | (flag.hasRedundancy << 4) | (flag.paddingValue << 1) | (flag.isNonSyncSample === null || flag.isNonSyncSample === undefined ? 1 : flag.isNonSyncSample),\n        flag.degradationPriority & (0xf0 << 8), flag.degradationPriority & 0x0f, // sample_flags\n        (cts >>> 24) & 0xff, (cts >>> 16) & 0xff, (cts >>> 8) & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i)\n    }\n\n    return MP4.box(MP4.types.trun, data)\n  }\n\n  static moovMP4 (tracks) {\n    return MP4.box(MP4.types.moov,\n      MP4.mvhd(tracks[0].duration, tracks[0].timescale),\n      ...tracks.map((t) => MP4.trackMP4(t)))\n  }\n\n  static trackMP4 (track) {\n    return MP4.box(\n      MP4.types.trak,\n      MP4.tkhd(track.id, track.duration, track.width, track.height),\n      MP4.mdiaMP4(track)\n    )\n  }\n\n  static mdiaMP4 (track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.duration, track.timescale), MP4.hdlr(track.type), MP4.minfMP4(track))\n  }\n\n  static minfMP4 (track) {\n    return MP4.box(MP4.types.minf, track.type === TrackType.VIDEO ? MP4.VMHD : MP4.SMHD, MP4.DINF, MP4.stblMP4(track))\n  }\n\n  static stblMP4 (track) {\n    const { ext } = track\n    const boxes = [\n      MP4.stsd(track),\n      MP4.stts(ext.stts),\n      MP4.stsc(ext.stsc),\n      MP4.stsz(ext.stsz),\n      MP4.stco(ext.stco)\n    ]\n\n    if (ext.stss.length) {\n      boxes.push(MP4.stss(ext.stss))\n    }\n\n    if (ext.ctts.length) {\n      boxes.push(MP4.ctts(ext.ctts))\n    }\n\n    return MP4.box(MP4.types.stbl, ...boxes)\n  }\n\n  static stts (samples) {\n    const len = samples.length\n    const data = new Uint8Array(8 * len)\n    let offset = 0\n    samples.forEach(({ value, count }) => {\n      data.set([\n        count >> 24, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff,\n        value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff\n      ], offset)\n      offset += 8\n    })\n\n    return MP4.box(MP4.types.stts, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      (len >> 24), (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static stsc (entries) {\n    const len = entries.length\n    const data = new Uint8Array(12 * len)\n    let offset = 0\n    entries.forEach(({ firstChunk, samplesPerChunk, sampleDescIndex }) => {\n      data.set([\n        firstChunk >> 24, (firstChunk >> 16) & 0xff, (firstChunk >> 8) & 0xff, firstChunk & 0xff,\n        samplesPerChunk >> 24, (samplesPerChunk >> 16) & 0xff, (samplesPerChunk >> 8) & 0xff, samplesPerChunk & 0xff,\n        sampleDescIndex >> 24, (sampleDescIndex >> 16) & 0xff, (sampleDescIndex >> 8) & 0xff, sampleDescIndex & 0xff\n      ], offset)\n      offset += 12\n    })\n    return MP4.box(MP4.types.stsc, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      (len >> 24), (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static stsz (samplesSizes) {\n    const len = samplesSizes.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    samplesSizes.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stsz, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static stco (offsets) {\n    const len = offsets.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    offsets.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stco, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static stss (keyframeIndexes) {\n    const len = keyframeIndexes.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    keyframeIndexes.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stss, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static ctts (samples) {\n    const len = samples.length\n    const data = new Uint8Array(8 * len)\n    let offset = 0\n    samples.forEach(({ value, count }) => {\n      data.set([\n        count >> 24, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff,\n        value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff\n      ], offset)\n      offset += 8\n    })\n    return MP4.box(MP4.types.ctts, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static styp () {\n    return MP4.box(MP4.types.styp, new Uint8Array([\n      0x6D, 0x73, 0x64, 0x68,\n      0x00, 0x00, 0x00, 0x00,\n      0x6D, 0x73, 0x64, 0x68,\n      0x6D, 0x73, 0x69, 0x78\n    ]))\n  }\n\n  // data.sampleOffset 指的是samples的序列号。_samples[0].idx\n  static sidx (data) {\n    // const buffer = new Buffer()\n    const timescale = data.timescale\n    const duration = data.samples[0].duration\n    const durationCount = duration * data.samples.length\n    const earliestTime = data.samples[0].sampleOffset * duration\n    let mdatSize = 8\n    data.samples.forEach(item => {\n      mdatSize += item.size\n    })\n    let length = 0\n    if (data.isVideo) {\n      let sencLength = 0\n      let samples\n      if (data.videoSenc) {\n        samples = data.videoSenc\n      }\n      if (data.isVideo) {\n        samples.forEach(item => {\n          sencLength = sencLength + 8\n          if (item.subsamples && item.subsamples.length) {\n            sencLength = sencLength + 2\n            sencLength = sencLength + item.subsamples.length * 6\n          }\n        })\n      }\n      data.videoSencLength = sencLength\n      length = mdatSize + 141 + data.samples.length * 16 + sencLength\n      if (data.useEME && data.isAudioEncryption && !data.isVideoEncryption) {\n        length = mdatSize + (data.samples.length * 16) + 84\n      }\n    } else {\n      length = mdatSize + 116 + data.samples.length * 12\n      if (data.useEME && data.isAudioEncryption) {\n        length = mdatSize + 169 + data.samples.length * 12 + 8 * data.audioSenc.length\n      }\n    }\n\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, data.id & 0xff, // ref_id\n      (timescale >> 24) & 0xff,\n      (timescale >> 16) & 0xff,\n      (timescale >> 8) & 0xff,\n      timescale & 0xff, // timescale\n      (earliestTime >> 24) & 0xff,\n      (earliestTime >> 16) & 0xff,\n      (earliestTime >> 8) & 0xff,\n      earliestTime & 0xff, // earliest_presentation_time\n      0x00, 0x00, 0x00, 0x00, // first_offset\n      0x00, 0x00, // reserved\n      0x00, 0x01, // ref_count\n      // 0x00, 0x04, 0x11, 0xCF, // ref_size + ref_type\n      // 0x00, 0x01, 0x0A, 0xA6, // ref_size + ref_type\n      0x00, // ref_size + ref_type ref_size = moof.size + mdat.size\n      (length >> 16) & 0xff,\n      (length >> 8) & 0xff,\n      length & 0xff,\n      (durationCount >> 24) & 0xff,\n      (durationCount >> 16) & 0xff,\n      (durationCount >> 8) & 0xff,\n      durationCount & 0xff,\n      0x90, 0x00, 0x00, 0x00\n    ])\n    return MP4.box(MP4.types.sidx, content)\n  }\n\n  static mdat (data) {\n    const mdat = MP4.box(MP4.types.mdat, data)\n    // console.log('[remux],mdat ,len ', mdat.byteLength, hashVal(mdat.toString()))\n    return mdat\n  }\n}\n","\nexport class Logger {\n  constructor (name, enable) {\n    this.name = name || ''\n    this._prefix = `[${this.name}]`\n    Logger.disabled = enable\n  }\n\n  debug (...args) {\n    if (Logger.disabled) return\n    console.debug(this._prefix, ...args)\n  }\n\n  log (...args) {\n    if (Logger.disabled) return\n    console.log(this._prefix, ...args)\n  }\n\n  warn (...args) {\n    if (Logger.disabled) return\n    console.warn(this._prefix, ...args)\n  }\n\n  error (...args) {\n    if (Logger.disabled) return\n    console.error(this._prefix, ...args)\n  }\n\n  table (...args) {\n    if (Logger.disabled) return\n    console.group(this._prefix)\n    console.table(...args)\n    console.groupEnd()\n  }\n\n  static disabled = true\n\n  static enable () {\n    Logger.disabled = false\n  }\n\n  static disable () {\n    Logger.disabled = true\n  }\n}\n","import {\n  WordArray,\n  Hasher,\n} from './core.js';\n\n// Constants table\nconst T = [];\n\n// Compute constants\nfor (let i = 0; i < 64; i += 1) {\n  T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nconst FF = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & c) | (~b & d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst GG = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & d) | (c & ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst HH = (a, b, c, d, x, s, t) => {\n  const n = a + (b ^ c ^ d) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst II = (a, b, c, d, x, s, t) => {\n  const n = a + (c ^ (b | ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\n/**\n * MD5 hash algorithm.\n */\nexport class MD5Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray([\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Swap endian\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = M[offset_i];\n\n      _M[offset_i] = (\n        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)\n          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n      );\n    }\n\n    // Shortcuts\n    const H = this._hash.words;\n\n    const M_offset_0 = _M[offset + 0];\n    const M_offset_1 = _M[offset + 1];\n    const M_offset_2 = _M[offset + 2];\n    const M_offset_3 = _M[offset + 3];\n    const M_offset_4 = _M[offset + 4];\n    const M_offset_5 = _M[offset + 5];\n    const M_offset_6 = _M[offset + 6];\n    const M_offset_7 = _M[offset + 7];\n    const M_offset_8 = _M[offset + 8];\n    const M_offset_9 = _M[offset + 9];\n    const M_offset_10 = _M[offset + 10];\n    const M_offset_11 = _M[offset + 11];\n    const M_offset_12 = _M[offset + 12];\n    const M_offset_13 = _M[offset + 13];\n    const M_offset_14 = _M[offset + 14];\n    const M_offset_15 = _M[offset + 15];\n\n    // Working varialbes\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n\n    // Computation\n    a = FF(a, b, c, d, M_offset_0, 7, T[0]);\n    d = FF(d, a, b, c, M_offset_1, 12, T[1]);\n    c = FF(c, d, a, b, M_offset_2, 17, T[2]);\n    b = FF(b, c, d, a, M_offset_3, 22, T[3]);\n    a = FF(a, b, c, d, M_offset_4, 7, T[4]);\n    d = FF(d, a, b, c, M_offset_5, 12, T[5]);\n    c = FF(c, d, a, b, M_offset_6, 17, T[6]);\n    b = FF(b, c, d, a, M_offset_7, 22, T[7]);\n    a = FF(a, b, c, d, M_offset_8, 7, T[8]);\n    d = FF(d, a, b, c, M_offset_9, 12, T[9]);\n    c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n    b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n    a = FF(a, b, c, d, M_offset_12, 7, T[12]);\n    d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n    c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n    b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n    a = GG(a, b, c, d, M_offset_1, 5, T[16]);\n    d = GG(d, a, b, c, M_offset_6, 9, T[17]);\n    c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n    b = GG(b, c, d, a, M_offset_0, 20, T[19]);\n    a = GG(a, b, c, d, M_offset_5, 5, T[20]);\n    d = GG(d, a, b, c, M_offset_10, 9, T[21]);\n    c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n    b = GG(b, c, d, a, M_offset_4, 20, T[23]);\n    a = GG(a, b, c, d, M_offset_9, 5, T[24]);\n    d = GG(d, a, b, c, M_offset_14, 9, T[25]);\n    c = GG(c, d, a, b, M_offset_3, 14, T[26]);\n    b = GG(b, c, d, a, M_offset_8, 20, T[27]);\n    a = GG(a, b, c, d, M_offset_13, 5, T[28]);\n    d = GG(d, a, b, c, M_offset_2, 9, T[29]);\n    c = GG(c, d, a, b, M_offset_7, 14, T[30]);\n    b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n    a = HH(a, b, c, d, M_offset_5, 4, T[32]);\n    d = HH(d, a, b, c, M_offset_8, 11, T[33]);\n    c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n    b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n    a = HH(a, b, c, d, M_offset_1, 4, T[36]);\n    d = HH(d, a, b, c, M_offset_4, 11, T[37]);\n    c = HH(c, d, a, b, M_offset_7, 16, T[38]);\n    b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n    a = HH(a, b, c, d, M_offset_13, 4, T[40]);\n    d = HH(d, a, b, c, M_offset_0, 11, T[41]);\n    c = HH(c, d, a, b, M_offset_3, 16, T[42]);\n    b = HH(b, c, d, a, M_offset_6, 23, T[43]);\n    a = HH(a, b, c, d, M_offset_9, 4, T[44]);\n    d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n    c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n    b = HH(b, c, d, a, M_offset_2, 23, T[47]);\n\n    a = II(a, b, c, d, M_offset_0, 6, T[48]);\n    d = II(d, a, b, c, M_offset_7, 10, T[49]);\n    c = II(c, d, a, b, M_offset_14, 15, T[50]);\n    b = II(b, c, d, a, M_offset_5, 21, T[51]);\n    a = II(a, b, c, d, M_offset_12, 6, T[52]);\n    d = II(d, a, b, c, M_offset_3, 10, T[53]);\n    c = II(c, d, a, b, M_offset_10, 15, T[54]);\n    b = II(b, c, d, a, M_offset_1, 21, T[55]);\n    a = II(a, b, c, d, M_offset_8, 6, T[56]);\n    d = II(d, a, b, c, M_offset_15, 10, T[57]);\n    c = II(c, d, a, b, M_offset_6, 15, T[58]);\n    b = II(b, c, d, a, M_offset_13, 21, T[59]);\n    a = II(a, b, c, d, M_offset_4, 6, T[60]);\n    d = II(d, a, b, c, M_offset_11, 10, T[61]);\n    c = II(c, d, a, b, M_offset_2, 15, T[62]);\n    b = II(b, c, d, a, M_offset_9, 21, T[63]);\n\n    // Intermediate hash value\n    H[0] = (H[0] + a) | 0;\n    H[1] = (H[1] + b) | 0;\n    H[2] = (H[2] + c) | 0;\n    H[3] = (H[3] + d) | 0;\n  }\n  /* eslint-ensable no-param-reassign */\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n\n    const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n    const nBitsTotalL = nBitsTotal;\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n      (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)\n    );\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)\n    );\n\n    data.sigBytes = (dataWords.length + 1) * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const hash = this._hash;\n    const H = hash.words;\n\n    // Swap endian\n    for (let i = 0; i < 4; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n\n      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)\n        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n    }\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.MD5('message');\n *     var hash = CryptoJS.MD5(wordArray);\n */\nexport const MD5 = Hasher._createHelper(MD5Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacMD5(message, key);\n */\nexport const HmacMD5 = Hasher._createHmacHelper(MD5Algo);\n","import { MP4 } from './mp4'\nimport { concatUint8Array } from '../utils'\nimport { Logger } from './logger'\n\n/**\n * @typedef {Object} RemuxResult\n * @property {Uint8Array} [videoInitSegment]\n * @property {Uint8Array} [audioInitSegment]\n * @property {Uint8Array} [videoSegment]\n * @property {Uint8Array} [audioSegment]\n */\n\nexport class FMP4Remuxer {\n  /**\n   * @param {import('../model').VideoTrack} videoTrack\n   * @param {import('../model').AudioTrack} audioTrack\n   */\n  constructor (videoTrack, audioTrack, options) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    const browserVersions = /Chrome\\/([^.]+)/.exec(navigator.userAgent)\n    this.forceFirstIDR = browserVersions && Number(browserVersions[1]) < 50\n    this.log = new Logger('FMP4Remuxer', options && options.openLog ? !options.openLog : true)\n  }\n\n  /**\n   * @param {boolean} [createInit=false]\n   * @returns {RemuxResult}\n   */\n  remux (createInit = false, options = {}) {\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n    const hasVideo = videoTrack.exist()\n    const hasAudio = audioTrack.exist()\n\n    let videoInitSegment\n    let audioInitSegment\n\n    let initSegment\n    const tracks = []\n\n    if (createInit) {\n      if (options && options.initMerge) {\n        if (hasVideo) {\n          tracks.push(this.videoTrack)\n        }\n        if (hasAudio) {\n          tracks.push(this.audioTrack)\n        }\n        initSegment = MP4.initSegment(tracks)\n      } else {\n        if (hasVideo) videoInitSegment = MP4.initSegment([this.videoTrack])\n        if (hasAudio) audioInitSegment = MP4.initSegment([this.audioTrack])\n      }\n    }\n\n    let videoSegment\n    let audioSegment\n    if (hasVideo && videoTrack.hasSample()) {\n      videoSegment = this._remuxVideo()\n    }\n\n    if (hasAudio && audioTrack.hasSample()) {\n      audioSegment = this._remuxAudio()\n    }\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    return {\n      initSegment,\n      videoInitSegment,\n      audioInitSegment,\n      videoSegment,\n      audioSegment\n    }\n  }\n\n  _remuxVideo () {\n    const track = this.videoTrack\n    if (this.forceFirstIDR) {\n      track.samples[0].flag = { dependsOn: 2, isNonSyncSample: 0 }\n    }\n    const samples = track.samples\n\n    let mdatSize = 0\n\n    samples.forEach((s) => {\n      mdatSize += s.units.reduce((t, c) => (t + c.byteLength), 0)\n      mdatSize += (s.units.length * 4)\n    })\n\n    const mdata = new Uint8Array(mdatSize)\n    const mdatView = new DataView(mdata.buffer)\n\n    for (let i = 0, l = samples.length, offset = 0, sample; i < l; i++) {\n      sample = samples[i]\n\n      let sampleSize = 0\n      sample.units.forEach((u) => {\n        mdatView.setUint32(offset, u.byteLength)\n        offset += 4\n        mdata.set(u, offset)\n        offset += u.byteLength\n        sampleSize += (4 + u.byteLength)\n      })\n      sample.size = sampleSize\n    }\n    const mdat = MP4.mdat(mdata)\n\n    const moof = MP4.moof([track])\n    return concatUint8Array(moof, mdat)\n\n  }\n\n  _remuxAudio () {\n    const track = this.audioTrack\n    const mdata = new Uint8Array(track.samples.reduce((t, c) => (t + c.size), 0))\n    track.samples.reduce((offset, s) => {\n      mdata.set(s.data, offset)\n      return offset + s.size\n    }, 0)\n    const mdat = MP4.mdat(mdata)\n    const moof = MP4.moof([track])\n    return concatUint8Array(moof, mdat)\n  }\n\n  reset () {\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n  }\n}\n","/* eslint-disable no-use-before-define */\n\n/**\n * Base class for inheritance.\n */\nexport class Base {\n  /**\n   * Extends this object and runs the init method.\n   * Arguments to create() will be passed to init().\n   *\n   * @return {Object} The new object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var instance = MyType.create();\n   */\n  static create(...args) {\n    return new this(...args);\n  }\n\n  /**\n   * Copies properties into this object.\n   *\n   * @param {Object} properties The properties to mix in.\n   *\n   * @example\n   *\n   *     MyType.mixIn({\n   *         field: 'value'\n   *     });\n   */\n  mixIn(properties) {\n    return Object.assign(this, properties);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = instance.clone();\n   */\n  clone() {\n    const clone = new this.constructor();\n    Object.assign(clone, this);\n    return clone;\n  }\n}\n\n/**\n * An array of 32-bit words.\n *\n * @property {Array} words The array of 32-bit words.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\nexport class WordArray extends Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of 32-bit words.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.create();\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n   */\n  constructor(words = [], sigBytes = words.length * 4) {\n    super();\n\n    let typedArray = words;\n    // Convert buffers to uint8\n    if (typedArray instanceof ArrayBuffer) {\n      typedArray = new Uint8Array(typedArray);\n    }\n\n    // Convert other array views to uint8\n    if (\n      typedArray instanceof Int8Array\n      || typedArray instanceof Uint8ClampedArray\n      || typedArray instanceof Int16Array\n      || typedArray instanceof Uint16Array\n      || typedArray instanceof Int32Array\n      || typedArray instanceof Uint32Array\n      || typedArray instanceof Float32Array\n      || typedArray instanceof Float64Array\n    ) {\n      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n    }\n\n    // Handle Uint8Array\n    if (typedArray instanceof Uint8Array) {\n      // Shortcut\n      const typedArrayByteLength = typedArray.byteLength;\n\n      // Extract bytes\n      const _words = [];\n      for (let i = 0; i < typedArrayByteLength; i += 1) {\n        _words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n      }\n\n      // Initialize this word array\n      this.words = _words;\n      this.sigBytes = typedArrayByteLength;\n    } else {\n      // Else call normal init\n      this.words = words;\n      this.sigBytes = sigBytes;\n    }\n  }\n\n  /**\n   * Creates a word array filled with random bytes.\n   *\n   * @param {number} nBytes The number of random bytes to generate.\n   *\n   * @return {WordArray} The random word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.random(16);\n   */\n  static random(nBytes) {\n    const words = [];\n\n    const r = (m_w) => {\n      let _m_w = m_w;\n      let _m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n\n      return () => {\n        _m_z = (0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10)) & mask;\n        _m_w = (0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10)) & mask;\n        let result = ((_m_z << 0x10) + _m_w) & mask;\n        result /= 0x100000000;\n        result += 0.5;\n        return result * (Math.random() > 0.5 ? 1 : -1);\n      };\n    };\n\n    for (let i = 0, rcache; i < nBytes; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n\n      rcache = _r() * 0x3ade67b7;\n      words.push((_r() * 0x100000000) | 0);\n    }\n\n    return new WordArray(words, nBytes);\n  }\n\n  /**\n   * Converts this word array to a string.\n   *\n   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n   *\n   * @return {string} The stringified word array.\n   *\n   * @example\n   *\n   *     var string = wordArray + '';\n   *     var string = wordArray.toString();\n   *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n   */\n  toString(encoder = Hex) {\n    return encoder.stringify(this);\n  }\n\n  /**\n   * Concatenates a word array to this word array.\n   *\n   * @param {WordArray} wordArray The word array to append.\n   *\n   * @return {WordArray} This word array.\n   *\n   * @example\n   *\n   *     wordArray1.concat(wordArray2);\n   */\n  concat(wordArray) {\n    // Shortcuts\n    const thisWords = this.words;\n    const thatWords = wordArray.words;\n    const thisSigBytes = this.sigBytes;\n    const thatSigBytes = wordArray.sigBytes;\n\n    // Clamp excess bits\n    this.clamp();\n\n    // Concat\n    if (thisSigBytes % 4) {\n      // Copy one byte at a time\n      for (let i = 0; i < thatSigBytes; i += 1) {\n        const thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n      }\n    } else {\n      // Copy one word at a time\n      for (let i = 0; i < thatSigBytes; i += 4) {\n        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n      }\n    }\n    this.sigBytes += thatSigBytes;\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Removes insignificant bits.\n   *\n   * @example\n   *\n   *     wordArray.clamp();\n   */\n  clamp() {\n    // Shortcuts\n    const { words, sigBytes } = this;\n\n    // Clamp\n    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n    words.length = Math.ceil(sigBytes / 4);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = wordArray.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone.words = this.words.slice(0);\n\n    return clone;\n  }\n}\n\n/**\n * Hex encoding strategy.\n */\nexport const Hex = {\n  /**\n   * Converts a word array to a hex string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The hex string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const hexChars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      hexChars.push((bite >>> 4).toString(16));\n      hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n  },\n\n  /**\n   * Converts a hex string to a word array.\n   *\n   * @param {string} hexStr The hex string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n   */\n  parse(hexStr) {\n    // Shortcut\n    const hexStrLength = hexStr.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < hexStrLength; i += 2) {\n      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n    }\n\n    return new WordArray(words, hexStrLength / 2);\n  },\n};\n\n/**\n * Latin1 encoding strategy.\n */\nexport const Latin1 = {\n  /**\n   * Converts a word array to a Latin1 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Latin1 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const latin1Chars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      latin1Chars.push(String.fromCharCode(bite));\n    }\n\n    return latin1Chars.join('');\n  },\n\n  /**\n   * Converts a Latin1 string to a word array.\n   *\n   * @param {string} latin1Str The Latin1 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n   */\n  parse(latin1Str) {\n    // Shortcut\n    const latin1StrLength = latin1Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i += 1) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n    }\n\n    return new WordArray(words, latin1StrLength);\n  },\n};\n\n/**\n * UTF-8 encoding strategy.\n */\nexport const Utf8 = {\n  /**\n   * Converts a word array to a UTF-8 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-8 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    try {\n      return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n    } catch (e) {\n      throw new Error('Malformed UTF-8 data');\n    }\n  },\n\n  /**\n   * Converts a UTF-8 string to a word array.\n   *\n   * @param {string} utf8Str The UTF-8 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n   */\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  },\n};\n\n/**\n * Abstract buffered block algorithm template.\n *\n * The property blockSize must be implemented in a concrete subtype.\n *\n * @property {number} _minBufferSize\n *\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\n */\nexport class BufferedBlockAlgorithm extends Base {\n  constructor() {\n    super();\n    this._minBufferSize = 0;\n  }\n\n  /**\n   * Resets this block algorithm's data buffer to its initial state.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm.reset();\n   */\n  reset() {\n    // Initial values\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n\n  /**\n   * Adds new data to this block algorithm's buffer.\n   *\n   * @param {WordArray|string} data\n   *\n   *     The data to append. Strings are converted to a WordArray using UTF-8.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm._append('data');\n   *     bufferedBlockAlgorithm._append(wordArray);\n   */\n  _append(data) {\n    let m_data = data;\n\n    // Convert string to WordArray, else assume WordArray already\n    if (typeof m_data === 'string') {\n      m_data = Utf8.parse(m_data);\n    }\n\n    // Append\n    this._data.concat(m_data);\n    this._nDataBytes += m_data.sigBytes;\n  }\n\n  /**\n   * Processes available data blocks.\n   *\n   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n   *\n   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n   *\n   * @return {WordArray} The processed data.\n   *\n   * @example\n   *\n   *     var processedData = bufferedBlockAlgorithm._process();\n   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n   */\n  _process(doFlush) {\n    let processedWords;\n\n    // Shortcuts\n    const { _data: data, blockSize } = this;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = blockSize * 4;\n\n    // Count blocks ready\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n\n    // Count words ready\n    const nWordsReady = nBlocksReady * blockSize;\n\n    // Count bytes ready\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n    // Process blocks\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      }\n\n      // Remove processed words\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    }\n\n    // Return processed words\n    return new WordArray(processedWords, nBytesReady);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = bufferedBlockAlgorithm.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone._data = this._data.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Abstract hasher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n */\nexport class Hasher extends BufferedBlockAlgorithm {\n  constructor(cfg) {\n    super();\n\n    this.blockSize = 512 / 32;\n\n    /**\n     * Configuration options.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates a shortcut function to a hasher's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to create a helper for.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHelper(SubHasher) {\n    return (message, cfg) => new SubHasher(cfg).finalize(message);\n  }\n\n  /**\n   * Creates a shortcut function to the HMAC's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHmacHelper(SubHasher) {\n    return (message, key) => new HMAC(SubHasher, key).finalize(message);\n  }\n\n  /**\n   * Resets this hasher to its initial state.\n   *\n   * @example\n   *\n   *     hasher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-hasher logic\n    this._doReset();\n  }\n\n  /**\n   * Updates this hasher with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {Hasher} This hasher.\n   *\n   * @example\n   *\n   *     hasher.update('message');\n   *     hasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    // Append\n    this._append(messageUpdate);\n\n    // Update the hash\n    this._process();\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @example\n   *\n   *     var hash = hasher.finalize();\n   *     var hash = hasher.finalize('message');\n   *     var hash = hasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Final message update\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n\n    // Perform concrete-hasher logic\n    const hash = this._doFinalize();\n\n    return hash;\n  }\n}\n\n/**\n * HMAC algorithm.\n */\nexport class HMAC extends Base {\n  /**\n   * Initializes a newly created HMAC.\n   *\n   * @param {Hasher} SubHasher The hash algorithm to use.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @example\n   *\n   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n   */\n  constructor(SubHasher, key) {\n    super();\n\n    const hasher = new SubHasher();\n    this._hasher = hasher;\n\n    // Convert string to WordArray, else assume WordArray already\n    let _key = key;\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    }\n\n    // Shortcuts\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\n\n    // Allow arbitrary length keys\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    }\n\n    // Clamp excess bits\n    _key.clamp();\n\n    // Clone key for inner and outer pads\n    const oKey = _key.clone();\n    this._oKey = oKey;\n    const iKey = _key.clone();\n    this._iKey = iKey;\n\n    // Shortcuts\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words;\n\n    // XOR keys with pad constants\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Resets this HMAC to its initial state.\n   *\n   * @example\n   *\n   *     hmacHasher.reset();\n   */\n  reset() {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Reset\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n\n  /**\n   * Updates this HMAC with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {HMAC} This HMAC instance.\n   *\n   * @example\n   *\n   *     hmacHasher.update('message');\n   *     hmacHasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    this._hasher.update(messageUpdate);\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the HMAC computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @example\n   *\n   *     var hmac = hmacHasher.finalize();\n   *     var hmac = hmacHasher.finalize('message');\n   *     var hmac = hmacHasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Compute HMAC\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n    return hmac;\n  }\n}\n","import {\n  WordArray,\n} from './core.js';\n\nconst parseLoop = (base64Str, base64StrLength, reverseMap) => {\n  const words = [];\n  let nBytes = 0;\n  for (let i = 0; i < base64StrLength; i += 1) {\n    if (i % 4) {\n      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n      const bitsCombined = bits1 | bits2;\n      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n      nBytes += 1;\n    }\n  }\n  return WordArray.create(words, nBytes);\n};\n\n/**\n * Base64 encoding strategy.\n */\nexport const Base64 = {\n  /**\n   * Converts a word array to a Base64 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Base64 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n    const map = this._map;\n\n    // Clamp excess bits\n    wordArray.clamp();\n\n    // Convert\n    const base64Chars = [];\n    for (let i = 0; i < sigBytes; i += 3) {\n      const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j += 1) {\n        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n      }\n    }\n\n    // Add padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      while (base64Chars.length % 4) {\n        base64Chars.push(paddingChar);\n      }\n    }\n\n    return base64Chars.join('');\n  },\n\n  /**\n   * Converts a Base64 string to a word array.\n   *\n   * @param {string} base64Str The Base64 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);\n   */\n  parse(base64Str) {\n    // Shortcuts\n    let base64StrLength = base64Str.length;\n    const map = this._map;\n    let reverseMap = this._reverseMap;\n\n    if (!reverseMap) {\n      this._reverseMap = [];\n      reverseMap = this._reverseMap;\n      for (let j = 0; j < map.length; j += 1) {\n        reverseMap[map.charCodeAt(j)] = j;\n      }\n    }\n\n    // Ignore padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      const paddingIndex = base64Str.indexOf(paddingChar);\n      if (paddingIndex !== -1) {\n        base64StrLength = paddingIndex;\n      }\n    }\n\n    // Convert\n    return parseLoop(base64Str, base64StrLength, reverseMap);\n  },\n\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n};\n","import {\n  Base,\n  WordArray,\n} from './core.js';\nimport { MD5Algo } from './md5.js';\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\nexport class EvpKDFAlgo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new Base(),\n      {\n        keySize: 128 / 32,\n        hasher: MD5Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    let block;\n\n    // Shortcut\n    const { cfg } = this;\n\n    // Init hasher\n    const hasher = cfg.hasher.create();\n\n    // Initial values\n    const derivedKey = WordArray.create();\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n\n      // Iterations\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);\n","/* eslint-disable no-use-before-define */\n\nimport {\n  Base,\n  WordArray,\n  BufferedBlockAlgorithm,\n} from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nexport class StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nexport class CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new Base(),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n","import {\n  BlockCipher,\n} from './cipher-core.js';\n\n// Lookup tables\nconst _SBOX = [];\nconst INV_SBOX = [];\nconst _SUB_MIX_0 = [];\nconst _SUB_MIX_1 = [];\nconst _SUB_MIX_2 = [];\nconst _SUB_MIX_3 = [];\nconst INV_SUB_MIX_0 = [];\nconst INV_SUB_MIX_1 = [];\nconst INV_SUB_MIX_2 = [];\nconst INV_SUB_MIX_3 = [];\n\n// Compute lookup tables\n\n// Compute double table\nconst d = [];\nfor (let i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = (i << 1) ^ 0x11b;\n  }\n}\n\n// Walk GF(2^8)\nlet x = 0;\nlet xi = 0;\nfor (let i = 0; i < 256; i += 1) {\n  // Compute sbox\n  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x;\n\n  // Compute multiplication\n  const x2 = d[x];\n  const x4 = d[x2];\n  const x8 = d[x4];\n\n  // Compute sub bytes, mix columns tables\n  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n  _SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n  _SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n  _SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n  _SUB_MIX_3[x] = t;\n\n  // Compute inv sub bytes, inv mix columns tables\n  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n  INV_SUB_MIX_3[sx] = t;\n\n  // Compute next counter\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n}\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n/**\n * AES block cipher algorithm.\n */\nexport class AESAlgo extends BlockCipher {\n  _doReset() {\n    let t;\n\n    // Skip reset of nRounds has been set before and key did not change\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    }\n\n    // Shortcuts\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4;\n\n    // Compute number of rounds\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds;\n\n    // Compute number of key schedule rows\n    const ksRows = (nRounds + 1) * 4;\n\n    // Compute key schedule\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = (t << 8) | (t >>> 24);\n\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n\n          // Mix Rcon\n          t ^= RCON[(ksRow / keySize) | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    }\n\n    // Compute inv key schedule\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]\n          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]\n          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]\n          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(\n      M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,\n    );\n  }\n\n  decryptBlock(M, offset) {\n    const _M = M;\n\n    // Swap 2nd and 4th rows\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(\n      _M,\n      offset,\n      this._invKeySchedule,\n      INV_SUB_MIX_0,\n      INV_SUB_MIX_1,\n      INV_SUB_MIX_2,\n      INV_SUB_MIX_3,\n      INV_SBOX,\n    );\n\n    // Inv swap 2nd and 4th rows\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n    const _M = M;\n\n    // Shortcut\n    const nRounds = this._nRounds;\n\n    // Get input, add round key\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3];\n\n    // Key schedule row counter\n    let ksRow = 4;\n\n    // Rounds\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24]\n        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s3 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24]\n        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s0 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24]\n        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s1 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24]\n        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s2 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n\n      // Update state\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    }\n\n    // Shift rows, sub bytes, add round key\n    const t0 = (\n      (SBOX[s0 >>> 24] << 24)\n        | (SBOX[(s1 >>> 16) & 0xff] << 16)\n        | (SBOX[(s2 >>> 8) & 0xff] << 8)\n        | SBOX[s3 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (\n      (SBOX[s1 >>> 24] << 24)\n        | (SBOX[(s2 >>> 16) & 0xff] << 16)\n        | (SBOX[(s3 >>> 8) & 0xff] << 8)\n        | SBOX[s0 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (\n      (SBOX[s2 >>> 24] << 24)\n        | (SBOX[(s3 >>> 16) & 0xff] << 16)\n        | (SBOX[(s0 >>> 8) & 0xff] << 8)\n        | SBOX[s1 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (\n      (SBOX[s3 >>> 24] << 24)\n        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n\n    // Set output\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n}\nAESAlgo.keySize = 256 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\nexport const AES = BlockCipher._createHelper(AESAlgo);\n","/**\n * Counter block mode.\n */\nimport {\n  BlockCipherMode,\n} from './cipher-core.js';\n\nexport class CTR extends BlockCipherMode {\n}\nCTR.Encryptor = class extends CTR {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let counter = this._counter;\n\n    // Generate keystream\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0);\n\n    // Increment counter\n    counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nCTR.Decryptor = CTR.Encryptor;\n","/**\n * A noop padding strategy.\n */\nexport const NoPadding = {\n  pad() {\n  },\n\n  unpad() {\n  },\n};\n","import { WordArray, Hex } from 'crypto-es/lib/core'\nimport { CipherParams } from 'crypto-es/lib/cipher-core'\nimport { AES } from 'crypto-es/lib/aes'\nimport { CTR } from 'crypto-es/lib/mode-ctr'\nimport { NoPadding } from 'crypto-es/lib/pad-nopadding'\nimport { formatIV } from '../../utils'\nimport Buffer from '../buffer'\n\nconst Crypto = {\n\n  decryptWordArray: function (raw, key, iv) {\n    const realKey = Hex.parse(key)\n\n    const realIV = Hex.parse(formatIV(iv))\n    const message = WordArray.create(new Uint8Array(raw))\n    const decryptWord = AES.decrypt(\n      CipherParams.create({\n        ciphertext: message\n      }),\n      realKey,\n      {\n        iv: realIV,\n        mode: CTR,\n        padding: NoPadding\n      }\n    )\n    return Crypto.wordArrayToUint8Array(decryptWord)\n  },\n  wordArrayToUint8Array: function (wordArray) {\n    const l = wordArray.sigBytes\n    const words = wordArray.words\n    const result = new Uint8Array(l)\n    let i = 0\n    let j = 0\n    while (true) {\n      if (i === l) { break }\n      const w = words[j++]\n      result[i++] = (w & 0xff000000) >>> 24\n      if (i === l) { break }\n      result[i++] = (w & 0x00ff0000) >>> 16\n      if (i === l) { break }\n      result[i++] = (w & 0x0000ff00) >>> 8\n      if (i === l) { break }\n      result[i++] = (w & 0x000000ff)\n    }\n    return result\n  },\n\n  decoderAESCTRData (videoTrack, audioTrack, customDescryptHandler) {\n    if (videoTrack.videoSenc) {\n      const key = videoTrack.kidValue\n      const senc = videoTrack.videoSenc\n      videoTrack.samples.forEach((item, index) => {\n        const sencBox = senc[index]\n        let encodeWord = item.data\n        const encodeBuffers = []\n        const decodeBuffers = []\n        const iv = sencBox.InitializationVector\n        if (sencBox.subsamples && sencBox.subsamples.length) {\n          sencBox.subsamples.forEach(function (value) {\n            const len = value.BytesOfClearData + value.BytesOfProtectedData\n            const sampleData = encodeWord.slice(0, len)\n            encodeBuffers.push(sampleData.slice(0, value.BytesOfClearData))\n            decodeBuffers.push(sampleData.slice(value.BytesOfClearData))\n            encodeWord = encodeWord.slice(len)\n          })\n        } else {\n          const len = item.size\n          encodeBuffers.push(encodeWord.slice(0, 0))\n          decodeBuffers.push(encodeWord.slice(0, len))\n          encodeWord = encodeWord.slice(len)\n        }\n        const tempBuffer = new Buffer()\n        tempBuffer.write(...decodeBuffers)\n        let decrypted = customDescryptHandler ? customDescryptHandler(tempBuffer.buffer, key, iv) : Crypto.decryptWordArray(tempBuffer.buffer, key, iv)\n        const buffer = new Buffer()\n        encodeBuffers.forEach((clearDataBuf, i) => {\n          const protectedDataLen = decodeBuffers[i].length\n          const decodeProtectedData = decrypted.slice(0, protectedDataLen)\n          buffer.write(clearDataBuf)\n          buffer.write(decodeProtectedData)\n          decrypted = decrypted.slice(protectedDataLen)\n        })\n        videoTrack.samples[index].data = buffer.buffer\n      })\n    }\n\n    if (audioTrack.audioSenc) {\n      const key = audioTrack.kidValue\n      const senc = audioTrack.audioSenc\n      audioTrack.samples.forEach((item, index) => {\n        const sencBox = senc[index]\n        const dec = customDescryptHandler ? customDescryptHandler(item.data, key, sencBox.InitializationVector) : Crypto.decryptWordArray(item.data, key, sencBox.InitializationVector)\n        audioTrack.samples[index].data = dec\n      })\n    }\n  }\n}\n\nexport default Crypto\n","import { VideoTrack, AudioTrack, MetadataTrack, AudioSample, VideoSample } from '../model'\nimport { readBig32 } from '../utils'\nimport { MP4Parser } from './mp4-parser'\nimport { Logger } from './logger'\nimport Crypto from './crypto/crypto'\nconst NEW_ARRAY_MAX_CNT = 20\nexport class MP4Demuxer {\n  _videoSamples = []\n  _audioSamples = []\n  _lastRemainBuffer = []\n  _lastRemainBufferStartPos = 0\n\n  constructor (videoSegmnents, audioSegmnents, metadataTrack, options) {\n    this.videoTrack = new VideoTrack()\n    this.audioTrack = new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this.log = new Logger('MP4Demuxer', options && options.openLog ? !options.openLog : true)\n\n    videoSegmnents && videoSegmnents.forEach(item => {\n      this._videoSamples.push(...item.frames)\n    })\n    audioSegmnents && audioSegmnents.forEach(item => {\n      this._audioSamples.push(...item.frames)\n    })\n  }\n\n  parseSamples (moov) {\n    if (!moov) {\n      throw new Error('moov is required')\n    }\n    if (!this.videoTrack.codec && !this.audioTrack.codec) {\n      MP4Parser.moovToTrack(moov, this.videoTrack, this.audioTrack)\n      this.videoSenc = this.videoTrack.videoSenc\n      this.audioSenc = this.audioTrack.audioSenc\n    }\n    if (!this._audioSamples.length && !this._videoSamples.length) {\n      const ret = MP4Parser.moovToSamples(moov)\n      if (!ret) throw new Error('cannot parse samples from moov box')\n      this._videoSamples = ret.videoSamples || []\n      this._audioSamples = ret.audioSamples || []\n    }\n  }\n\n  demux (data, dataStart, videoIndexRange, audioIndexRange, moov) {\n    this.parseSamples(moov)\n\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    let sample\n    let sampleData\n    let startByte\n    if (videoIndexRange) {\n      let frame\n      let nalSize = 0\n      for (let i = videoIndexRange[0], l = videoIndexRange[1]; i <= l; i++) {\n        sample = this._videoSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        startByte = sample.offset - dataStart\n        sampleData = data.subarray(startByte, startByte + sample.size)\n        frame = new VideoSample(sample.pts || sample.dts, sample.dts)\n        frame.duration = sample.duration\n        frame.gopId = sample.gopId\n        if (sample.keyframe) frame.setToKeyframe()\n        let start = 0\n        const len = sampleData.length - 1\n        while (start < len) {\n          nalSize = readBig32(sampleData, start)\n          start += 4\n          frame.units.push(sampleData.subarray(start, start + nalSize))\n          start += nalSize\n        }\n        videoTrack.samples.push(frame)\n      }\n\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioIndexRange) {\n      for (let i = audioIndexRange[0], l = audioIndexRange[1]; i <= l; i++) {\n        sample = this._audioSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        startByte = sample.offset - dataStart\n        sampleData = data.subarray(startByte, startByte + sample.size)\n        audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration))\n      }\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  demuxPart (data, dataStart, videoIndexRange, audioIndexRange, moov, useEME, kidValue, customDescryptHandler) {\n    this.parseSamples(moov)\n\n    this.videoTrack.useEME = useEME\n    this.audioTrack.useEME = useEME\n    // this.log.debug('[demuxPart start],dataStart,', dataStart, ',dataLen,', data.byteLength, ', lastRemain,', this._lastRemainBuffer ? this._lastRemainBuffer.byteLength : 0)\n    if (this._lastRemainBuffer && this._lastRemainBuffer.byteLength > 0 && dataStart > this._lastRemainBufferStartPos && dataStart <= this._lastRemainBufferStartPos + this._lastRemainBuffer.byteLength) {\n      let tryCnt = 0\n      while (tryCnt < NEW_ARRAY_MAX_CNT) {\n        try {\n          const buffer = this._lastRemainBuffer.subarray(0, dataStart - this._lastRemainBufferStartPos)\n          const temp = new Uint8Array(data.byteLength + buffer.byteLength)\n          temp.set(buffer, 0)\n          temp.set(new Uint8Array(data), buffer.byteLength)\n          data = temp\n          dataStart -= buffer.byteLength\n          this._lastRemainBuffer = null\n          this._lastRemainBufferStartPos = 0\n          // this.log.debug('[demuxPart add lastRemain],dataStart,', dataStart, ',dataLen,', data.byteLength)\n          break\n        } catch (e) {\n          if (tryCnt < NEW_ARRAY_MAX_CNT) {\n            tryCnt++\n          } else {\n            throw new Error('new Uint8Array error:,' + e.errorMessage)\n          }\n        }\n      }\n    }\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n    videoTrack.videoSenc = null\n    audioTrack.audioSenc = null\n\n    let sample\n    let sampleData\n    let startByte\n    let videoEndByte = 0\n    let audioEndByte = 0\n    if (this._videoSamples.length > 0 && videoIndexRange.length > 0) {\n      let frame\n      const end = data.byteLength + dataStart\n      for (let i = videoIndexRange[0]; i <= videoIndexRange[1]; i++) {\n        sample = this._videoSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        if (sample.offset >= dataStart && sample.offset + sample.size <= end) {\n          startByte = sample.offset - dataStart\n          videoEndByte = startByte + sample.size\n          sampleData = data.subarray(startByte, videoEndByte)\n          frame = new VideoSample(sample.pts || sample.dts, sample.dts)\n          frame.duration = sample.duration\n          // this.log.debug('[video !!!!!!!!],frame,index，', sample.index, ',segmentIdx', segmentIdx, ', dataStart,', dataStart, ',dataEnd', end, ',Samplestart,', sample.offset, ', SampleEnd,', sample.offset + sample.size, ',size,', sample.size, 'dts,', sample.dts, ',pts,', sample.pts, ', keyframe', sample.keyframe)\n          frame.gopId = sample.gopId\n          frame.sampleOffset = sample.index\n          // frame.timeOffset = sample.timeOffset || sample.timeOffset === 0 ? sample.timeOffset : null\n          if (sample.keyframe) frame.setToKeyframe()\n          frame.data = sampleData\n          frame.size = sample.size\n          // this.log.debug('[demux video frame],frame,index，', sample.index, ', size,', sampleData.byteLength, ', hash ', hashVal(sampleData.toString()))\n          videoTrack.samples.push(frame)\n        }\n      }\n      if (videoTrack.samples.length > 0) {\n        videoTrack.gopId = videoTrack.samples[0].gopId\n        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n        videoTrack.startPts = videoTrack.samples[0].pts / videoTrack.timescale\n        videoTrack.endPts = videoTrack.samples[videoTrack.samples.length - 1].pts / videoTrack.timescale\n        // this.log.debug('[demux video],frame,startPts，', videoTrack.startPts, ', endPts,', videoTrack.endPts)\n        if (this.videoSenc) {\n          videoTrack.videoSenc = this.videoSenc.slice(videoTrack.samples[0].sampleOffset, videoTrack.samples[0].sampleOffset + videoTrack.samples.length)\n          videoTrack.kidValue = kidValue\n        }\n      }\n    }\n    if (this._audioSamples.length > 0 && audioIndexRange.length > 0) {\n      for (let i = audioIndexRange[0]; i <= audioIndexRange[1]; i++) {\n        sample = this._audioSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        if (sample.offset >= dataStart && sample.offset + sample.size <= data.byteLength + dataStart) {\n          startByte = sample.offset - dataStart\n          audioEndByte = startByte + sample.size\n          sampleData = data.subarray(startByte, audioEndByte)\n          // this.log.debug('[audio !!!!!!!!],audio frame,index，', sample.index, ',segmentIdx', segmentIdx, ', Samplestart,', sample.offset, ', SampleEnd,', sample.offset + sample.size, ',size,', sample.size, 'dts,', sample.dts, ',pts,', sample.pts || sample.dts)\n          // frame.gopId = sample.gopId\n          // this.log.debug('[demux audio frame],index ,', sample.index, ', size,', sampleData.byteLength, ', hash,', hashVal(sampleData.toString()))\n          audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration, sample.index))\n        }\n      }\n      if (audioTrack.samples.length > 0) {\n        audioTrack.gopId = audioTrack.samples[0].gopId || videoTrack.gopId\n        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts\n        audioTrack.startPts = audioTrack.samples[0].pts / audioTrack.timescale\n        audioTrack.endPts = audioTrack.samples[audioTrack.samples.length - 1].pts / audioTrack.timescale\n        // this.log.debug('[demux audio],frame,startPts，', audioTrack.startPts, ', endPts,', audioTrack.endPts)\n        if (this.audioSenc) {\n          audioTrack.audioSenc = this.audioSenc.slice(audioTrack.samples[0].sampleOffset, audioTrack.samples[0].sampleOffset + audioTrack.samples.length)\n          audioTrack.kidValue = kidValue\n        }\n      }\n    }\n    this.decoderData(videoTrack, audioTrack, customDescryptHandler)\n    let nalSize = 0\n    for (let i = 0; i < videoTrack.samples.length; i++) {\n      let start = 0\n      const sampleData = videoTrack.samples[i].data\n      const len = sampleData.length - 1\n      while (start < len) {\n        nalSize = readBig32(sampleData, start)\n        start += 4\n        videoTrack.samples[i].units.push(sampleData.subarray(start, start + nalSize))\n        start += nalSize\n      }\n    }\n    this._lastRemainBuffer = data.subarray(Math.max(videoEndByte, audioEndByte))\n    if (this._lastRemainBuffer.byteLength > 0) {\n      this._lastRemainBufferStartPos = dataStart + data.byteLength - this._lastRemainBuffer.byteLength\n    } else {\n      this._lastRemainBufferStartPos = 0\n    }\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  reset () {\n    this._videoSamples = []\n    this._audioSamples = []\n    this._lastRemainBuffer = null\n    this._lastRemainBufferStartPos = 0\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n    this.metadataTrack.reset()\n  }\n\n  decoderData (videoTrack, audioTrack, customDescryptHandler) {\n    if (videoTrack.useEME || audioTrack.useEME) return\n    Crypto.decoderAESCTRData(videoTrack, audioTrack, customDescryptHandler)\n  }\n\n  static probe (data) {\n    return MP4Parser.probe(data)\n  }\n}\n","import { TrackType } from '../model'\nimport { MP4 } from './mp4'\nimport { concatUint8Array } from '../utils'\n\nexport class MP4Remuxer {\n  /**\n   * @param {import('../model').VideoTrack} videoTrack\n   * @param {import('../model').AudioTrack} audioTrack\n   */\n  constructor (videoTrack, audioTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n  }\n\n  /**\n   * @returns {import('./fmp4-remuxer').RemuxResult}\n   */\n  remux (videoTrack, audioTrack) {\n    this.videoTrack = videoTrack || this.videoTrack\n    this.audioTrack = audioTrack || this.audioTrack\n\n    const hasVideo = videoTrack?.exist() && videoTrack?.hasSample()\n    const hasAudio = audioTrack?.exist() && audioTrack?.hasSample()\n\n    let videoSegment\n    let audioSegment\n    if (hasVideo && hasAudio) {\n      videoSegment = this._remuxMix(videoTrack, audioTrack)\n    } else if (hasVideo) {\n      videoSegment = this._remuxTrack(videoTrack)\n    } else if (hasAudio) {\n      audioSegment = this._remuxTrack(audioTrack)\n    }\n\n    if (videoTrack) {\n      videoTrack.samples = []\n    }\n\n    if (audioTrack) {\n      audioTrack.samples = []\n    }\n\n    return {\n      videoSegment,\n      audioSegment\n    }\n  }\n\n  _remuxMix (videoTrack, audioTrack) {\n    const ftyp = MP4.ftyp([videoTrack, audioTrack])\n    const { mdatData: video, chunkOffset } = this._remuxData(videoTrack, ftyp.byteLength + 8)\n    const { mdatData: audio } = this._remuxData(audioTrack, chunkOffset)\n\n    const mdat = MP4.mdat(concatUint8Array(video, audio))\n    const moov = MP4.moovMP4([videoTrack, audioTrack])\n\n    videoTrack.ext = undefined\n    audioTrack.ext = undefined\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    return concatUint8Array(ftyp, mdat, moov)\n  }\n\n  _remuxTrack (track) {\n    const ftyp = MP4.ftyp([track])\n\n    const { mdatData } = this._remuxData(track, ftyp.byteLength + 8)\n    const mdat = MP4.mdat(mdatData)\n    const moov = MP4.moovMP4([track])\n\n    track.ext = undefined\n    track.samples = []\n\n    return concatUint8Array(ftyp, mdat, moov)\n  }\n\n  _remuxData (track, chunkOffset) {\n    const isVideo = track.type === TrackType.VIDEO\n    const samples = track.samples\n\n    let mdatSize = 0\n    if (isVideo) {\n      samples.forEach((s) => {\n        mdatSize += s.units.reduce((t, c) => (t + c.byteLength), 0)\n        mdatSize += (s.units.length * 4)\n      })\n    } else {\n      mdatSize = samples.reduce((t, c) => (t + c.size), 0)\n    }\n\n    const mdatData = new Uint8Array(mdatSize)\n    const mdatView = new DataView(mdatData.buffer)\n\n    const ext = track.ext = {\n      stts: [],\n      stsc: [],\n      stsz: [],\n      stco: [],\n      stss: [],\n      ctts: []\n    }\n\n    const samplesPerChunk = 1\n    let dataOffset = 0\n    let totalDuration = 0\n    let sample\n    const sampleLen = samples.length\n    for (let i = 0; i < sampleLen; i++) {\n      sample = samples[i]\n      totalDuration += sample.duration\n\n      let sampleSize = isVideo ? 0 : sample.size\n      if (isVideo) {\n        sample.units.forEach((u) => {\n          mdatView.setUint32(dataOffset, u.byteLength)\n          dataOffset += 4\n          mdatData.set(u, dataOffset)\n          dataOffset += u.byteLength\n          sampleSize += (4 + u.byteLength)\n        })\n      } else {\n        mdatData.set(sample.data, dataOffset)\n        dataOffset += sampleSize\n      }\n      sample.size = sampleSize\n      ext.stsz.push(sampleSize)\n\n      if (isVideo) this._fillCttsSamples(ext.ctts, sample.cts)\n      this._fillSttsSamples(ext.stts, sample, samples[i + 1])\n      this._fillStcoSamples(ext.stco, i, samplesPerChunk, chunkOffset)\n      chunkOffset += sampleSize\n\n      if (isVideo && sample.keyframe) {\n        ext.stss.push(i + 1)\n      }\n    }\n\n    track.duration = totalDuration\n    this._fillStscSamples(ext.stsc, sampleLen, samplesPerChunk)\n\n    return {\n      mdatData,\n      chunkOffset\n    }\n  }\n\n  _fillSttsSamples (sttsSamples, cur, next) {\n    const lastSample = sttsSamples[sttsSamples.length - 1]\n\n    if (next) {\n      if (!lastSample || lastSample.value !== cur.duration) {\n        sttsSamples.push({ value: cur.duration, count: 1 })\n      } else {\n        lastSample.count++\n      }\n      return\n    }\n\n    if (lastSample) {\n      lastSample.count++\n    } else {\n      sttsSamples.push({ value: 40, count: 1 })\n    }\n  }\n\n  _fillCttsSamples (cttsSamples, cts) {\n    const lastSample = cttsSamples[cttsSamples.length - 1]\n\n    if (!lastSample || lastSample.value !== cts) {\n      cttsSamples.push({ value: cts, count: 1 })\n    } else {\n      lastSample.count++\n    }\n  }\n\n  _fillStcoSamples (stcoSamples, index, samplePerChunk, chunkOffset) {\n    if (!(index % samplePerChunk)) {\n      stcoSamples.push(chunkOffset)\n    }\n  }\n\n  _fillStscSamples (samples, sampleCount, samplesPerChunk) {\n    if (sampleCount <= samplesPerChunk) {\n      samples.push({ firstChunk: 1, samplesPerChunk: sampleCount, sampleDescIndex: 1 })\n    } else {\n      const len = Math.floor(sampleCount / samplesPerChunk)\n      const remaining = sampleCount % samplesPerChunk\n      samples.push({ firstChunk: 1, samplesPerChunk, sampleDescIndex: 1 })\n      if (remaining) {\n        samples.push({ firstChunk: len + 1, samplesPerChunk: remaining, sampleDescIndex: 1 })\n      }\n    }\n  }\n}\n","import * as flv from './flv'\nimport * as mpegTs from './mpeg-ts'\nimport * as mp4 from './mp4'\nimport * as model from './model'\nimport { Logger } from './utils'\n\nexport default {\n  ...flv,\n  ...mpegTs,\n  ...mp4,\n  ...model,\n  Logger\n}\n"],"names":["TrackType","VIDEO","AUDIO","METADATA","VideoCodecType","AVC","HEVC","AudioCodecType","AAC","G711PCMA","G711PCMU","WarningType","LARGE_AV_SHIFT","LARGE_VIDEO_GAP","LARGE_VIDEO_GAP_BETWEEN_CHUNK","LARGE_AUDIO_GAP","AUDIO_FILLED","AUDIO_DROPPED","VideoTrack","_classCallCheck","_defineProperty","this","undefined","_createClass","key","value","sequenceNumber","width","height","fpsDen","fpsNum","duration","baseMediaDecodeTime","timescale","codec","present","pid","pps","sps","vps","sarRatio","samples","warnings","hvcC","length","get","isVideoEncryption","AudioTrack","sampleDuration","sampleRate","channelCount","config","codecType","isAudioEncryption","VideoSample","pts","dts","units","originPts","originDts","keyframe","flag","dependsOn","isNonSyncSample","AudioSample","data","sampleOffset","size","byteLength","Sample","FlvScriptSample","_Sample","_inherits","_super","_createSuper","apply","arguments","SeiSample","_Sample2","_super2","MetadataTrack","flvScriptSamples","seiSamples","ExpGolomb","Error","_data","_bytesAvailable","_loadWord","position","availableBytes","Math","min","workingBytes","Uint8Array","set","subarray","_word","DataView","buffer","getUint32","_bitsAvailable","count","skipBytes","floor","bits","val","readBits","leadingZeroCount","skipLZ","skipBits","clz","readUEG","lastScale","nextScale","j","readEG","Logger","name","_prefix","concat","_console","disabled","_len","args","Array","_key","console","warn","UTF8","uint8array","out","input","i","push","String","fromCharCode","_checkContinuation","ucs4","_ucs2","join","start","checkLength","array","isBrowser","window","ua","navigator","userAgent","toLocaleLowerCase","isSafari","test","isFirefox","includes","isAndroid","concatUint8Array","arr","filter","Boolean","reduce","p","c","prevLen","forEach","d","MAX_SIZE","pow","readBig16","readBig32","readBig64","getAvcCodec","codecs","h","toString","formatIV","iv","Number","slice","toUpperCase","bufferToString","len","parse","a","isArray","parseInt","map","item","NALu","end","offset","dataLen","unit","isHevc","type","uuid","payload","uint","emulationPreventionBytesPositions","newLength","newData","sourceIndex","shift","nalUnitSize","spsParsed","spsSize","spsArr","ppsArr","spsCount","parseSPS","removeEPB","ppsSize","ppsCount","eg","readUByte","profileIdc","profileCompatibility","levelIdc","skipUEG","chromaFormat","chromaFormatIdc","readBool","scalingListCount","skipScalingList","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","fixedFrame","fps","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","aspectRatioIdc","numUnitsInTick","timeScale","ceil","rate","FREQ","indexOf","skip","frames","samplingFrequencyIndex","protectionSkipBytes","frameLength","objectType","_AAC$_getConfig","_getConfig","frameIndex","getFrameDuration","remaining","originCodec","_AAC$_getConfig2","samplingIndex","originObjectType","extensionSamplingIndex","vpsParsed","nalUnitType","numNalus","nalSize","vpsArr","numOfArrays","parseVPS","vpsMaxSubLayersMinus1","numTemporalLayers","max","_parseProfileTierLevel","spsMaxSubLayersMinus1","temporalIdNested","separateColourPlaneFlag","confWinLeftOffset","confWinRightOffset","confWinTopOffset","confWinBottomOffset","conformanceWindowFlag","bitDepthLumaMinus8","bitDepthChromaMinus8","subWidthC","subHeightC","maxSubLayersMinus1","generalTierFlag","generalProfileSpace","generalProfileIdc","generalProfileCompatibilityFlags","generalConstraintIndicatorFlags","generalLevelIdc","subLayerProfilePresentFlag","subLayerLevelPresentFlag","MAX_SILENT_FRAME_DURATION","AUDIO_EXCETION_LOG_EMIT_DURATION","FlvFixer","videoTrack","audioTrack","metadataTrack","_baseDts","_baseDtsInited","_audioNextPts","_videoNextDts","_audioTimestampBreak","_videoTimestampBreak","_lastVideoDuration","_keyFrameInNextChunk","_lastAudioExceptionGapDot","Infinity","_lastAudioExceptionOverlapDot","_lastAudioExceptionLargeGapDot","_lastVideoExceptionLargeGapDot","_lastVideoExceptionChunkFirstDtsDot","_this","startTime","discontinuity","contiguous","round","_videoLastSample","_calculateBaseDts","resetBaseDts","exist","_resetBaseDtsWhenStreamBreaked","_fixAudio","_fixVideo","s","time","_this2","refSampleDurationInt","x","first","last","lastSample","pop","unshift","samp0","firstSample","vDelta","abs","_samples$","nextDts","firstSampleDts","nextSampleDts","nextSample","refSampleDuration","_this3","_doFixAudioInternal","audioSamps","videoSamps","audioBasePts","videoBaseDts","baseDts","delta","isFinite","_getG711Duration","sampleDurationInSampleRate","nextPts","sample","silentFrame","_getSilentFrame","silentSample","splice","track","sampleSize","getSilentFrame","AMF","ret","_parseValue","byteOffset","view","isEnd","getUint8","getFloat64","_AMF$_parseString","_parseString","terminal","_AMF$_parseObject","_parseObject","_terminal","_AMF$_parseObject2","strictArrayLength","_AMF$_parseValue","timestamp","getInt16","Date","decode","getUint16","logger","FlvDemuxer","_fixer","_remainingData","_headerParsed","reset","probe","tagType","dataSize","bodyData","prevTagSize","_parseAudio","_parseVideo","_parseScript","formatTimescale","hasSample","fix","demux","format","soundRate","soundSize","soundType","AUDIO_RATE","_parseAac","_parseG711","parseAudioSpecificConfig","sampleRateIndex","frameType","codecId","packetType","cts","configData","parseHEVCDecoderConfigurationRecord","parseAVCDecoderConfigurationRecord","parseAvcC","_checkAddMetaNalToUnits","setToKeyframe","parseSEI","_gopId","gopId","hevc","_needAddMetaBeforeKeyFrameNal","MAX_VIDEO_FRAME_DURATION","TsFixer","vSamples","aSamples","firstVideoSample","firstAudioSample","vaDelta","vDeltaToNextDts","aDeltaToNextDts","expectFragEnd","_audioLastSample","TsDemuxer","_pmtId","_remainingPacketData","_videoPesData","_audioPesData","remainingLength","videoPid","audioPid","payloadUnitStartIndicator","adaptationFiledControl","tableEnd","programInfoLength","esPid","_parseVideoData","_parseAudioData","pes","_parsePES","_toConsumableArray","parseAnnexB","_createVideoSample","spsInfo","_pushVideoSample","_parseAacData","_track$samples","parseADTS","headerDataLen","pesLen","ptsDtsFlags","MP4Parser","names","headerSize","subData","findBox","box","parseBox","trackId","baseDataOffsetPresent","flags","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","baseDataOffset","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","reference_ID","version","earliest_presentation_time","first_offset","references","ref","tmp32","reference_type","referenced_size","subsegment_duration","starts_with_SAP","SAP_type","SAP_delta_time","mvhd","trak","pssh","nextTrackId","tkhd","mdia","mdhd","hdlr","minf","lang","language","handlerType","vmhd","smhd","stbl","graphicsmode","opcolor","balance","_ret$stsd$entries$","_ret$stsd$entries$$si","_ret$stsd$entries$$si2","stsd","stts","ctts","stsc","stsz","stco","co64","default_IV_size","entries","sinf","schi","tenc","stss","senc","sampleCount","InitializationVector","subsamples","subsampleCount","subsample","BytesOfClearData","BytesOfProtectedData","keyIds","systemId","toHex","numKeyIds","keyId","data_size","kid","system_id","entryCount","b","avc1","hvc1","mp4a","alaw","samplesize","esds","horizresolution","vertresolution","avcC","pasp","default_IsEncrypted","default_KID","frma","data_format","bodyStart","parseVisualSampleEntry","configurationVersion","AVCProfileIndication","AVCLevelIndication","lengthSizeMinusOne","spsLength","ppsLength","tmp","generalProfileCompatibility","avgFrameRate","_ret$vps","nalus","_ret$sps","_ret$pps","hSpacing","vSpacing","parseAudioSampleEntry","byteRead","tag","substring","padStart","firstChunk","samplesPerChunk","entrySizes","mfhd","traf","t","tfhd","tfdt","trun","dataOffset","firstSampleFlags","isLeading","isDependedOn","hasRedundancy","paddingValue","degradationPriority","moov","_e$esds","_e$esds2","tracks","vTrack","find","_t$mdia","_t$mdia$hdlr","aTrack","_t$mdia2","_t$mdia2$hdlr","_vTrack$tkhd","_vTrack$mdia","_vTrack$mdia$minf","_vTrack$mdia$minf$stb","_vTrack$mdia2","_vTrack$mdia2$minf","_vTrack$mdia2$minf$st","v","_vTrackId","id","tkhdDuration","mvhdDurtion","mvhdTimecale","_e1$sinf","_e1$sinf$schi","_e1$sinf2","_e1$sinf2$schi","_e1$sinf3","_e1$sinf3$schi","_e1$sinf4","_e1$sinf4$frma","e1","ext","videoSenc","useEME","kidValue","encv","_aTrack$tkhd","_e$esds3","_e$esds4","_aTrack$mdia","_aTrack$mdia$minf","_aTrack$mdia$minf$stb","_aTrack$mdia2","_aTrack$mdia2$minf","_aTrack$mdia2$minf$st","_aTrackId","_e$sinf","_e$sinf$frma","_e$sinf2","_e$sinf2$schi","_e$sinf3","_e$sinf3$schi","_e$sinf4","_e$sinf4$schi","getRateIndexByRate","from","audioSenc","enca","_videoTrack$encv","_audioTrack$enca","vkid","akid","videoSampleCount","_audioTrack$samples","audioSampleCount","moof","_ref","defaultSize","defaultDuration","evaluateDefaultDuration","index","_t$mdia3","_t$mdia3$hdlr","_t$mdia4","_t$mdia4$hdlr","videoSamples","audioSamples","_vTrack$mdia3","_vTrack$mdia3$minf","videoStbl","getSamples","_aTrack$mdia3","_aTrack$mdia3$minf","_aTrack$mdia$mdhd","audioStbl","keyframeMap","cttsArr","cttsEntries","stscEntries","stcoEntries","stszEntrySizes","stssEntries","_ref2","pos","chunkIndex","chunkRunIndex","offsetInChunk","lastSampleInChunk","lastChunkInRun","_ref3","dataReferenceIndex","frameCount","depth","isFullBox","readBig24","str","pad","charstr","maxlen","chars","r","hex","FMP4Demuxer","videoData","audioData","videoExist","audioExist","moovBox","moovToTrack","moofBox","moofToSamples","baseOffset","sampleData","videoBaseMediaDecodeTime","audioBaseMediaDecodeTime","Object","keys","k","Concat","ResultConstructor","totalLength","arrays","result","Buffer","self","_len2","_key2","UINT32_MAX","MP4","FTYPHEV1","FTYPAVC1","init","ftyp","content","types","mvex","HDLR_TYPES","VMHD","SMHD","DINF","extBox","STTS","STSC","STSZ","STCO","avc1hev1","_concat$concat","avcc","btrt","charCodeAt","schm","typ","boxes","fiel","_concat$concat2","ArrayBuffer","pcf","cif","write","_ref4","_slicedToArray","trex","sencLength","isVideo","videoSencLength","saiz","saio","trun1","sbgp","sdtp","extension","writeUint32","samplesLength","writeUint16","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","sampleLen","_samples$i","_samples$i$flag","_samples$i$cts","trackMP4","mdiaMP4","minfMP4","stblMP4","_ref5","_ref6","sampleDescIndex","samplesSizes","offsets","keyframeIndexes","_ref7","styp","durationCount","earliestTime","mdatSize","sidx","mdat","create","video","audio","dinf","dref","StblTable","enable","debug","_console2","log","_console3","_len3","_key3","_console4","_len4","_key4","error","_console5","group","table","groupEnd","FMP4Remuxer","options","browserVersions","exec","forceFirstIDR","openLog","createInit","videoInitSegment","audioInitSegment","initSegment","videoSegment","audioSegment","hasVideo","hasAudio","initMerge","_remuxVideo","_remuxAudio","mdata","mdatView","_loop","_offset","_sample","u","setUint32","l","Base","properties","assign","clone","constructor","_construct","WordArray","_Base","words","sigBytes","call","typedArray","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","typedArrayByteLength","_words","encoder","Hex","stringify","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","_get","_getPrototypeOf","prototype","nBytes","rcache","m_w","_m_w","_m_z","mask","random","_r","hexChars","bite","hexStr","hexStrLength","substr","Latin1","latin1Str","latin1StrLength","Utf8","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","_Base2","_minBufferSize","_nDataBytes","m_data","doFlush","processedWords","blockSize","dataWords","dataSigBytes","nBlocksReady","nWordsReady","nBytesReady","_doProcessBlock","Hasher","_BufferedBlockAlgorit","_super3","cfg","_doReset","messageUpdate","_append","_process","hash","_doFinalize","SubHasher","message","finalize","HMAC","_Base3","_super4","_this4","hasher","_hasher","hasherBlockSize","hasherBlockSizeBytes","oKey","_oKey","iKey","_iKey","oKeyWords","iKeyWords","update","innerHash","hmac","Base64","_map","base64Chars","triplet","charAt","paddingChar","base64Str","base64StrLength","reverseMap","_reverseMap","paddingIndex","parseLoop","bits1","bitsCombined","T","sin","FF","n","GG","HH","II","MD5Algo","_Hasher","_hash","M","_M","offset_i","M_offset_i","H","M_offset_0","M_offset_1","M_offset_2","M_offset_3","M_offset_4","M_offset_5","M_offset_6","M_offset_7","M_offset_8","M_offset_9","M_offset_10","M_offset_11","M_offset_12","M_offset_13","M_offset_14","M_offset_15","nBitsTotal","nBitsLeft","nBitsTotalH","nBitsTotalL","H_i","_createHelper","_createHmacHelper","EvpKDFAlgo","keySize","iterations","password","salt","derivedKeyWords","block","derivedKey","Cipher","xformMode","_xformMode","dataUpdate","finalProcessedData","_ENC_XFORM_MODE","_DEC_XFORM_MODE","SubCipher","selectCipherStrategy","PasswordBasedCipher","SerializableCipher","encrypt","decrypt","ciphertext","ivSize","BlockCipherMode","cipher","_cipher","_iv","Encryptor","Decryptor","xorBlock","_prevBlock","CBC","_BlockCipherMode","_CBC","_class","_super5","encryptBlock","_CBC2","_class2","_super6","thisBlock","decryptBlock","Pkcs7","blockSizeBytes","nPaddingBytes","paddingWord","paddingWords","padding","unpad","BlockCipher","_Cipher2","_super7","mode","modeCreator","createEncryptor","createDecryptor","_mode","__creator","processBlock","finalProcessedBlocks","CipherParams","_super8","cipherParams","_this5","mixIn","formatter","OpenSSLFormatter","openSSLStr","ciphertextWords","_super9","_cfg","encryptor","cipherCfg","algorithm","_ciphertext","plaintext","_parse","OpenSSLKdf","execute","_salt","compute","_SerializableCipher","_super10","derivedParams","kdf","_SBOX","INV_SBOX","_SUB_MIX_0","_SUB_MIX_1","_SUB_MIX_2","_SUB_MIX_3","INV_SUB_MIX_0","INV_SUB_MIX_1","INV_SUB_MIX_2","INV_SUB_MIX_3","xi","sx","x2","x4","x8","RCON","AESAlgo","_BlockCipher","_nRounds","_keyPriorReset","keyWords","ksRows","_keySchedule","keySchedule","ksRow","_invKeySchedule","invKeySchedule","invKsRow","_doCryptBlock","SUB_MIX_0","SUB_MIX_1","SUB_MIX_2","SUB_MIX_3","SBOX","nRounds","s0","s1","s2","s3","t0","t1","t2","t3","AES","CTR","_CTR","counter","_counter","keystream","NoPadding","Crypto","decryptWordArray","raw","realKey","realIV","decryptWord","wordArrayToUint8Array","w","decoderAESCTRData","customDescryptHandler","sencBox","encodeWord","encodeBuffers","decodeBuffers","tempBuffer","decrypted","clearDataBuf","protectedDataLen","decodeProtectedData","dec","MP4Demuxer","videoSegmnents","audioSegmnents","_this$_videoSamples","_videoSamples","_this$_audioSamples","_audioSamples","moovToSamples","dataStart","videoIndexRange","audioIndexRange","parseSamples","startByte","frame","_lastRemainBuffer","_lastRemainBufferStartPos","tryCnt","temp","e","errorMessage","videoEndByte","audioEndByte","startPts","endPts","decoderData","MP4Remuxer","_remuxMix","_remuxTrack","_this$_remuxData","_remuxData","mdatData","chunkOffset","moovMP4","totalDuration","_fillCttsSamples","_fillSttsSamples","_fillStcoSamples","_fillStscSamples","sttsSamples","cur","next","cttsSamples","stcoSamples","samplePerChunk","_objectSpread","flv","mpegTs","mp4","model"],"mappings":"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"}