import { createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
import { readBig32 } from "../utils/index.js";
var NALu = /* @__PURE__ */ function() {
  function NALu2() {
    _classCallCheck(this, NALu2);
  }
  _createClass(NALu2, null, [{
    key: "parseAnnexB",
    value: function parseAnnexB(data) {
      var len = data.length;
      var start = 2;
      var end = 0;
      while (data[start] !== null && data[start] !== void 0 && data[start] !== 1) {
        start++;
      }
      start++;
      end = start + 2;
      if (end >= len)
        return [];
      var units = [];
      while (end < len) {
        switch (data[end]) {
          case 0:
            if (data[end - 1] !== 0) {
              end += 2;
              break;
            } else if (data[end - 2] !== 0) {
              end++;
              break;
            }
            if (start !== end - 2)
              units.push(data.subarray(start, end - 2));
            do {
              end++;
            } while (data[end] !== 1 && end < len);
            start = end + 1;
            end = start + 2;
            break;
          case 1:
            if (data[end - 1] !== 0 || data[end - 2] !== 0) {
              end += 3;
              break;
            }
            if (start !== end - 2)
              units.push(data.subarray(start, end - 2));
            start = end + 1;
            end = start + 2;
            break;
          default:
            end += 3;
            break;
        }
      }
      if (start < len)
        units.push(data.subarray(start));
      return units;
    }
  }, {
    key: "parseAvcC",
    value: function parseAvcC(data) {
      var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
      if (data.length < 4)
        return;
      var dataLen = data.length;
      var units = [];
      var offset = 0;
      var length;
      while (offset + size < dataLen) {
        length = readBig32(data, offset);
        if (size === 3)
          length >>>= 8;
        offset += size;
        if (!length)
          continue;
        if (offset + length > dataLen) {
          break;
        }
        units.push(data.subarray(offset, offset + length));
        offset += length;
      }
      return units;
    }
  }, {
    key: "parseSEI",
    value: function parseSEI(unit, isHevc) {
      var len = unit.length;
      var i = isHevc ? 2 : 1;
      var type = 0;
      var size = 0;
      var uuid = "";
      while (unit[i] === 255) {
        type += 255;
        i++;
      }
      type += unit[i++];
      while (unit[i] === 255) {
        size += 255;
        i++;
      }
      size += unit[i++];
      if (type === 5 && len > i + 16) {
        for (var j = 0; j < 16; j++) {
          uuid += unit[i].toString(16);
          i++;
        }
      }
      return {
        payload: unit.subarray(i),
        type,
        size,
        uuid
      };
    }
  }, {
    key: "removeEPB",
    value: function removeEPB(uint) {
      var length = uint.byteLength;
      var emulationPreventionBytesPositions = [];
      var i = 1;
      while (i < length - 2) {
        if (uint[i] === 0 && uint[i + 1] === 0 && uint[i + 2] === 3) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (!emulationPreventionBytesPositions.length)
        return uint;
      var newLength = length - emulationPreventionBytesPositions.length;
      var newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = uint[sourceIndex];
      }
      return newData;
    }
  }]);
  return NALu2;
}();
export { NALu };
