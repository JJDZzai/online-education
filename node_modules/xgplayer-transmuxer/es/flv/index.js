import { defineProperty as _defineProperty, createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
import { VideoTrack } from "../model/video-track.js";
import { AudioTrack } from "../model/audio-track.js";
import { VideoSample } from "../model/video-sample.js";
import { AudioSample } from "../model/audio-sample.js";
import { MetadataTrack, SeiSample, FlvScriptSample } from "../model/metadata-track.js";
import { AudioCodecType, VideoCodecType } from "../model/types.js";
import { FlvFixer } from "./fixer.js";
import { readBig32, concatUint8Array } from "../utils/index.js";
import { AVC } from "../codec/avc.js";
import { AAC } from "../codec/aac.js";
import { HEVC } from "../codec/hevc.js";
import { NALu } from "../codec/nalu.js";
import { AMF } from "./amf.js";
import { Logger } from "../utils/logger.js";
var logger = new Logger("FlvDemuxer");
var FlvDemuxer = /* @__PURE__ */ function() {
  function FlvDemuxer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck(this, FlvDemuxer2);
    _defineProperty(this, "_headerParsed", false);
    _defineProperty(this, "_remainingData", null);
    _defineProperty(this, "_gopId", 0);
    _defineProperty(this, "_needAddMetaBeforeKeyFrameNal", true);
    this.videoTrack = videoTrack || new VideoTrack();
    this.audioTrack = audioTrack || new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
    this._fixer = new FlvFixer(this.videoTrack, this.audioTrack, this.metadataTrack);
  }
  _createClass(FlvDemuxer2, [{
    key: "demux",
    value: function demux(data) {
      var discontinuity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var contiguous = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var audioTrack = this.audioTrack, videoTrack = this.videoTrack, metadataTrack = this.metadataTrack;
      if (discontinuity || !contiguous) {
        this._remainingData = null;
        this._headerParsed = false;
      }
      if (discontinuity) {
        videoTrack.reset();
        audioTrack.reset();
        metadataTrack.reset();
      } else {
        videoTrack.samples = [];
        audioTrack.samples = [];
        metadataTrack.seiSamples = [];
        metadataTrack.flvScriptSamples = [];
        videoTrack.warnings = [];
        audioTrack.warnings = [];
        if (this._remainingData) {
          data = concatUint8Array(this._remainingData, data);
          this._remainingData = null;
        }
      }
      if (!data.length) {
        return {
          videoTrack,
          audioTrack,
          metadataTrack
        };
      }
      var offset = 0;
      if (!this._headerParsed) {
        if (!FlvDemuxer2.probe(data)) {
          throw new Error("Invalid flv file");
        }
        audioTrack.present = (data[4] & 4) >>> 2 !== 0;
        videoTrack.present = (data[4] & 1) !== 0;
        this._headerParsed = true;
        offset = readBig32(data, 5) + 4;
      }
      var dataLen = data.length;
      var tagType;
      var dataSize;
      var timestamp;
      var bodyData;
      var prevTagSize;
      while (offset + 15 < dataLen) {
        tagType = data[offset];
        dataSize = data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
        if (offset + 15 + dataSize > dataLen)
          break;
        timestamp = (data[offset + 7] << 24 >>> 0) + (data[offset + 4] << 16) + (data[offset + 5] << 8) + data[offset + 6];
        offset += 11;
        bodyData = data.subarray(offset, offset + dataSize);
        if (tagType === 8) {
          this._parseAudio(bodyData, timestamp);
        } else if (tagType === 9) {
          this._parseVideo(bodyData, timestamp);
        } else if (tagType === 18) {
          this._parseScript(bodyData, timestamp);
        } else {
          logger.warn("Invalid tag type: ".concat(tagType));
        }
        offset += dataSize;
        prevTagSize = readBig32(data, offset);
        if (prevTagSize !== 11 + dataSize) {
          logger.warn("Invalid PrevTagSize ".concat(prevTagSize, " (").concat(11 + dataSize, ")"));
        }
        offset += 4;
      }
      if (offset < dataLen) {
        this._remainingData = data.subarray(offset);
      }
      audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 1e3;
      audioTrack.timescale = audioTrack.sampleRate || 0;
      if (!audioTrack.exist() && audioTrack.hasSample()) {
        audioTrack.reset();
      }
      if (!videoTrack.exist() && videoTrack.hasSample()) {
        videoTrack.reset();
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack
      };
    }
  }, {
    key: "fix",
    value: function fix(startTime, discontinuity, contiguous) {
      this._fixer.fix(startTime, discontinuity, contiguous);
      return {
        videoTrack: this.videoTrack,
        audioTrack: this.audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "demuxAndFix",
    value: function demuxAndFix(data, discontinuity, contiguous, startTime) {
      this.demux(data, discontinuity, contiguous);
      return this.fix(startTime, discontinuity, contiguous);
    }
  }, {
    key: "_parseAudio",
    value: function _parseAudio(data, pts) {
      if (!data.length)
        return;
      var format = (data[0] & 240) >>> 4;
      var track = this.audioTrack;
      if (format !== 10 && format !== 7 && format !== 8) {
        logger.warn("Unsupported sound format: ".concat(format));
        track.reset();
        return;
      }
      if (format !== 10) {
        var soundRate = (data[0] & 12) >> 2;
        var soundSize = (data[0] & 2) >> 1;
        var soundType = data[0] & 1;
        track.sampleRate = FlvDemuxer2.AUDIO_RATE[soundRate];
        track.sampleSize = soundSize ? 16 : 8;
        track.channelCount = soundType + 1;
      }
      if (format === 10) {
        this._parseAac(data, pts);
      } else {
        this._parseG711(data, pts, format);
      }
    }
  }, {
    key: "_parseG711",
    value: function _parseG711(data, pts, format) {
      var track = this.audioTrack;
      track.codecType = format === 7 ? AudioCodecType.G711PCMA : AudioCodecType.G711PCMU;
      track.sampleRate = 8e3;
      track.codec = track.codecType;
      track.samples.push(new AudioSample(pts, data.subarray(1)));
    }
  }, {
    key: "_parseAac",
    value: function _parseAac(data, pts) {
      var track = this.audioTrack;
      track.codecType = AudioCodecType.AAC;
      if (data[1] === 0) {
        var ret = AAC.parseAudioSpecificConfig(data.subarray(2));
        if (ret) {
          track.codec = ret.codec;
          track.channelCount = ret.channelCount;
          track.sampleRate = ret.sampleRate;
          track.config = ret.config;
          track.objectType = ret.objectType;
          track.sampleRateIndex = ret.samplingFrequencyIndex;
        } else {
          track.reset();
          logger.warn("Cannot parse AudioSpecificConfig", data);
        }
      } else if (data[1] === 1) {
        if (pts === void 0 || pts === null)
          return;
        track.samples.push(new AudioSample(pts, data.subarray(2)));
      } else {
        logger.warn("Unknown AACPacketType: ".concat(data[1]));
      }
    }
  }, {
    key: "_parseVideo",
    value: function _parseVideo(data, dts) {
      var _this = this;
      if (data.length < 6)
        return;
      var frameType = (data[0] & 240) >>> 4;
      var codecId = data[0] & 15;
      var track = this.videoTrack;
      if (codecId !== 7 && codecId !== 12) {
        track.reset();
        logger.warn("Unsupported codecId: ".concat(codecId));
        return;
      }
      var isHevc = codecId === 12;
      track.codecType = isHevc ? VideoCodecType.HEVC : VideoCodecType.AVC;
      var packetType = data[1];
      var cts = (data[2] << 16 | data[3] << 8 | data[4]) << 8 >> 8;
      if (packetType === 0) {
        var configData = data.subarray(5);
        var ret = isHevc ? HEVC.parseHEVCDecoderConfigurationRecord(configData) : AVC.parseAVCDecoderConfigurationRecord(configData);
        if (ret) {
          var hvcC = ret.hvcC, sps = ret.sps, ppsArr = ret.ppsArr, spsArr = ret.spsArr, vpsArr = ret.vpsArr, nalUnitSize = ret.nalUnitSize;
          if (hvcC) {
            track.hvcC = track.hvcC || hvcC;
          }
          if (sps) {
            track.codec = sps.codec;
            track.width = sps.width;
            track.height = sps.height;
            track.sarRatio = sps.sarRatio;
            track.fpsNum = sps.fpsNum;
            track.fpsDen = sps.fpsDen;
          }
          if (spsArr.length)
            track.sps = spsArr;
          if (ppsArr.length)
            track.pps = ppsArr;
          if (vpsArr && vpsArr.length)
            track.vps = vpsArr;
          if (nalUnitSize)
            track.nalUnitSize = nalUnitSize;
        } else {
          logger.warn("Cannot parse ".concat(isHevc ? "HEVC" : "AVC", "DecoderConfigurationRecord"), data);
        }
      } else if (packetType === 1) {
        var units = NALu.parseAvcC(data.subarray(5), track.nalUnitSize);
        units = this._checkAddMetaNalToUnits(isHevc, units, track);
        if (units && units.length) {
          var sample = new VideoSample(dts + cts, dts, units);
          if (frameType === 1) {
            sample.setToKeyframe();
          }
          track.samples.push(sample);
          units.forEach(function(unit) {
            var type = isHevc ? unit[0] >>> 1 & 63 : unit[0] & 31;
            switch (type) {
              case 5:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 22:
              case 23:
                if (!isHevc && type !== 5 || isHevc && type === 5)
                  break;
                sample.setToKeyframe();
                break;
              case 6:
              case 39:
              case 40:
                if (!isHevc && type !== 6 || isHevc && type === 6)
                  break;
                _this.metadataTrack.seiSamples.push(new SeiSample(NALu.parseSEI(NALu.removeEPB(unit), isHevc), dts + cts));
                break;
            }
          });
          if (sample.keyframe) {
            this._gopId++;
          }
          sample.gopId = this._gopId;
        } else {
          logger.warn("Cannot parse NALUs", data);
        }
      } else if (packetType === 2)
        ;
      else {
        logger.warn("Unknown AVCPacketType: ".concat(packetType));
      }
    }
  }, {
    key: "_checkAddMetaNalToUnits",
    value: function _checkAddMetaNalToUnits(hevc, units, track) {
      if (!hevc || !this._needAddMetaBeforeKeyFrameNal) {
        this._needAddMetaBeforeKeyFrameNal = false;
        return units;
      }
      var nalTypes = units.map(function(x) {
        return x[0] >>> 1 & 63;
      });
      if (nalTypes.includes(32)) {
        this._needAddMetaBeforeKeyFrameNal = false;
        return units;
      }
      units.unshift(track.pps[0]);
      units.unshift(track.sps[0]);
      units.unshift(track.vps[0]);
      return units.filter(Boolean);
    }
  }, {
    key: "_parseScript",
    value: function _parseScript(data, pts) {
      this.metadataTrack.flvScriptSamples.push(new FlvScriptSample(AMF.parse(data), pts));
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      if (data[0] !== 70 || data[1] !== 76 || data[2] !== 86 || data[3] !== 1) {
        return false;
      }
      return readBig32(data, 5) >= 9;
    }
  }]);
  return FlvDemuxer2;
}();
_defineProperty(FlvDemuxer, "AUDIO_RATE", [5500, 11e3, 22e3, 44e3]);
export { FlvDemuxer };
