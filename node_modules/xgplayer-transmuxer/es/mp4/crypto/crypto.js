import { Hex, WordArray } from "crypto-es/lib/core";
import { CipherParams } from "crypto-es/lib/cipher-core";
import { AES } from "crypto-es/lib/aes";
import { CTR } from "crypto-es/lib/mode-ctr";
import { NoPadding } from "crypto-es/lib/pad-nopadding";
import { formatIV } from "../../utils/index.js";
import Buffer from "../buffer.js";
var Crypto = {
  decryptWordArray: function decryptWordArray(raw, key, iv) {
    var realKey = Hex.parse(key);
    var realIV = Hex.parse(formatIV(iv));
    var message = WordArray.create(new Uint8Array(raw));
    var decryptWord = AES.decrypt(CipherParams.create({
      ciphertext: message
    }), realKey, {
      iv: realIV,
      mode: CTR,
      padding: NoPadding
    });
    return Crypto.wordArrayToUint8Array(decryptWord);
  },
  wordArrayToUint8Array: function wordArrayToUint8Array(wordArray) {
    var l = wordArray.sigBytes;
    var words = wordArray.words;
    var result = new Uint8Array(l);
    var i = 0;
    var j = 0;
    while (true) {
      if (i === l) {
        break;
      }
      var w = words[j++];
      result[i++] = (w & 4278190080) >>> 24;
      if (i === l) {
        break;
      }
      result[i++] = (w & 16711680) >>> 16;
      if (i === l) {
        break;
      }
      result[i++] = (w & 65280) >>> 8;
      if (i === l) {
        break;
      }
      result[i++] = w & 255;
    }
    return result;
  },
  decoderAESCTRData: function decoderAESCTRData(videoTrack, audioTrack, customDescryptHandler) {
    if (videoTrack.videoSenc) {
      var key = videoTrack.kidValue;
      var senc = videoTrack.videoSenc;
      videoTrack.samples.forEach(function(item, index) {
        var sencBox = senc[index];
        var encodeWord = item.data;
        var encodeBuffers = [];
        var decodeBuffers = [];
        var iv = sencBox.InitializationVector;
        if (sencBox.subsamples && sencBox.subsamples.length) {
          sencBox.subsamples.forEach(function(value) {
            var len2 = value.BytesOfClearData + value.BytesOfProtectedData;
            var sampleData = encodeWord.slice(0, len2);
            encodeBuffers.push(sampleData.slice(0, value.BytesOfClearData));
            decodeBuffers.push(sampleData.slice(value.BytesOfClearData));
            encodeWord = encodeWord.slice(len2);
          });
        } else {
          var len = item.size;
          encodeBuffers.push(encodeWord.slice(0, 0));
          decodeBuffers.push(encodeWord.slice(0, len));
          encodeWord = encodeWord.slice(len);
        }
        var tempBuffer = new Buffer();
        tempBuffer.write.apply(tempBuffer, decodeBuffers);
        var decrypted = customDescryptHandler ? customDescryptHandler(tempBuffer.buffer, key, iv) : Crypto.decryptWordArray(tempBuffer.buffer, key, iv);
        var buffer = new Buffer();
        encodeBuffers.forEach(function(clearDataBuf, i) {
          var protectedDataLen = decodeBuffers[i].length;
          var decodeProtectedData = decrypted.slice(0, protectedDataLen);
          buffer.write(clearDataBuf);
          buffer.write(decodeProtectedData);
          decrypted = decrypted.slice(protectedDataLen);
        });
        videoTrack.samples[index].data = buffer.buffer;
      });
    }
    if (audioTrack.audioSenc) {
      var _key = audioTrack.kidValue;
      var _senc = audioTrack.audioSenc;
      audioTrack.samples.forEach(function(item, index) {
        var sencBox = _senc[index];
        var dec = customDescryptHandler ? customDescryptHandler(item.data, _key, sencBox.InitializationVector) : Crypto.decryptWordArray(item.data, _key, sencBox.InitializationVector);
        audioTrack.samples[index].data = dec;
      });
    }
  }
};
export { Crypto as default };
