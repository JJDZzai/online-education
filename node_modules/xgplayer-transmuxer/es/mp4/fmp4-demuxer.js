import { createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
import { VideoTrack } from "../model/video-track.js";
import { AudioTrack } from "../model/audio-track.js";
import { VideoSample } from "../model/video-sample.js";
import { AudioSample } from "../model/audio-sample.js";
import { MetadataTrack } from "../model/metadata-track.js";
import { readBig32 } from "../utils/index.js";
import { MP4Parser } from "./mp4-parser.js";
var FMP4Demuxer = /* @__PURE__ */ function() {
  function FMP4Demuxer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck(this, FMP4Demuxer2);
    this.videoTrack = videoTrack || new VideoTrack();
    this.audioTrack = audioTrack || new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
  }
  _createClass(FMP4Demuxer2, [{
    key: "demux",
    value: function demux(videoData, audioData) {
      var videoTrack = this.videoTrack, audioTrack = this.audioTrack;
      var videoExist = videoTrack.exist();
      var audioExist = audioTrack.exist();
      videoTrack.samples = [];
      audioTrack.samples = [];
      if (audioData) {
        if (!audioExist) {
          var moovBox = MP4Parser.findBox(audioData, ["moov"])[0];
          if (!moovBox)
            throw new Error("cannot found moov box");
          MP4Parser.moovToTrack(MP4Parser.moov(moovBox), null, audioTrack);
        }
        var moofBox = MP4Parser.findBox(audioData, ["moof"])[0];
        if (moofBox) {
          var samples = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), null, audioTrack)[audioTrack.id];
          var baseMediaDecodeTime = audioTrack.baseMediaDecodeTime;
          if (samples) {
            var baseOffset = moofBox.start;
            samples.map(function(x) {
              x.offset += baseOffset;
              var sampleData = audioData.subarray(x.offset, x.offset + x.size);
              audioTrack.samples.push(new AudioSample(x.dts + baseMediaDecodeTime, sampleData, x.duration));
            });
          }
        }
      }
      if (videoData) {
        if (!videoExist && !audioExist) {
          var _moovBox = MP4Parser.findBox(videoData, ["moov"])[0];
          if (!_moovBox)
            throw new Error("cannot found moov box");
          MP4Parser.moovToTrack(MP4Parser.moov(_moovBox), videoTrack, audioTrack);
        }
        var _moofBox = MP4Parser.findBox(videoData, ["moof"])[0];
        if (_moofBox) {
          var tracks = MP4Parser.moofToSamples(MP4Parser.moof(_moofBox), videoTrack, audioTrack);
          var videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime;
          var audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime;
          var _baseOffset = _moofBox.start;
          var nalSize;
          Object.keys(tracks).forEach(function(k) {
            if (videoTrack.id == k) {
              tracks[k].map(function(x) {
                x.offset += _baseOffset;
                var sample = new VideoSample((x.pts || x.dts) + videoBaseMediaDecodeTime, x.dts + videoBaseMediaDecodeTime);
                sample.duration = x.duration;
                sample.gopId = x.gopId;
                if (x.keyframe)
                  sample.setToKeyframe();
                var sampleData = videoData.subarray(x.offset, x.offset + x.size);
                sample.data = sampleData;
                var start = 0;
                var len = sampleData.length - 1;
                while (start < len) {
                  nalSize = readBig32(sampleData, start);
                  start += 4;
                  sample.units.push(sampleData.subarray(start, start + nalSize));
                  start += nalSize;
                }
                videoTrack.samples.push(sample);
              });
            } else if (audioTrack.id == k) {
              tracks[k].map(function(x) {
                x.offset += _baseOffset;
                var sampleData = videoData.subarray(x.offset, x.offset + x.size);
                audioTrack.samples.push(new AudioSample(x.dts + audioBaseMediaDecodeTime, sampleData, x.duration));
              });
            }
          });
        }
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      this.videoTrack.reset();
      this.audioTrack.reset();
      this.metadataTrack.reset();
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      return MP4Parser.probe(data);
    }
  }]);
  return FMP4Demuxer2;
}();
export { FMP4Demuxer };
