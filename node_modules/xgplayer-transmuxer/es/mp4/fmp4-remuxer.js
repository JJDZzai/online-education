import { createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
import { MP4 } from "./mp4.js";
import { concatUint8Array } from "../utils/index.js";
import { Logger } from "./logger.js";
var FMP4Remuxer = /* @__PURE__ */ function() {
  function FMP4Remuxer2(videoTrack, audioTrack, options) {
    _classCallCheck(this, FMP4Remuxer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
    var browserVersions = /Chrome\/([^.]+)/.exec(navigator.userAgent);
    this.forceFirstIDR = browserVersions && Number(browserVersions[1]) < 50;
    this.log = new Logger("FMP4Remuxer", options && options.openLog ? !options.openLog : true);
  }
  _createClass(FMP4Remuxer2, [{
    key: "remux",
    value: function remux() {
      var createInit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      var hasVideo = videoTrack.exist();
      var hasAudio = audioTrack.exist();
      var videoInitSegment;
      var audioInitSegment;
      var initSegment;
      var tracks = [];
      if (createInit) {
        if (options && options.initMerge) {
          if (hasVideo) {
            tracks.push(this.videoTrack);
          }
          if (hasAudio) {
            tracks.push(this.audioTrack);
          }
          initSegment = MP4.initSegment(tracks);
        } else {
          if (hasVideo)
            videoInitSegment = MP4.initSegment([this.videoTrack]);
          if (hasAudio)
            audioInitSegment = MP4.initSegment([this.audioTrack]);
        }
      }
      var videoSegment;
      var audioSegment;
      if (hasVideo && videoTrack.hasSample()) {
        videoSegment = this._remuxVideo();
      }
      if (hasAudio && audioTrack.hasSample()) {
        audioSegment = this._remuxAudio();
      }
      videoTrack.samples = [];
      audioTrack.samples = [];
      return {
        initSegment,
        videoInitSegment,
        audioInitSegment,
        videoSegment,
        audioSegment
      };
    }
  }, {
    key: "_remuxVideo",
    value: function _remuxVideo() {
      var track = this.videoTrack;
      if (this.forceFirstIDR) {
        track.samples[0].flag = {
          dependsOn: 2,
          isNonSyncSample: 0
        };
      }
      var samples = track.samples;
      var mdatSize = 0;
      samples.forEach(function(s) {
        mdatSize += s.units.reduce(function(t, c) {
          return t + c.byteLength;
        }, 0);
        mdatSize += s.units.length * 4;
      });
      var mdata = new Uint8Array(mdatSize);
      var mdatView = new DataView(mdata.buffer);
      var _loop = function _loop2(_offset, _sample) {
        _sample = samples[i];
        var sampleSize = 0;
        _sample.units.forEach(function(u) {
          mdatView.setUint32(_offset, u.byteLength);
          _offset += 4;
          mdata.set(u, _offset);
          _offset += u.byteLength;
          sampleSize += 4 + u.byteLength;
        });
        _sample.size = sampleSize;
        offset = _offset, sample = _sample;
      };
      for (var i = 0, l = samples.length, offset = 0, sample; i < l; i++) {
        _loop(offset, sample);
      }
      var mdat = MP4.mdat(mdata);
      var moof = MP4.moof([track]);
      return concatUint8Array(moof, mdat);
    }
  }, {
    key: "_remuxAudio",
    value: function _remuxAudio() {
      var track = this.audioTrack;
      var mdata = new Uint8Array(track.samples.reduce(function(t, c) {
        return t + c.size;
      }, 0));
      track.samples.reduce(function(offset, s) {
        mdata.set(s.data, offset);
        return offset + s.size;
      }, 0);
      var mdat = MP4.mdat(mdata);
      var moof = MP4.moof([track]);
      return concatUint8Array(moof, mdat);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.videoTrack.reset();
      this.audioTrack.reset();
    }
  }]);
  return FMP4Remuxer2;
}();
export { FMP4Remuxer };
