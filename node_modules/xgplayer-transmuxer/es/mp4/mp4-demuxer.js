import { createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty, toConsumableArray as _toConsumableArray } from "../_virtual/_rollupPluginBabelHelpers.js";
import { VideoTrack } from "../model/video-track.js";
import { AudioTrack } from "../model/audio-track.js";
import { VideoSample } from "../model/video-sample.js";
import { AudioSample } from "../model/audio-sample.js";
import { MetadataTrack } from "../model/metadata-track.js";
import { readBig32 } from "../utils/index.js";
import { MP4Parser } from "./mp4-parser.js";
import { Logger } from "./logger.js";
import Crypto from "./crypto/crypto.js";
var NEW_ARRAY_MAX_CNT = 20;
var MP4Demuxer = /* @__PURE__ */ function() {
  function MP4Demuxer2(videoSegmnents, audioSegmnents, metadataTrack, options) {
    var _this = this;
    _classCallCheck(this, MP4Demuxer2);
    _defineProperty(this, "_videoSamples", []);
    _defineProperty(this, "_audioSamples", []);
    _defineProperty(this, "_lastRemainBuffer", []);
    _defineProperty(this, "_lastRemainBufferStartPos", 0);
    this.videoTrack = new VideoTrack();
    this.audioTrack = new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
    this.log = new Logger("MP4Demuxer", options && options.openLog ? !options.openLog : true);
    videoSegmnents && videoSegmnents.forEach(function(item) {
      var _this$_videoSamples;
      (_this$_videoSamples = _this._videoSamples).push.apply(_this$_videoSamples, _toConsumableArray(item.frames));
    });
    audioSegmnents && audioSegmnents.forEach(function(item) {
      var _this$_audioSamples;
      (_this$_audioSamples = _this._audioSamples).push.apply(_this$_audioSamples, _toConsumableArray(item.frames));
    });
  }
  _createClass(MP4Demuxer2, [{
    key: "parseSamples",
    value: function parseSamples(moov) {
      if (!moov) {
        throw new Error("moov is required");
      }
      if (!this.videoTrack.codec && !this.audioTrack.codec) {
        MP4Parser.moovToTrack(moov, this.videoTrack, this.audioTrack);
        this.videoSenc = this.videoTrack.videoSenc;
        this.audioSenc = this.audioTrack.audioSenc;
      }
      if (!this._audioSamples.length && !this._videoSamples.length) {
        var ret = MP4Parser.moovToSamples(moov);
        if (!ret)
          throw new Error("cannot parse samples from moov box");
        this._videoSamples = ret.videoSamples || [];
        this._audioSamples = ret.audioSamples || [];
      }
    }
  }, {
    key: "demux",
    value: function demux(data, dataStart, videoIndexRange, audioIndexRange, moov) {
      this.parseSamples(moov);
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      videoTrack.samples = [];
      audioTrack.samples = [];
      var sample;
      var sampleData;
      var startByte;
      if (videoIndexRange) {
        var frame;
        var nalSize = 0;
        for (var i = videoIndexRange[0], l = videoIndexRange[1]; i <= l; i++) {
          sample = this._videoSamples[i];
          if (!sample) {
            throw new Error("cannot found video frame #".concat(i));
          }
          startByte = sample.offset - dataStart;
          sampleData = data.subarray(startByte, startByte + sample.size);
          frame = new VideoSample(sample.pts || sample.dts, sample.dts);
          frame.duration = sample.duration;
          frame.gopId = sample.gopId;
          if (sample.keyframe)
            frame.setToKeyframe();
          var start = 0;
          var len = sampleData.length - 1;
          while (start < len) {
            nalSize = readBig32(sampleData, start);
            start += 4;
            frame.units.push(sampleData.subarray(start, start + nalSize));
            start += nalSize;
          }
          videoTrack.samples.push(frame);
        }
        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts;
      }
      if (audioIndexRange) {
        for (var _i = audioIndexRange[0], _l = audioIndexRange[1]; _i <= _l; _i++) {
          sample = this._audioSamples[_i];
          if (!sample) {
            throw new Error("cannot found video frame #".concat(_i));
          }
          startByte = sample.offset - dataStart;
          sampleData = data.subarray(startByte, startByte + sample.size);
          audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration));
        }
        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts;
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "demuxPart",
    value: function demuxPart(data, dataStart, videoIndexRange, audioIndexRange, moov, useEME, kidValue, customDescryptHandler) {
      this.parseSamples(moov);
      this.videoTrack.useEME = useEME;
      this.audioTrack.useEME = useEME;
      if (this._lastRemainBuffer && this._lastRemainBuffer.byteLength > 0 && dataStart > this._lastRemainBufferStartPos && dataStart <= this._lastRemainBufferStartPos + this._lastRemainBuffer.byteLength) {
        var tryCnt = 0;
        while (tryCnt < NEW_ARRAY_MAX_CNT) {
          try {
            var buffer = this._lastRemainBuffer.subarray(0, dataStart - this._lastRemainBufferStartPos);
            var temp = new Uint8Array(data.byteLength + buffer.byteLength);
            temp.set(buffer, 0);
            temp.set(new Uint8Array(data), buffer.byteLength);
            data = temp;
            dataStart -= buffer.byteLength;
            this._lastRemainBuffer = null;
            this._lastRemainBufferStartPos = 0;
            break;
          } catch (e) {
            if (tryCnt < NEW_ARRAY_MAX_CNT) {
              tryCnt++;
            } else {
              throw new Error("new Uint8Array error:," + e.errorMessage);
            }
          }
        }
      }
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      videoTrack.samples = [];
      audioTrack.samples = [];
      videoTrack.videoSenc = null;
      audioTrack.audioSenc = null;
      var sample;
      var sampleData;
      var startByte;
      var videoEndByte = 0;
      var audioEndByte = 0;
      if (this._videoSamples.length > 0 && videoIndexRange.length > 0) {
        var frame;
        var end = data.byteLength + dataStart;
        for (var i = videoIndexRange[0]; i <= videoIndexRange[1]; i++) {
          sample = this._videoSamples[i];
          if (!sample) {
            throw new Error("cannot found video frame #".concat(i));
          }
          if (sample.offset >= dataStart && sample.offset + sample.size <= end) {
            startByte = sample.offset - dataStart;
            videoEndByte = startByte + sample.size;
            sampleData = data.subarray(startByte, videoEndByte);
            frame = new VideoSample(sample.pts || sample.dts, sample.dts);
            frame.duration = sample.duration;
            frame.gopId = sample.gopId;
            frame.sampleOffset = sample.index;
            if (sample.keyframe)
              frame.setToKeyframe();
            frame.data = sampleData;
            frame.size = sample.size;
            videoTrack.samples.push(frame);
          }
        }
        if (videoTrack.samples.length > 0) {
          videoTrack.gopId = videoTrack.samples[0].gopId;
          videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts;
          videoTrack.startPts = videoTrack.samples[0].pts / videoTrack.timescale;
          videoTrack.endPts = videoTrack.samples[videoTrack.samples.length - 1].pts / videoTrack.timescale;
          if (this.videoSenc) {
            videoTrack.videoSenc = this.videoSenc.slice(videoTrack.samples[0].sampleOffset, videoTrack.samples[0].sampleOffset + videoTrack.samples.length);
            videoTrack.kidValue = kidValue;
          }
        }
      }
      if (this._audioSamples.length > 0 && audioIndexRange.length > 0) {
        for (var _i2 = audioIndexRange[0]; _i2 <= audioIndexRange[1]; _i2++) {
          sample = this._audioSamples[_i2];
          if (!sample) {
            throw new Error("cannot found video frame #".concat(_i2));
          }
          if (sample.offset >= dataStart && sample.offset + sample.size <= data.byteLength + dataStart) {
            startByte = sample.offset - dataStart;
            audioEndByte = startByte + sample.size;
            sampleData = data.subarray(startByte, audioEndByte);
            audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration, sample.index));
          }
        }
        if (audioTrack.samples.length > 0) {
          audioTrack.gopId = audioTrack.samples[0].gopId || videoTrack.gopId;
          audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts;
          audioTrack.startPts = audioTrack.samples[0].pts / audioTrack.timescale;
          audioTrack.endPts = audioTrack.samples[audioTrack.samples.length - 1].pts / audioTrack.timescale;
          if (this.audioSenc) {
            audioTrack.audioSenc = this.audioSenc.slice(audioTrack.samples[0].sampleOffset, audioTrack.samples[0].sampleOffset + audioTrack.samples.length);
            audioTrack.kidValue = kidValue;
          }
        }
      }
      this.decoderData(videoTrack, audioTrack, customDescryptHandler);
      var nalSize = 0;
      for (var _i3 = 0; _i3 < videoTrack.samples.length; _i3++) {
        var start = 0;
        var _sampleData = videoTrack.samples[_i3].data;
        var len = _sampleData.length - 1;
        while (start < len) {
          nalSize = readBig32(_sampleData, start);
          start += 4;
          videoTrack.samples[_i3].units.push(_sampleData.subarray(start, start + nalSize));
          start += nalSize;
        }
      }
      this._lastRemainBuffer = data.subarray(Math.max(videoEndByte, audioEndByte));
      if (this._lastRemainBuffer.byteLength > 0) {
        this._lastRemainBufferStartPos = dataStart + data.byteLength - this._lastRemainBuffer.byteLength;
      } else {
        this._lastRemainBufferStartPos = 0;
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      this._videoSamples = [];
      this._audioSamples = [];
      this._lastRemainBuffer = null;
      this._lastRemainBufferStartPos = 0;
      this.videoTrack.reset();
      this.audioTrack.reset();
      this.metadataTrack.reset();
    }
  }, {
    key: "decoderData",
    value: function decoderData(videoTrack, audioTrack, customDescryptHandler) {
      if (videoTrack.useEME || audioTrack.useEME)
        return;
      Crypto.decoderAESCTRData(videoTrack, audioTrack, customDescryptHandler);
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      return MP4Parser.probe(data);
    }
  }]);
  return MP4Demuxer2;
}();
export { MP4Demuxer };
