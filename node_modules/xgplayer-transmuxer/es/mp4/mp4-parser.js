import { createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
import { VideoCodecType, AudioCodecType } from "../model/types.js";
import { readBig32, readBig64, readBig24, readBig16, getAvcCodec } from "../utils/index.js";
import { AAC } from "../codec/aac.js";
var MP4Parser = /* @__PURE__ */ function() {
  function MP4Parser2() {
    _classCallCheck(this, MP4Parser2);
  }
  _createClass(MP4Parser2, null, [{
    key: "findBox",
    value: function findBox(data, names) {
      var start = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var ret = [];
      if (!data)
        return ret;
      var size = 0;
      var type = "";
      var headerSize = 0;
      while (data.length > 7) {
        size = readBig32(data);
        type = String.fromCharCode.apply(null, data.subarray(4, 8));
        headerSize = 8;
        if (size === 1) {
          size = readBig64(data, 8);
          headerSize += 8;
        } else if (!size) {
          size = data.length;
        }
        if (!names[0] || type === names[0]) {
          var subData = data.subarray(0, size);
          if (names.length < 2) {
            ret.push({
              start,
              size,
              headerSize,
              type,
              data: subData
            });
          } else {
            return MP4Parser2.findBox(subData.subarray(headerSize), names.slice(1), start + headerSize);
          }
        }
        start += size;
        data = data.subarray(size);
      }
      return ret;
    }
  }, {
    key: "tfhd",
    value: function tfhd(box) {
      return parseBox(box, true, function(ret, data) {
        ret.trackId = readBig32(data);
        var start = 4;
        var baseDataOffsetPresent = ret.flags & 255 & 1;
        var sampleDescriptionIndexPresent = ret.flags & 255 & 2;
        var defaultSampleDurationPresent = ret.flags & 255 & 8;
        var defaultSampleSizePresent = ret.flags & 255 & 16;
        var defaultSampleFlagsPresent = ret.flags & 255 & 32;
        if (baseDataOffsetPresent) {
          start += 4;
          ret.baseDataOffset = readBig32(data, start);
          start += 4;
        }
        if (sampleDescriptionIndexPresent) {
          ret.sampleDescriptionIndex = readBig32(data, start);
          start += 4;
        }
        if (defaultSampleDurationPresent) {
          ret.defaultSampleDuration = readBig32(data, start);
          start += 4;
        }
        if (defaultSampleSizePresent) {
          ret.defaultSampleSize = readBig32(data, start);
          start += 4;
        }
        if (defaultSampleFlagsPresent) {
          ret.defaultSampleFlags = readBig32(data, start);
        }
      });
    }
  }, {
    key: "sidx",
    value: function sidx(box) {
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        ret.reference_ID = readBig32(data, start);
        start += 4;
        ret.timescale = readBig32(data, start);
        start += 4;
        if (ret.version === 0) {
          ret.earliest_presentation_time = readBig32(data, start);
          start += 4;
          ret.first_offset = readBig32(data, start);
          start += 4;
        } else {
          ret.earliest_presentation_time = readBig64(data, start);
          start += 8;
          ret.first_offset = readBig64(data, start);
          start += 8;
        }
        start += 2;
        ret.references = [];
        var count = readBig16(data, start);
        start += 2;
        for (var i = 0; i < count; i++) {
          var ref = {};
          ret.references.push(ref);
          var tmp32 = readBig32(data, start);
          start += 4;
          ref.reference_type = tmp32 >> 31 & 1;
          ref.referenced_size = tmp32 & 2147483647;
          ref.subsegment_duration = readBig32(data, start);
          start += 4;
          tmp32 = readBig32(data, start);
          start += 4;
          ref.starts_with_SAP = tmp32 >> 31 & 1;
          ref.SAP_type = tmp32 >> 28 & 7;
          ref.SAP_delta_time = tmp32 & 268435455;
        }
      });
    }
  }, {
    key: "moov",
    value: function moov(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.mvhd = MP4Parser2.mvhd(MP4Parser2.findBox(data, ["mvhd"], start)[0]);
        ret.trak = MP4Parser2.findBox(data, ["trak"], start).map(function(trak) {
          return MP4Parser2.trak(trak);
        });
        ret.pssh = MP4Parser2.pssh(MP4Parser2.findBox(data, ["pssh"], start)[0]);
      });
    }
  }, {
    key: "mvhd",
    value: function mvhd(box) {
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        if (ret.version === 1) {
          ret.timescale = readBig32(data, 16);
          ret.duration = readBig64(data, 20);
          start += 28;
        } else {
          ret.timescale = readBig32(data, 8);
          ret.duration = readBig32(data, 12);
          start += 16;
        }
        ret.nextTrackId = readBig32(data, start + 76);
      });
    }
  }, {
    key: "trak",
    value: function trak(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.tkhd = MP4Parser2.tkhd(MP4Parser2.findBox(data, ["tkhd"], start)[0]);
        ret.mdia = MP4Parser2.mdia(MP4Parser2.findBox(data, ["mdia"], start)[0]);
      });
    }
  }, {
    key: "tkhd",
    value: function tkhd(box) {
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        if (ret.version === 1) {
          ret.trackId = readBig32(data, 16);
          ret.duration = readBig64(data, 24);
          start += 32;
        } else {
          ret.trackId = readBig32(data, 8);
          ret.duration = readBig32(data, 16);
          start += 20;
        }
        ret.width = readBig32(data, start + 52);
        ret.height = readBig32(data, start + 56);
      });
    }
  }, {
    key: "mdia",
    value: function mdia(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.mdhd = MP4Parser2.mdhd(MP4Parser2.findBox(data, ["mdhd"], start)[0]);
        ret.hdlr = MP4Parser2.hdlr(MP4Parser2.findBox(data, ["hdlr"], start)[0]);
        ret.minf = MP4Parser2.minf(MP4Parser2.findBox(data, ["minf"], start)[0]);
      });
    }
  }, {
    key: "mdhd",
    value: function mdhd(box) {
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        if (ret.version === 1) {
          ret.timescale = readBig32(data, 16);
          ret.duration = readBig64(data, 20);
          start += 28;
        } else {
          ret.timescale = readBig32(data, 8);
          ret.duration = readBig32(data, 12);
          start += 16;
        }
        var lang = readBig16(data, start);
        ret.language = String.fromCharCode((lang >> 10 & 31) + 96, (lang >> 5 & 31) + 96, (lang & 31) + 96);
      });
    }
  }, {
    key: "hdlr",
    value: function hdlr(box) {
      return parseBox(box, true, function(ret, data) {
        if (ret.version === 0) {
          ret.handlerType = String.fromCharCode.apply(null, data.subarray(4, 8));
        }
      });
    }
  }, {
    key: "minf",
    value: function minf(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.vmhd = MP4Parser2.vmhd(MP4Parser2.findBox(data, ["vmhd"], start)[0]);
        ret.smhd = MP4Parser2.smhd(MP4Parser2.findBox(data, ["smhd"], start)[0]);
        ret.stbl = MP4Parser2.stbl(MP4Parser2.findBox(data, ["stbl"], start)[0]);
      });
    }
  }, {
    key: "vmhd",
    value: function vmhd(box) {
      return parseBox(box, true, function(ret, data) {
        ret.graphicsmode = readBig16(data);
        ret.opcolor = [readBig16(data, 2), readBig16(data, 4), readBig16(data, 6)];
      });
    }
  }, {
    key: "smhd",
    value: function smhd(box) {
      return parseBox(box, true, function(ret, data) {
        ret.balance = readBig16(data);
      });
    }
  }, {
    key: "stbl",
    value: function stbl(box) {
      return parseBox(box, false, function(ret, data, start) {
        var _ret$stsd$entries$, _ret$stsd$entries$$si, _ret$stsd$entries$$si2;
        ret.stsd = MP4Parser2.stsd(MP4Parser2.findBox(data, ["stsd"], start)[0]);
        ret.stts = MP4Parser2.stts(MP4Parser2.findBox(data, ["stts"], start)[0]);
        ret.ctts = MP4Parser2.ctts(MP4Parser2.findBox(data, ["ctts"], start)[0]);
        ret.stsc = MP4Parser2.stsc(MP4Parser2.findBox(data, ["stsc"], start)[0]);
        ret.stsz = MP4Parser2.stsz(MP4Parser2.findBox(data, ["stsz"], start)[0]);
        ret.stco = MP4Parser2.stco(MP4Parser2.findBox(data, ["stco"], start)[0]);
        if (!ret.stco) {
          ret.co64 = MP4Parser2.co64(MP4Parser2.findBox(data, ["co64"], start)[0]);
          ret.stco = ret.co64;
        }
        var default_IV_size = (_ret$stsd$entries$ = ret.stsd.entries[0]) === null || _ret$stsd$entries$ === void 0 ? void 0 : (_ret$stsd$entries$$si = _ret$stsd$entries$.sinf) === null || _ret$stsd$entries$$si === void 0 ? void 0 : (_ret$stsd$entries$$si2 = _ret$stsd$entries$$si.schi) === null || _ret$stsd$entries$$si2 === void 0 ? void 0 : _ret$stsd$entries$$si2.tenc.default_IV_size;
        ret.stss = MP4Parser2.stss(MP4Parser2.findBox(data, ["stss"], start)[0]);
        ret.senc = MP4Parser2.senc(MP4Parser2.findBox(data, ["senc"], start)[0], default_IV_size);
      });
    }
  }, {
    key: "senc",
    value: function senc(box) {
      var iv = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        var sampleCount = readBig32(data, start);
        start += 4;
        ret.samples = [];
        for (var i = 0; i < sampleCount; i++) {
          var sample = {};
          sample.InitializationVector = [];
          for (var j = 0; j < iv; j++) {
            sample.InitializationVector[j] = data[start + j];
          }
          start += iv;
          if (ret.flags & 2) {
            sample.subsamples = [];
            var subsampleCount = readBig16(data, start);
            start += 2;
            for (var _j = 0; _j < subsampleCount; _j++) {
              var subsample = {};
              subsample.BytesOfClearData = readBig16(data, start);
              start += 2;
              subsample.BytesOfProtectedData = readBig32(data, start);
              start += 4;
              sample.subsamples.push(subsample);
            }
          }
          ret.samples.push(sample);
        }
      });
    }
  }, {
    key: "pssh",
    value: function pssh(box) {
      return parseBox(box, true, function(ret, data) {
        var keyIds = [];
        var systemId = [];
        var start = 0;
        for (var i = 0; i < 16; i++) {
          systemId.push(toHex(data[start + i]));
        }
        start += 16;
        if (ret.version > 0) {
          var numKeyIds = readBig32(data, start);
          start += 4;
          for (var _i = 0; _i < ("" + numKeyIds).length; _i++) {
            for (var j = 0; j < 16; j++) {
              var keyId = data[start];
              start += 1;
              keyIds.push(toHex(keyId));
            }
          }
        }
        var dataSize = readBig32(data, start);
        ret.data_size = dataSize;
        start += 4;
        ret.kid = keyIds;
        ret.system_id = systemId;
        ret.buffer = data;
      });
    }
  }, {
    key: "stsd",
    value: function stsd(box) {
      return parseBox(box, true, function(ret, data, start) {
        ret.entryCount = readBig32(data);
        ret.entries = MP4Parser2.findBox(data.subarray(4), [], start + 4).map(function(b) {
          switch (b.type) {
            case "avc1":
            case "avc2":
            case "avc3":
            case "avc4":
              return MP4Parser2.avc1(b);
            case "hvc1":
            case "hev1":
              return MP4Parser2.hvc1(b);
            case "mp4a":
              return MP4Parser2.mp4a(b);
            case "alaw":
            case "ulaw":
              return MP4Parser2.alaw(b);
            case "enca":
              return parseBox(b, false, function(ret2, data2, start2) {
                ret2.channelCount = readBig16(data2, 16);
                ret2.samplesize = readBig16(data2, 18);
                ret2.sampleRate = readBig32(data2, 24) / (1 << 16);
                data2 = data2.subarray(28);
                ret2.sinf = MP4Parser2.sinf(MP4Parser2.findBox(data2, ["sinf"], start2)[0]);
                ret2.esds = MP4Parser2.esds(MP4Parser2.findBox(data2, ["esds"], start2)[0]);
              });
            case "encv":
              return parseBox(b, false, function(ret2, data2, start2) {
                ret2.width = readBig16(data2, 24);
                ret2.height = readBig16(data2, 26);
                ret2.horizresolution = readBig32(data2, 28);
                ret2.vertresolution = readBig32(data2, 32);
                data2 = data2.subarray(78);
                ret2.sinf = MP4Parser2.sinf(MP4Parser2.findBox(data2, ["sinf"], start2)[0]);
                ret2.avcC = MP4Parser2.avcC(MP4Parser2.findBox(data2, ["avcC"], start2)[0]);
                ret2.hvcC = MP4Parser2.hvcC(MP4Parser2.findBox(data2, ["hvcC"], start2)[0]);
                ret2.pasp = MP4Parser2.pasp(MP4Parser2.findBox(data2, ["pasp"], start2)[0]);
              });
          }
        }).filter(Boolean);
      });
    }
  }, {
    key: "tenc",
    value: function tenc(box) {
      return parseBox(box, false, function(ret, data) {
        var start = 6;
        ret.default_IsEncrypted = data[start];
        start += 1;
        ret.default_IV_size = data[start];
        start += 1;
        ret.default_KID = [];
        for (var i = 0; i < 16; i++) {
          ret.default_KID.push(toHex(data[start]));
          start += 1;
        }
      });
    }
  }, {
    key: "schi",
    value: function schi(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.tenc = MP4Parser2.tenc(MP4Parser2.findBox(data, ["tenc"], start)[0]);
      });
    }
  }, {
    key: "sinf",
    value: function sinf(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.schi = MP4Parser2.schi(MP4Parser2.findBox(data, ["schi"], start)[0]);
        ret.frma = MP4Parser2.frma(MP4Parser2.findBox(data, ["frma"], start)[0]);
      });
    }
  }, {
    key: "frma",
    value: function frma(box) {
      return parseBox(box, false, function(ret, data) {
        ret.data_format = "";
        for (var i = 0; i < 4; i++) {
          ret.data_format += String.fromCharCode(data[i]);
        }
      });
    }
  }, {
    key: "avc1",
    value: function avc1(box) {
      return parseBox(box, false, function(ret, data, start) {
        var bodyStart = parseVisualSampleEntry(ret, data);
        var bodyData = data.subarray(bodyStart);
        start += bodyStart;
        ret.avcC = MP4Parser2.avcC(MP4Parser2.findBox(bodyData, ["avcC"], start)[0]);
        ret.pasp = MP4Parser2.pasp(MP4Parser2.findBox(bodyData, ["pasp"], start)[0]);
      });
    }
  }, {
    key: "avcC",
    value: function avcC(box) {
      return parseBox(box, false, function(ret, data) {
        ret.configurationVersion = data[0];
        ret.AVCProfileIndication = data[1];
        ret.profileCompatibility = data[2];
        ret.AVCLevelIndication = data[3];
        ret.codec = getAvcCodec([data[1], data[2], data[3]]);
        ret.lengthSizeMinusOne = data[4] & 3;
        ret.spsLength = data[5] & 31;
        ret.sps = [];
        var start = 6;
        for (var i = 0; i < ret.spsLength; i++) {
          var size = readBig16(data, start);
          start += 2;
          ret.sps.push(data.subarray(start, start + size));
          start += size;
        }
        ret.ppsLength = data[start];
        start += 1;
        ret.pps = [];
        for (var _i2 = 0; _i2 < ret.ppsLength; _i2++) {
          var _size = readBig16(data, start);
          start += 2;
          ret.pps.push(data.subarray(start, start += _size));
          start += _size;
        }
      });
    }
  }, {
    key: "hvc1",
    value: function hvc1(box) {
      return parseBox(box, false, function(ret, data, start) {
        var bodyStart = parseVisualSampleEntry(ret, data);
        var bodyData = data.subarray(bodyStart);
        start += bodyStart;
        ret.hvcC = MP4Parser2.hvcC(MP4Parser2.findBox(bodyData, ["hvcC"], start)[0]);
        ret.pasp = MP4Parser2.pasp(MP4Parser2.findBox(bodyData, ["pasp"], start)[0]);
      });
    }
  }, {
    key: "hvcC",
    value: function hvcC(box) {
      return parseBox(box, false, function(ret, data) {
        ret.data = box.data;
        ret.codec = "hev1.1.6.L93.B0";
        ret.configurationVersion = data[0];
        var tmp = data[1];
        ret.generalProfileSpace = tmp >> 6;
        ret.generalTierFlag = (tmp & 32) >> 5;
        ret.generalProfileIdc = tmp & 31;
        ret.generalProfileCompatibility = readBig32(data, 2);
        ret.generalConstraintIndicatorFlags = data.subarray(6, 12);
        ret.generalLevelIdc = data[12];
        ret.avgFrameRate = readBig16(data, 19);
        ret.numOfArrays = data[22];
        ret.vps = [];
        ret.sps = [];
        ret.pps = [];
        var start = 23;
        var type = 0;
        var numNalus = 0;
        var size = 0;
        for (var i = 0; i < ret.numOfArrays; i++) {
          type = data[start] & 63;
          numNalus = readBig16(data, start + 1);
          start += 3;
          var nalus = [];
          for (var j = 0; j < numNalus; j++) {
            size = readBig16(data, start);
            start += 2;
            nalus.push(data.subarray(start, start + size));
            start += size;
          }
          if (type === 32) {
            var _ret$vps;
            (_ret$vps = ret.vps).push.apply(_ret$vps, nalus);
          } else if (type === 33) {
            var _ret$sps;
            (_ret$sps = ret.sps).push.apply(_ret$sps, nalus);
          } else if (type === 34) {
            var _ret$pps;
            (_ret$pps = ret.pps).push.apply(_ret$pps, nalus);
          }
        }
      });
    }
  }, {
    key: "pasp",
    value: function pasp(box) {
      return parseBox(box, false, function(ret, data) {
        ret.hSpacing = readBig32(data);
        ret.vSpacing = readBig32(data, 4);
      });
    }
  }, {
    key: "mp4a",
    value: function mp4a(box) {
      return parseBox(box, false, function(ret, data, start) {
        var bodyStart = parseAudioSampleEntry(ret, data);
        ret.esds = MP4Parser2.esds(MP4Parser2.findBox(data.subarray(bodyStart), ["esds"], start + bodyStart)[0]);
      });
    }
  }, {
    key: "esds",
    value: function esds(box) {
      return parseBox(box, true, function(ret, data) {
        ret.codec = "mp4a.";
        var start = 0;
        var byteRead = 0;
        var size = 0;
        var tag = 0;
        while (data.length) {
          start = 0;
          tag = data[start];
          byteRead = data[start + 1];
          start += 2;
          while (byteRead & 128) {
            size = (byteRead & 127) << 7;
            byteRead = data[start];
            start += 1;
          }
          size += byteRead & 127;
          if (tag === 3) {
            data = data.subarray(start + 3);
          } else if (tag === 4) {
            ret.codec += (data[start].toString(16) + ".").padStart(3, "0");
            data = data.subarray(start + 13);
          } else if (tag === 5) {
            var config = ret.config = data.subarray(start, start + size);
            var objectType = (config[0] & 248) >> 3;
            if (objectType === 31 && config.length >= 2) {
              objectType = 32 + ((config[0] & 7) << 3) + ((config[1] & 224) >> 5);
            }
            ret.objectType = objectType;
            ret.codec += objectType.toString(16);
            if (ret.codec[ret.codec.length - 1] === ".") {
              ret.codec = ret.codec.substring(0, ret.codec.length - 1);
            }
            return;
          } else {
            if (ret.codec[ret.codec.length - 1] === ".") {
              ret.codec = ret.codec.substring(0, ret.codec.length - 1);
            }
            return;
          }
        }
      });
    }
  }, {
    key: "alaw",
    value: function alaw(box) {
      return parseBox(box, false, function(ret, data) {
        parseAudioSampleEntry(ret, data);
      });
    }
  }, {
    key: "stts",
    value: function stts(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push({
            count: readBig32(data, start),
            delta: readBig32(data, start + 4)
          });
          start += 8;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "ctts",
    value: function ctts(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        if (ret.version === 1) {
          for (var i = 0; i < entryCount; i++) {
            entries.push({
              count: readBig32(data, start),
              offset: readBig32(data, start + 4)
            });
            start += 8;
          }
        } else {
          for (var _i3 = 0; _i3 < entryCount; _i3++) {
            entries.push({
              count: readBig32(data, start),
              offset: -(~readBig32(data, start + 4) + 1)
            });
            start += 8;
          }
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "stsc",
    value: function stsc(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push({
            firstChunk: readBig32(data, start),
            samplesPerChunk: readBig32(data, start + 4),
            sampleDescriptionIndex: readBig32(data, start + 8)
          });
          start += 12;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "stsz",
    value: function stsz(box) {
      return parseBox(box, true, function(ret, data) {
        var sampleSize = readBig32(data);
        var sampleCount = readBig32(data, 4);
        var entrySizes = [];
        if (!sampleSize) {
          var start = 8;
          for (var i = 0; i < sampleCount; i++) {
            entrySizes.push(readBig32(data, start));
            start += 4;
          }
        }
        ret.sampleSize = sampleSize;
        ret.sampleCount = sampleCount;
        ret.entrySizes = entrySizes;
      });
    }
  }, {
    key: "stco",
    value: function stco(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push(readBig32(data, start));
          start += 4;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "co64",
    value: function co64(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push(readBig64(data, start));
          start += 8;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "stss",
    value: function stss(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push(readBig32(data, start));
          start += 4;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "moof",
    value: function moof(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.mfhd = MP4Parser2.mfhd(MP4Parser2.findBox(data, ["mfhd"], start)[0]);
        ret.traf = MP4Parser2.findBox(data, ["traf"], start).map(function(t) {
          return MP4Parser2.traf(t);
        });
      });
    }
  }, {
    key: "mfhd",
    value: function mfhd(box) {
      return parseBox(box, true, function(ret, data) {
        ret.sequenceNumber = readBig32(data);
      });
    }
  }, {
    key: "traf",
    value: function traf(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.tfhd = MP4Parser2.tfhd(MP4Parser2.findBox(data, ["tfhd"], start)[0]);
        ret.tfdt = MP4Parser2.tfdt(MP4Parser2.findBox(data, ["tfdt"], start)[0]);
        ret.trun = MP4Parser2.trun(MP4Parser2.findBox(data, ["trun"], start)[0]);
      });
    }
  }, {
    key: "trun",
    value: function trun(box) {
      return parseBox(box, true, function(ret, data) {
        var version = ret.version, flags = ret.flags;
        var dataLen = data.length;
        var sampleCount = ret.sampleCount = readBig32(data);
        var offset = 4;
        if (dataLen > offset && flags & 1) {
          ret.dataOffset = -(~readBig32(data, offset) + 1);
          offset += 4;
        }
        if (dataLen > offset && flags & 4) {
          ret.firstSampleFlags = readBig32(data, offset);
          offset += 4;
        }
        ret.samples = [];
        if (dataLen > offset) {
          var sample;
          for (var i = 0; i < sampleCount; i++) {
            sample = {};
            if (flags & 256) {
              sample.duration = readBig32(data, offset);
              offset += 4;
            }
            if (flags & 512) {
              sample.size = readBig32(data, offset);
              offset += 4;
            }
            if (flags & 1024) {
              sample.flags = readBig32(data, offset);
              offset += 4;
            }
            if (flags & 2048) {
              if (version) {
                sample.cts = -(~readBig32(data, offset + 4) + 1);
              } else {
                sample.cts = readBig32(data, offset);
              }
              offset += 4;
            }
            ret.samples.push(sample);
          }
        }
      });
    }
  }, {
    key: "tfdt",
    value: function tfdt(box) {
      return parseBox(box, true, function(ret, data) {
        if (ret.version === 1) {
          ret.baseMediaDecodeTime = readBig64(data);
        } else {
          ret.baseMediaDecodeTime = readBig32(data);
        }
      });
    }
  }, {
    key: "probe",
    value: function probe(data) {
      return !!MP4Parser2.findBox(data, ["ftyp"]);
    }
  }, {
    key: "parseSampleFlags",
    value: function parseSampleFlags(flags) {
      return {
        isLeading: (flags[0] & 12) >>> 2,
        dependsOn: flags[0] & 3,
        isDependedOn: (flags[1] & 192) >>> 6,
        hasRedundancy: (flags[1] & 48) >>> 4,
        paddingValue: (flags[1] & 14) >>> 1,
        isNonSyncSample: flags[1] & 1,
        degradationPriority: flags[2] << 8 | flags[3]
      };
    }
  }, {
    key: "moovToTrack",
    value: function moovToTrack(moov, videoTrack, audioTrack) {
      var _e$esds, _e$esds2;
      var tracks = moov.trak;
      if (!tracks || !tracks.length)
        return;
      var vTrack = tracks.find(function(t) {
        var _t$mdia, _t$mdia$hdlr;
        return ((_t$mdia = t.mdia) === null || _t$mdia === void 0 ? void 0 : (_t$mdia$hdlr = _t$mdia.hdlr) === null || _t$mdia$hdlr === void 0 ? void 0 : _t$mdia$hdlr.handlerType) === "vide";
      });
      var aTrack = tracks.find(function(t) {
        var _t$mdia2, _t$mdia2$hdlr;
        return ((_t$mdia2 = t.mdia) === null || _t$mdia2 === void 0 ? void 0 : (_t$mdia2$hdlr = _t$mdia2.hdlr) === null || _t$mdia2$hdlr === void 0 ? void 0 : _t$mdia2$hdlr.handlerType) === "soun";
      });
      if (vTrack && videoTrack) {
        var _vTrack$tkhd, _vTrack$mdia, _vTrack$mdia$minf, _vTrack$mdia$minf$stb, _vTrack$mdia2, _vTrack$mdia2$minf, _vTrack$mdia2$minf$st;
        var v = videoTrack;
        var _vTrackId = (_vTrack$tkhd = vTrack.tkhd) === null || _vTrack$tkhd === void 0 ? void 0 : _vTrack$tkhd.trackId;
        if (_vTrackId !== null && _vTrackId !== void 0)
          v.id = vTrack.tkhd.trackId;
        v.tkhdDuration = vTrack.tkhd.duration;
        v.mvhdDurtion = moov.mvhd.duration;
        v.mvhdTimecale = moov.mvhd.timescale;
        v.timescale = v.formatTimescale = vTrack.mdia.mdhd.timescale;
        v.duration = vTrack.mdia.mdhd.duration || v.mvhdDurtion / v.mvhdTimecale * v.timescale;
        var e1 = vTrack.mdia.minf.stbl.stsd.entries[0];
        v.width = e1.width;
        v.height = e1.height;
        if (e1.pasp) {
          v.sarRatio = [e1.pasp.hSpacing, e1.pasp.vSpacing];
        }
        if (e1.hvcC) {
          v.codecType = VideoCodecType.HEVC;
          v.codec = e1.hvcC.codec;
          v.vps = e1.hvcC.vps;
          v.sps = e1.hvcC.sps;
          v.pps = e1.hvcC.pps;
          v.hvcC = e1.hvcC.data;
        } else if (e1.avcC) {
          v.codec = e1.avcC.codec;
          v.sps = e1.avcC.sps;
          v.pps = e1.avcC.pps;
        } else {
          throw new Error("unknown video stsd entry");
        }
        v.present = true;
        v.ext = {};
        v.ext.stss = (_vTrack$mdia = vTrack.mdia) === null || _vTrack$mdia === void 0 ? void 0 : (_vTrack$mdia$minf = _vTrack$mdia.minf) === null || _vTrack$mdia$minf === void 0 ? void 0 : (_vTrack$mdia$minf$stb = _vTrack$mdia$minf.stbl) === null || _vTrack$mdia$minf$stb === void 0 ? void 0 : _vTrack$mdia$minf$stb.stss;
        v.ext.ctts = (_vTrack$mdia2 = vTrack.mdia) === null || _vTrack$mdia2 === void 0 ? void 0 : (_vTrack$mdia2$minf = _vTrack$mdia2.minf) === null || _vTrack$mdia2$minf === void 0 ? void 0 : (_vTrack$mdia2$minf$st = _vTrack$mdia2$minf.stbl) === null || _vTrack$mdia2$minf$st === void 0 ? void 0 : _vTrack$mdia2$minf$st.ctts;
        if (e1 && e1.type === "encv") {
          var _e1$sinf, _e1$sinf$schi, _e1$sinf2, _e1$sinf2$schi, _e1$sinf3, _e1$sinf3$schi, _e1$sinf4, _e1$sinf4$frma;
          v.isVideoEncryption = true;
          e1.default_KID = (_e1$sinf = e1.sinf) === null || _e1$sinf === void 0 ? void 0 : (_e1$sinf$schi = _e1$sinf.schi) === null || _e1$sinf$schi === void 0 ? void 0 : _e1$sinf$schi.tenc.default_KID;
          e1.default_IsEncrypted = (_e1$sinf2 = e1.sinf) === null || _e1$sinf2 === void 0 ? void 0 : (_e1$sinf2$schi = _e1$sinf2.schi) === null || _e1$sinf2$schi === void 0 ? void 0 : _e1$sinf2$schi.tenc.default_IsEncrypted;
          e1.default_IV_size = (_e1$sinf3 = e1.sinf) === null || _e1$sinf3 === void 0 ? void 0 : (_e1$sinf3$schi = _e1$sinf3.schi) === null || _e1$sinf3$schi === void 0 ? void 0 : _e1$sinf3$schi.tenc.default_IV_size;
          v.videoSenc = vTrack.mdia.minf.stbl.senc && vTrack.mdia.minf.stbl.senc.samples;
          e1.data_format = (_e1$sinf4 = e1.sinf) === null || _e1$sinf4 === void 0 ? void 0 : (_e1$sinf4$frma = _e1$sinf4.frma) === null || _e1$sinf4$frma === void 0 ? void 0 : _e1$sinf4$frma.data_format;
          v.useEME = moov.useEME;
          v.kidValue = moov.kidValue;
          v.pssh = moov.pssh;
          v.encv = e1;
        }
      }
      if (aTrack && audioTrack) {
        var _aTrack$tkhd, _e$esds3, _e$esds4, _aTrack$mdia, _aTrack$mdia$minf, _aTrack$mdia$minf$stb, _aTrack$mdia2, _aTrack$mdia2$minf, _aTrack$mdia2$minf$st;
        var a = audioTrack;
        var _aTrackId = (_aTrack$tkhd = aTrack.tkhd) === null || _aTrack$tkhd === void 0 ? void 0 : _aTrack$tkhd.trackId;
        if (_aTrackId !== null && _aTrackId !== void 0)
          a.id = aTrack.tkhd.trackId;
        a.tkhdDuration = aTrack.tkhd.duration;
        a.mvhdDurtion = moov.mvhd.duration;
        a.mvhdTimecale = moov.mvhd.timescale;
        a.timescale = a.formatTimescale = aTrack.mdia.mdhd.timescale;
        a.duration = aTrack.mdia.mdhd.duration || a.mvhdDurtion / a.mvhdTimecale * a.timescale;
        var _e = aTrack.mdia.minf.stbl.stsd.entries[0];
        a.sampleSize = _e.sampleSize;
        a.sampleRate = _e.sampleRate;
        a.channelCount = _e.channelCount;
        a.present = true;
        switch (_e.type) {
          case "alaw":
            a.codecType = a.codec = AudioCodecType.G711PCMA;
            a.sampleRate = 8e3;
            break;
          case "ulaw":
            a.codecType = a.codec = AudioCodecType.G711PCMU;
            a.sampleRate = 8e3;
            break;
          default:
            a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale);
            a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate);
            a.objectType = ((_e$esds = _e.esds) === null || _e$esds === void 0 ? void 0 : _e$esds.objectType) || 2;
            if (_e.esds)
              a.config = Array.from(_e.esds.config);
            a.codec = ((_e$esds2 = _e.esds) === null || _e$esds2 === void 0 ? void 0 : _e$esds2.codec) || "mp4a.40.2";
            break;
        }
        a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale);
        a.objectType = ((_e$esds3 = _e.esds) === null || _e$esds3 === void 0 ? void 0 : _e$esds3.objectType) || 2;
        if (_e.esds) {
          if (_e.esds.config) {
            a.config = Array.from(_e.esds.config);
          } else {
            console.warn("esds config is null");
          }
        }
        a.codec = ((_e$esds4 = _e.esds) === null || _e$esds4 === void 0 ? void 0 : _e$esds4.codec) || "mp4a.40.2";
        a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate);
        a.ext = {};
        a.ext.stss = (_aTrack$mdia = aTrack.mdia) === null || _aTrack$mdia === void 0 ? void 0 : (_aTrack$mdia$minf = _aTrack$mdia.minf) === null || _aTrack$mdia$minf === void 0 ? void 0 : (_aTrack$mdia$minf$stb = _aTrack$mdia$minf.stbl) === null || _aTrack$mdia$minf$stb === void 0 ? void 0 : _aTrack$mdia$minf$stb.stss;
        a.ext.ctts = (_aTrack$mdia2 = aTrack.mdia) === null || _aTrack$mdia2 === void 0 ? void 0 : (_aTrack$mdia2$minf = _aTrack$mdia2.minf) === null || _aTrack$mdia2$minf === void 0 ? void 0 : (_aTrack$mdia2$minf$st = _aTrack$mdia2$minf.stbl) === null || _aTrack$mdia2$minf$st === void 0 ? void 0 : _aTrack$mdia2$minf$st.ctts;
        a.present = true;
        if (_e && _e.type === "enca") {
          var _e$sinf, _e$sinf$frma, _e$sinf2, _e$sinf2$schi, _e$sinf3, _e$sinf3$schi, _e$sinf4, _e$sinf4$schi;
          a.isAudioEncryption = true;
          _e.data_format = (_e$sinf = _e.sinf) === null || _e$sinf === void 0 ? void 0 : (_e$sinf$frma = _e$sinf.frma) === null || _e$sinf$frma === void 0 ? void 0 : _e$sinf$frma.data_format;
          _e.default_KID = (_e$sinf2 = _e.sinf) === null || _e$sinf2 === void 0 ? void 0 : (_e$sinf2$schi = _e$sinf2.schi) === null || _e$sinf2$schi === void 0 ? void 0 : _e$sinf2$schi.tenc.default_KID;
          _e.default_IsEncrypted = (_e$sinf3 = _e.sinf) === null || _e$sinf3 === void 0 ? void 0 : (_e$sinf3$schi = _e$sinf3.schi) === null || _e$sinf3$schi === void 0 ? void 0 : _e$sinf3$schi.tenc.default_IsEncrypted;
          _e.default_IV_size = (_e$sinf4 = _e.sinf) === null || _e$sinf4 === void 0 ? void 0 : (_e$sinf4$schi = _e$sinf4.schi) === null || _e$sinf4$schi === void 0 ? void 0 : _e$sinf4$schi.tenc.default_IV_size;
          a.audioSenc = aTrack.mdia.minf.stbl.senc && aTrack.mdia.minf.stbl.senc.samples;
          a.useEME = moov.useEME;
          a.kidValue = moov.kidValue;
          a.enca = _e;
        }
      }
      audioTrack && (audioTrack.isVideoEncryption = videoTrack ? videoTrack.isVideoEncryption : false);
      videoTrack && (videoTrack.isAudioEncryption = audioTrack ? audioTrack.isAudioEncryption : false);
      if (videoTrack !== null && videoTrack !== void 0 && videoTrack.encv || audioTrack !== null && audioTrack !== void 0 && audioTrack.enca) {
        var _videoTrack$encv, _audioTrack$enca;
        var vkid = videoTrack === null || videoTrack === void 0 ? void 0 : (_videoTrack$encv = videoTrack.encv) === null || _videoTrack$encv === void 0 ? void 0 : _videoTrack$encv.default_KID;
        var akid = audioTrack === null || audioTrack === void 0 ? void 0 : (_audioTrack$enca = audioTrack.enca) === null || _audioTrack$enca === void 0 ? void 0 : _audioTrack$enca.default_KID;
        var kid = vkid || akid ? (vkid || akid).join("") : null;
        videoTrack && (videoTrack.kid = kid);
        audioTrack && (audioTrack.kid = kid);
      }
      videoTrack && (videoTrack.flags = 3841);
      audioTrack && (audioTrack.flags = 1793);
      return {
        videoTrack,
        audioTrack
      };
    }
  }, {
    key: "evaluateDefaultDuration",
    value: function evaluateDefaultDuration(videoTrack, audioTrack, videoSampleCount) {
      var _audioTrack$samples;
      var audioSampleCount = audioTrack === null || audioTrack === void 0 ? void 0 : (_audioTrack$samples = audioTrack.samples) === null || _audioTrack$samples === void 0 ? void 0 : _audioTrack$samples.length;
      if (!audioSampleCount)
        return 1024;
      var segmentDuration = 1024 * audioSampleCount / audioTrack.timescale;
      return segmentDuration * videoTrack.timescale / videoSampleCount;
    }
  }, {
    key: "moofToSamples",
    value: function moofToSamples(moof, videoTrack, audioTrack) {
      var ret = {};
      if (moof.mfhd) {
        if (videoTrack)
          videoTrack.sequenceNumber = moof.mfhd.sequenceNumber;
        if (audioTrack)
          audioTrack.sequenceNumber = moof.mfhd.sequenceNumber;
      }
      moof.traf.forEach(function(_ref) {
        var tfhd = _ref.tfhd, tfdt = _ref.tfdt, trun = _ref.trun;
        if (!tfhd || !trun)
          return;
        if (tfdt) {
          if (videoTrack && videoTrack.id === tfhd.trackId)
            videoTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime;
          if (audioTrack && audioTrack.id === tfhd.trackId)
            audioTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime;
        }
        var defaultSize = tfhd.defaultSampleSize || 0;
        var defaultDuration = tfhd.defaultSampleDuration || MP4Parser2.evaluateDefaultDuration(videoTrack, audioTrack, trun.samples.length || trun.sampleCount);
        var offset = trun.dataOffset || 0;
        var dts = 0;
        var gopId = -1;
        if (!trun.samples.length && trun.sampleCount) {
          ret[tfhd.trackId] = [];
          for (var i = 0; i < trun.sampleCount; i++) {
            ret[tfhd.trackId].push({
              offset,
              dts,
              duration: defaultDuration,
              size: defaultSize
            });
            dts += defaultDuration;
            offset += defaultSize;
          }
        } else {
          ret[tfhd.trackId] = trun.samples.map(function(s, index) {
            s = {
              offset,
              dts,
              pts: dts + (s.cts || 0),
              duration: s.duration || defaultDuration,
              size: s.size || defaultSize,
              gopId,
              keyframe: index === 0 || s.flags !== null && s.flags !== void 0 && (s.flags & 65536) >>> 0 !== 65536
            };
            if (s.keyframe) {
              gopId++;
              s.gopId = gopId;
            }
            dts += s.duration;
            offset += s.size;
            return s;
          });
        }
      });
      return ret;
    }
  }, {
    key: "moovToSamples",
    value: function moovToSamples(moov) {
      var tracks = moov.trak;
      if (!tracks || !tracks.length)
        return;
      var vTrack = tracks.find(function(t) {
        var _t$mdia3, _t$mdia3$hdlr;
        return ((_t$mdia3 = t.mdia) === null || _t$mdia3 === void 0 ? void 0 : (_t$mdia3$hdlr = _t$mdia3.hdlr) === null || _t$mdia3$hdlr === void 0 ? void 0 : _t$mdia3$hdlr.handlerType) === "vide";
      });
      var aTrack = tracks.find(function(t) {
        var _t$mdia4, _t$mdia4$hdlr;
        return ((_t$mdia4 = t.mdia) === null || _t$mdia4 === void 0 ? void 0 : (_t$mdia4$hdlr = _t$mdia4.hdlr) === null || _t$mdia4$hdlr === void 0 ? void 0 : _t$mdia4$hdlr.handlerType) === "soun";
      });
      if (!vTrack && !aTrack)
        return;
      var videoSamples;
      var audioSamples;
      if (vTrack) {
        var _vTrack$mdia3, _vTrack$mdia3$minf;
        var videoStbl = (_vTrack$mdia3 = vTrack.mdia) === null || _vTrack$mdia3 === void 0 ? void 0 : (_vTrack$mdia3$minf = _vTrack$mdia3.minf) === null || _vTrack$mdia3$minf === void 0 ? void 0 : _vTrack$mdia3$minf.stbl;
        if (!videoStbl)
          return;
        var stts = videoStbl.stts, stsc = videoStbl.stsc, stsz = videoStbl.stsz, stco = videoStbl.stco, stss = videoStbl.stss, ctts = videoStbl.ctts;
        if (!stts || !stsc || !stsz || !stco || !stss)
          return;
        videoSamples = getSamples(stts, stsc, stsz, stco, ctts, stss);
      }
      if (aTrack) {
        var _aTrack$mdia3, _aTrack$mdia3$minf, _aTrack$mdia$mdhd;
        var audioStbl = (_aTrack$mdia3 = aTrack.mdia) === null || _aTrack$mdia3 === void 0 ? void 0 : (_aTrack$mdia3$minf = _aTrack$mdia3.minf) === null || _aTrack$mdia3$minf === void 0 ? void 0 : _aTrack$mdia3$minf.stbl;
        if (!audioStbl)
          return;
        var timescale = (_aTrack$mdia$mdhd = aTrack.mdia.mdhd) === null || _aTrack$mdia$mdhd === void 0 ? void 0 : _aTrack$mdia$mdhd.timescale;
        var _stts = audioStbl.stts, _stsc = audioStbl.stsc, _stsz = audioStbl.stsz, _stco = audioStbl.stco;
        if (!timescale || !_stts || !_stsc || !_stsz || !_stco)
          return;
        audioSamples = getSamples(_stts, _stsc, _stsz, _stco);
      }
      return {
        videoSamples,
        audioSamples
      };
    }
  }]);
  return MP4Parser2;
}();
function getSamples(stts, stsc, stsz, stco, ctts, stss) {
  var samples = [];
  var cttsEntries = ctts === null || ctts === void 0 ? void 0 : ctts.entries;
  var stscEntries = stsc.entries;
  var stcoEntries = stco.entries;
  var stszEntrySizes = stsz.entrySizes;
  var stssEntries = stss === null || stss === void 0 ? void 0 : stss.entries;
  var keyframeMap;
  if (stssEntries) {
    keyframeMap = {};
    stssEntries.forEach(function(x) {
      keyframeMap[x - 1] = true;
    });
  }
  var cttsArr;
  if (cttsEntries) {
    cttsArr = [];
    cttsEntries.forEach(function(_ref2) {
      var count = _ref2.count, offset = _ref2.offset;
      for (var i = 0; i < count; i++) {
        cttsArr.push(offset);
      }
    });
  }
  var sample;
  var gopId = -1;
  var dts = 0;
  var pos = 0;
  var chunkIndex = 0;
  var chunkRunIndex = 0;
  var offsetInChunk = 0;
  var lastSampleInChunk = stscEntries[0].samplesPerChunk;
  var lastChunkInRun = stscEntries[1] ? stscEntries[1].firstChunk - 1 : Infinity;
  stts.entries.forEach(function(_ref3) {
    var count = _ref3.count, delta = _ref3.delta;
    for (var i = 0; i < count; i++) {
      sample = {
        dts,
        duration: delta,
        size: stszEntrySizes[pos] || stsz.sampleSize,
        offset: stcoEntries[chunkIndex] + offsetInChunk,
        index: pos
      };
      if (stssEntries) {
        sample.keyframe = keyframeMap[pos];
        if (sample.keyframe) {
          gopId++;
        }
        sample.gopId = gopId;
      }
      if (cttsArr && pos < cttsArr.length) {
        sample.pts = sample.dts + cttsArr[pos];
      }
      samples.push(sample);
      dts += delta;
      pos++;
      if (pos < lastSampleInChunk) {
        offsetInChunk += sample.size;
      } else {
        chunkIndex++;
        offsetInChunk = 0;
        if (chunkIndex >= lastChunkInRun) {
          chunkRunIndex++;
          lastChunkInRun = stscEntries[chunkRunIndex + 1] ? stscEntries[chunkRunIndex + 1].firstChunk - 1 : Infinity;
        }
        lastSampleInChunk += stscEntries[chunkRunIndex].samplesPerChunk;
      }
    }
  });
  return samples;
}
function parseVisualSampleEntry(ret, data) {
  ret.dataReferenceIndex = readBig16(data, 6);
  ret.width = readBig16(data, 24);
  ret.height = readBig16(data, 26);
  ret.horizresolution = readBig32(data, 28);
  ret.vertresolution = readBig32(data, 32);
  ret.frameCount = readBig16(data, 40);
  ret.depth = readBig16(data, 74);
  return 78;
}
function parseAudioSampleEntry(ret, data) {
  ret.dataReferenceIndex = readBig16(data, 6);
  ret.channelCount = readBig16(data, 16);
  ret.sampleSize = readBig16(data, 18);
  ret.sampleRate = readBig32(data, 24) / (1 << 16);
  return 28;
}
function parseBox(box, isFullBox, parse) {
  if (!box)
    return;
  if (box.size !== box.data.length)
    throw new Error("box ".concat(box.type, " size !== data.length"));
  var ret = {
    start: box.start,
    size: box.size,
    headerSize: box.headerSize,
    type: box.type
  };
  if (isFullBox) {
    ret.version = box.data[box.headerSize];
    ret.flags = readBig24(box.data, box.headerSize + 1);
    ret.headerSize += 4;
  }
  parse(ret, box.data.subarray(ret.headerSize), ret.start + ret.headerSize);
  return ret;
}
var padStart = function padStart2(str, length, pad) {
  var charstr = String(pad);
  var len = length >> 0;
  var maxlen = Math.ceil(len / charstr.length);
  var chars = [];
  var r = String(str);
  while (maxlen--) {
    chars.push(charstr);
  }
  return chars.join("").substring(0, len - r.length) + r;
};
var toHex = function toHex2() {
  var hex = [];
  for (var _len = arguments.length, value = new Array(_len), _key = 0; _key < _len; _key++) {
    value[_key] = arguments[_key];
  }
  value.forEach(function(item) {
    hex.push(padStart(Number(item).toString(16), 2, 0));
  });
  return hex[0];
};
export { MP4Parser };
