import { createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
import { TrackType } from "../model/types.js";
import { MP4 } from "./mp4.js";
import { concatUint8Array } from "../utils/index.js";
var MP4Remuxer = /* @__PURE__ */ function() {
  function MP4Remuxer2(videoTrack, audioTrack) {
    _classCallCheck(this, MP4Remuxer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
  }
  _createClass(MP4Remuxer2, [{
    key: "remux",
    value: function remux(videoTrack, audioTrack) {
      this.videoTrack = videoTrack || this.videoTrack;
      this.audioTrack = audioTrack || this.audioTrack;
      var hasVideo = (videoTrack === null || videoTrack === void 0 ? void 0 : videoTrack.exist()) && (videoTrack === null || videoTrack === void 0 ? void 0 : videoTrack.hasSample());
      var hasAudio = (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.exist()) && (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.hasSample());
      var videoSegment;
      var audioSegment;
      if (hasVideo && hasAudio) {
        videoSegment = this._remuxMix(videoTrack, audioTrack);
      } else if (hasVideo) {
        videoSegment = this._remuxTrack(videoTrack);
      } else if (hasAudio) {
        audioSegment = this._remuxTrack(audioTrack);
      }
      if (videoTrack) {
        videoTrack.samples = [];
      }
      if (audioTrack) {
        audioTrack.samples = [];
      }
      return {
        videoSegment,
        audioSegment
      };
    }
  }, {
    key: "_remuxMix",
    value: function _remuxMix(videoTrack, audioTrack) {
      var ftyp = MP4.ftyp([videoTrack, audioTrack]);
      var _this$_remuxData = this._remuxData(videoTrack, ftyp.byteLength + 8), video = _this$_remuxData.mdatData, chunkOffset = _this$_remuxData.chunkOffset;
      var _this$_remuxData2 = this._remuxData(audioTrack, chunkOffset), audio = _this$_remuxData2.mdatData;
      var mdat = MP4.mdat(concatUint8Array(video, audio));
      var moov = MP4.moovMP4([videoTrack, audioTrack]);
      videoTrack.ext = void 0;
      audioTrack.ext = void 0;
      videoTrack.samples = [];
      audioTrack.samples = [];
      return concatUint8Array(ftyp, mdat, moov);
    }
  }, {
    key: "_remuxTrack",
    value: function _remuxTrack(track) {
      var ftyp = MP4.ftyp([track]);
      var _this$_remuxData3 = this._remuxData(track, ftyp.byteLength + 8), mdatData = _this$_remuxData3.mdatData;
      var mdat = MP4.mdat(mdatData);
      var moov = MP4.moovMP4([track]);
      track.ext = void 0;
      track.samples = [];
      return concatUint8Array(ftyp, mdat, moov);
    }
  }, {
    key: "_remuxData",
    value: function _remuxData(track, chunkOffset) {
      var _this = this;
      var isVideo = track.type === TrackType.VIDEO;
      var samples = track.samples;
      var mdatSize = 0;
      if (isVideo) {
        samples.forEach(function(s) {
          mdatSize += s.units.reduce(function(t, c) {
            return t + c.byteLength;
          }, 0);
          mdatSize += s.units.length * 4;
        });
      } else {
        mdatSize = samples.reduce(function(t, c) {
          return t + c.size;
        }, 0);
      }
      var mdatData = new Uint8Array(mdatSize);
      var mdatView = new DataView(mdatData.buffer);
      var ext = track.ext = {
        stts: [],
        stsc: [],
        stsz: [],
        stco: [],
        stss: [],
        ctts: []
      };
      var samplesPerChunk = 1;
      var dataOffset = 0;
      var totalDuration = 0;
      var sample;
      var sampleLen = samples.length;
      var _loop = function _loop2() {
        sample = samples[i];
        totalDuration += sample.duration;
        var sampleSize = isVideo ? 0 : sample.size;
        if (isVideo) {
          sample.units.forEach(function(u) {
            mdatView.setUint32(dataOffset, u.byteLength);
            dataOffset += 4;
            mdatData.set(u, dataOffset);
            dataOffset += u.byteLength;
            sampleSize += 4 + u.byteLength;
          });
        } else {
          mdatData.set(sample.data, dataOffset);
          dataOffset += sampleSize;
        }
        sample.size = sampleSize;
        ext.stsz.push(sampleSize);
        if (isVideo)
          _this._fillCttsSamples(ext.ctts, sample.cts);
        _this._fillSttsSamples(ext.stts, sample, samples[i + 1]);
        _this._fillStcoSamples(ext.stco, i, samplesPerChunk, chunkOffset);
        chunkOffset += sampleSize;
        if (isVideo && sample.keyframe) {
          ext.stss.push(i + 1);
        }
      };
      for (var i = 0; i < sampleLen; i++) {
        _loop();
      }
      track.duration = totalDuration;
      this._fillStscSamples(ext.stsc, sampleLen, samplesPerChunk);
      return {
        mdatData,
        chunkOffset
      };
    }
  }, {
    key: "_fillSttsSamples",
    value: function _fillSttsSamples(sttsSamples, cur, next) {
      var lastSample = sttsSamples[sttsSamples.length - 1];
      if (next) {
        if (!lastSample || lastSample.value !== cur.duration) {
          sttsSamples.push({
            value: cur.duration,
            count: 1
          });
        } else {
          lastSample.count++;
        }
        return;
      }
      if (lastSample) {
        lastSample.count++;
      } else {
        sttsSamples.push({
          value: 40,
          count: 1
        });
      }
    }
  }, {
    key: "_fillCttsSamples",
    value: function _fillCttsSamples(cttsSamples, cts) {
      var lastSample = cttsSamples[cttsSamples.length - 1];
      if (!lastSample || lastSample.value !== cts) {
        cttsSamples.push({
          value: cts,
          count: 1
        });
      } else {
        lastSample.count++;
      }
    }
  }, {
    key: "_fillStcoSamples",
    value: function _fillStcoSamples(stcoSamples, index, samplePerChunk, chunkOffset) {
      if (!(index % samplePerChunk)) {
        stcoSamples.push(chunkOffset);
      }
    }
  }, {
    key: "_fillStscSamples",
    value: function _fillStscSamples(samples, sampleCount, samplesPerChunk) {
      if (sampleCount <= samplesPerChunk) {
        samples.push({
          firstChunk: 1,
          samplesPerChunk: sampleCount,
          sampleDescIndex: 1
        });
      } else {
        var len = Math.floor(sampleCount / samplesPerChunk);
        var remaining = sampleCount % samplesPerChunk;
        samples.push({
          firstChunk: 1,
          samplesPerChunk,
          sampleDescIndex: 1
        });
        if (remaining) {
          samples.push({
            firstChunk: len + 1,
            samplesPerChunk: remaining,
            sampleDescIndex: 1
          });
        }
      }
    }
  }]);
  return MP4Remuxer2;
}();
export { MP4Remuxer };
