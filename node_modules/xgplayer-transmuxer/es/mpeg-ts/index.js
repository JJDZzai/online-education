import { createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty, toConsumableArray as _toConsumableArray } from "../_virtual/_rollupPluginBabelHelpers.js";
import { TsFixer } from "./fixer.js";
import { AVC } from "../codec/avc.js";
import { AAC } from "../codec/aac.js";
import { HEVC } from "../codec/hevc.js";
import { NALu } from "../codec/nalu.js";
import { VideoTrack } from "../model/video-track.js";
import { AudioTrack } from "../model/audio-track.js";
import { VideoSample } from "../model/video-sample.js";
import { AudioSample } from "../model/audio-sample.js";
import { MetadataTrack, SeiSample } from "../model/metadata-track.js";
import { VideoCodecType } from "../model/types.js";
import { concatUint8Array } from "../utils/index.js";
import { Logger } from "../utils/logger.js";
var logger = new Logger("TsDemuxer");
var TsDemuxer = /* @__PURE__ */ function() {
  function TsDemuxer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck(this, TsDemuxer2);
    _defineProperty(this, "_pmtId", -1);
    _defineProperty(this, "_remainingPacketData", null);
    _defineProperty(this, "_videoPesData", []);
    _defineProperty(this, "_audioPesData", []);
    _defineProperty(this, "_gopId", 0);
    this.videoTrack = videoTrack || new VideoTrack();
    this.audioTrack = audioTrack || new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
    this._fixer = new TsFixer(this.videoTrack, this.audioTrack, this.metadataTrack);
  }
  _createClass(TsDemuxer2, [{
    key: "demux",
    value: function demux(data) {
      var discontinuity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var contiguous = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var audioTrack = this.audioTrack, videoTrack = this.videoTrack, metadataTrack = this.metadataTrack;
      if (discontinuity) {
        this._pmtId = -1;
        videoTrack.reset();
        audioTrack.reset();
        metadataTrack.reset();
      }
      if (!contiguous || discontinuity) {
        this._remainingPacketData = null;
        this._videoPesData = [];
        this._audioPesData = [];
      } else {
        videoTrack.samples = [];
        audioTrack.samples = [];
        metadataTrack.seiSamples = [];
        videoTrack.warnings = [];
        audioTrack.warnings = [];
        if (this._remainingPacketData) {
          data = concatUint8Array(this._remainingPacketData, data);
          this._remainingPacketData = null;
        }
      }
      var dataLen = data.length;
      var remainingLength = dataLen % 188;
      if (remainingLength) {
        this._remainingPacketData = data.subarray(dataLen - remainingLength);
        dataLen -= remainingLength;
      }
      var videoPid = videoTrack.pid;
      var audioPid = audioTrack.pid;
      for (var start = 0; start < dataLen; start += 188) {
        if (data[start] !== 71)
          throw new Error("TS packet did not start with 0x47");
        var payloadUnitStartIndicator = !!(data[start + 1] & 64);
        var pid = ((data[start + 1] & 31) << 8) + data[start + 2];
        var adaptationFiledControl = (data[start + 3] & 48) >> 4;
        var offset = void 0;
        if (adaptationFiledControl > 1) {
          offset = start + 5 + data[start + 4];
          if (offset === start + 188)
            continue;
        } else {
          offset = start + 4;
        }
        switch (pid) {
          case 0:
            if (payloadUnitStartIndicator)
              offset += data[offset] + 1;
            this._pmtId = (data[offset + 10] & 31) << 8 | data[offset + 11];
            break;
          case this._pmtId:
            {
              if (payloadUnitStartIndicator)
                offset += data[offset] + 1;
              var tableEnd = offset + 3 + ((data[offset + 1] & 15) << 8 | data[offset + 2]) - 4;
              var programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
              offset += 12 + programInfoLength;
              while (offset < tableEnd) {
                var esPid = (data[offset + 1] & 31) << 8 | data[offset + 2];
                switch (data[offset]) {
                  case 15:
                    audioTrack.pid = audioPid = esPid;
                    break;
                  case 27:
                    if (videoPid !== -1)
                      break;
                    videoTrack.codecType = VideoCodecType.AVC;
                    videoTrack.pid = videoPid = esPid;
                    break;
                  case 36:
                    if (videoPid !== -1)
                      break;
                    videoTrack.codecType = VideoCodecType.HEVC;
                    videoTrack.pid = videoPid = esPid;
                    break;
                  default:
                    logger.warn("Unsupported stream. type: ".concat(data[offset], ", pid: ").concat(esPid));
                }
                offset += ((data[offset + 3] & 15) << 8 | data[offset + 4]) + 5;
              }
            }
            break;
          case videoPid:
            if (payloadUnitStartIndicator && this._videoPesData.length) {
              this._parseVideoData();
            }
            this._videoPesData.push(data.subarray(offset, start + 188));
            break;
          case audioPid:
            if (payloadUnitStartIndicator && this._audioPesData.length) {
              this._parseAudioData();
            }
            this._audioPesData.push(data.subarray(offset, start + 188));
            break;
          case 17:
          case 8191:
            break;
          default:
            logger.warn("Unknown pid: ".concat(pid));
        }
      }
      this._parseVideoData();
      this._parseAudioData();
      audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 9e4;
      audioTrack.timescale = audioTrack.sampleRate || 0;
      return {
        videoTrack,
        audioTrack,
        metadataTrack
      };
    }
  }, {
    key: "fix",
    value: function fix(startTime, discontinuity, contiguous) {
      this._fixer.fix(startTime, discontinuity, contiguous);
      return {
        videoTrack: this.videoTrack,
        audioTrack: this.audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "demuxAndFix",
    value: function demuxAndFix(data, discontinuity, contiguous, startTime) {
      this.demux(data, discontinuity, contiguous);
      return this.fix(startTime, discontinuity, contiguous);
    }
  }, {
    key: "_parseVideoData",
    value: function _parseVideoData() {
      if (!this._videoPesData.length)
        return;
      var pes = TsDemuxer2._parsePES(concatUint8Array.apply(void 0, _toConsumableArray(this._videoPesData)));
      if (!pes) {
        logger.warn("Cannot parse video pes", this._videoPesData);
        return;
      }
      var units = NALu.parseAnnexB(pes.data);
      if (units) {
        this._createVideoSample(units, pes.pts, pes.dts);
      } else {
        logger.warn("Cannot parse avc units", pes);
      }
      this._videoPesData = [];
    }
  }, {
    key: "_createVideoSample",
    value: function _createVideoSample(units, pts, dts) {
      var _this = this;
      if (!units.length)
        return;
      var track = this.videoTrack;
      var isHevc = track.codecType === VideoCodecType.HEVC;
      var sample = new VideoSample(pts, dts);
      units.forEach(function(unit) {
        var type = isHevc ? unit[0] >>> 1 & 63 : unit[0] & 31;
        switch (type) {
          case 5:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
            if (!isHevc && type !== 5 || isHevc && type === 5)
              break;
            sample.setToKeyframe();
            _this._gopId++;
            break;
          case 6:
          case 39:
          case 40:
            if (!isHevc && type !== 6 || isHevc && type === 6)
              break;
            _this.metadataTrack.seiSamples.push(new SeiSample(NALu.parseSEI(NALu.removeEPB(unit), isHevc), pts));
            return;
          case 32:
            if (!isHevc)
              break;
            if (!track.vps.length) {
              var hvcC = HEVC.parseVPS(NALu.removeEPB(unit), track.hvcC);
              track.hvcC = track.hvcC || hvcC;
              track.vps = [unit];
            }
            break;
          case 7:
          case 33:
            if (!isHevc && type !== 7 || isHevc && type === 7)
              break;
            if (!track.sps.length) {
              var data = NALu.removeEPB(unit);
              var spsInfo = isHevc ? HEVC.parseSPS(data, track.hvcC) : AVC.parseSPS(data);
              track.sps = [unit];
              track.hvcC = track.hvcC || spsInfo.hvcC;
              track.codec = spsInfo.codec;
              track.width = spsInfo.width;
              track.height = spsInfo.height;
              track.sarRatio = spsInfo.sarRatio;
              track.fpsNum = spsInfo.fpsNum;
              track.fpsDen = spsInfo.fpsDen;
            }
            break;
          case 8:
          case 34:
            if (!isHevc && type !== 8 || isHevc && type === 8)
              break;
            if (!track.pps.length)
              track.pps = [unit];
            break;
        }
        sample.units.push(unit);
      });
      sample.gopId = this._gopId;
      this._pushVideoSample(track, sample);
    }
  }, {
    key: "_pushVideoSample",
    value: function _pushVideoSample(track, sample) {
      if (sample.units.length) {
        if (sample.pts === null || sample.pts === void 0) {
          logger.warn("Video sample no pts", sample);
          var lastSample = track.samples[track.samples.length - 1];
          if (lastSample) {
            sample.pts = lastSample.pts;
            sample.dts = lastSample.dts;
          } else {
            logger.warn("Drop video sample", sample);
          }
        } else {
          track.samples.push(sample);
        }
      }
    }
  }, {
    key: "_parseAudioData",
    value: function _parseAudioData() {
      if (!this._audioPesData.length)
        return;
      var pes = TsDemuxer2._parsePES(concatUint8Array.apply(void 0, _toConsumableArray(this._audioPesData)));
      if (!pes) {
        logger.warn("Cannot parse audio pes", this._audioPesData);
        return;
      }
      this._parseAacData(pes);
      this._audioPesData = [];
    }
  }, {
    key: "_parseAacData",
    value: function _parseAacData(pes) {
      var track = this.audioTrack;
      var pts = pes.pts;
      if (pts === null || pts === void 0) {
        logger.warn("AAC pes not pts", track);
        if (!track.samples.length || !track.sampleRate) {
          return;
        }
        pts = track.samples[track.samples.length - 1].pts + AAC.getFrameDuration(track.sampleRate);
      }
      var ret = AAC.parseADTS(pes.data, pts);
      if (ret) {
        var _track$samples;
        track.codec = ret.codec;
        track.channelCount = ret.channelCount;
        track.sampleRate = ret.sampleRate;
        track.objectType = ret.objectType;
        track.sampleRateIndex = ret.samplingFrequencyIndex;
        track.config = ret.config;
        (_track$samples = track.samples).push.apply(_track$samples, _toConsumableArray(ret.frames.map(function(s) {
          return new AudioSample(s.pts, s.data);
        })));
        if (ret.skip) {
          logger.warn("Skip aac adts ".concat(ret.skip, " bits"));
        }
        if (ret.remaining) {
          logger.warn("Remaining aac adts ".concat(ret.remaining, " bits"));
        }
      } else {
        logger.warn("Cannot parse aac adts", pes);
      }
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      if (!data.length)
        return false;
      return data[0] === 71 && data[188] === 71 && data[376] === 71;
    }
  }, {
    key: "_parsePES",
    value: function _parsePES(data) {
      var headerDataLen = data[8];
      if (headerDataLen === null || headerDataLen === void 0 || data.length < headerDataLen + 9)
        return;
      var startPrefix = data[0] << 16 | data[1] << 8 | data[2];
      if (startPrefix !== 1)
        return;
      var pesLen = (data[4] << 8) + data[5];
      if (pesLen && pesLen > data.length - 6)
        return;
      var pts;
      var dts;
      var ptsDtsFlags = data[7];
      if (ptsDtsFlags & 192) {
        pts = (data[9] & 14) * 536870912 + (data[10] & 255) * 4194304 + (data[11] & 254) * 16384 + (data[12] & 255) * 128 + (data[13] & 254) / 2;
        if (ptsDtsFlags & 64) {
          dts = (data[14] & 14) * 536870912 + (data[15] & 255) * 4194304 + (data[16] & 254) * 16384 + (data[17] & 255) * 128 + (data[18] & 254) / 2;
          if (pts - dts > 60 * 9e4)
            pts = dts;
        } else {
          dts = pts;
        }
      }
      return {
        data: data.subarray(9 + headerDataLen),
        pts,
        dts
      };
    }
  }]);
  return TsDemuxer2;
}();
export { TsDemuxer };
