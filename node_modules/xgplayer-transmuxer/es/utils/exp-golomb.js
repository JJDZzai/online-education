import { createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty } from "../_virtual/_rollupPluginBabelHelpers.js";
var ExpGolomb = /* @__PURE__ */ function() {
  function ExpGolomb2(data) {
    _classCallCheck(this, ExpGolomb2);
    _defineProperty(this, "_bytesAvailable", void 0);
    _defineProperty(this, "_bitsAvailable", 0);
    _defineProperty(this, "_word", 0);
    if (!data)
      throw new Error("ExpGolomb data params is required");
    this._data = data;
    this._bytesAvailable = data.byteLength;
    if (this._bytesAvailable)
      this._loadWord();
  }
  _createClass(ExpGolomb2, [{
    key: "_loadWord",
    value: function _loadWord() {
      var position = this._data.byteLength - this._bytesAvailable;
      var availableBytes = Math.min(4, this._bytesAvailable);
      if (availableBytes === 0)
        throw new Error("No bytes available");
      var workingBytes = new Uint8Array(4);
      workingBytes.set(this._data.subarray(position, position + availableBytes));
      this._word = new DataView(workingBytes.buffer).getUint32(0);
      this._bitsAvailable = availableBytes * 8;
      this._bytesAvailable -= availableBytes;
    }
  }, {
    key: "skipBits",
    value: function skipBits(count) {
      if (this._bitsAvailable > count) {
        this._word <<= count;
        this._bitsAvailable -= count;
      } else {
        count -= this._bitsAvailable;
        var skipBytes = Math.floor(count / 8);
        count -= skipBytes * 8;
        this._bytesAvailable -= skipBytes;
        this._loadWord();
        this._word <<= count;
        this._bitsAvailable -= count;
      }
    }
  }, {
    key: "readBits",
    value: function readBits(size) {
      if (size > 32) {
        throw new Error("Cannot read more than 32 bits");
      }
      var bits = Math.min(this._bitsAvailable, size);
      var val = this._word >>> 32 - bits;
      this._bitsAvailable -= bits;
      if (this._bitsAvailable > 0) {
        this._word <<= bits;
      } else if (this._bytesAvailable > 0) {
        this._loadWord();
      }
      bits = size - bits;
      if (bits > 0 && this._bitsAvailable) {
        return val << bits | this.readBits(bits);
      }
      return val;
    }
  }, {
    key: "skipLZ",
    value: function skipLZ() {
      var leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < this._bitsAvailable; ++leadingZeroCount) {
        if ((this._word & 2147483648 >>> leadingZeroCount) !== 0) {
          this._word <<= leadingZeroCount;
          this._bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this._loadWord();
      return leadingZeroCount + this.skipLZ();
    }
  }, {
    key: "skipUEG",
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }
  }, {
    key: "readUEG",
    value: function readUEG() {
      var clz = this.skipLZ();
      return this.readBits(clz + 1) - 1;
    }
  }, {
    key: "readEG",
    value: function readEG() {
      var val = this.readUEG();
      if (1 & val) {
        return 1 + val >>> 1;
      }
      return -1 * (val >>> 1);
    }
  }, {
    key: "readBool",
    value: function readBool() {
      return this.readBits(1) === 1;
    }
  }, {
    key: "readUByte",
    value: function readUByte() {
      return this.readBits(8);
    }
  }, {
    key: "skipScalingList",
    value: function skipScalingList(count) {
      var lastScale = 8;
      var nextScale = 8;
      var deltaScale;
      for (var j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }
  }]);
  return ExpGolomb2;
}();
export { ExpGolomb };
